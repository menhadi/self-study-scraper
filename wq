import requests
import json
import re
import os
import time
from google.oauth2 import service_account
from googleapiclient.discovery import build
from typing import Dict, List

# ==============================
#  MODEL SETTINGS
# ==============================
ANSWER_MODEL = "gpt-4.1"
ANSWER_TEMP = 0.0

# ========================================
#  LATEX TO UNICODE CONVERSION
# ========================================
def convert_latex_to_unicode(text):
    """Convert LaTeX math symbols to Unicode characters"""
    if not isinstance(text, str):
        return text
    
    # Common LaTeX to Unicode conversions
    latex_to_unicode = {
        # Greek letters
        r'\\alpha': 'Œ±', r'\\beta': 'Œ≤', r'\\gamma': 'Œ≥', r'\\Gamma': 'Œì',
        r'\\delta': 'Œ¥', r'\\Delta': 'Œî', r'\\epsilon': 'Œµ', r'\\varepsilon': 'Œµ',
        r'\\zeta': 'Œ∂', r'\\eta': 'Œ∑', r'\\theta': 'Œ∏', r'\\Theta': 'Œò',
        r'\\iota': 'Œπ', r'\\kappa': 'Œ∫', r'\\lambda': 'Œª', r'\\Lambda': 'Œõ',
        r'\\mu': 'Œº', r'\\nu': 'ŒΩ', r'\\xi': 'Œæ', r'\\Xi': 'Œû',
        r'\\pi': 'œÄ', r'\\Pi': 'Œ†', r'\\rho': 'œÅ', r'\\sigma': 'œÉ',
        r'\\Sigma': 'Œ£', r'\\tau': 'œÑ', r'\\upsilon': 'œÖ', r'\\Upsilon': 'Œ•',
        r'\\phi': 'œÜ', r'\\Phi': 'Œ¶', r'\\chi': 'œá', r'\\psi': 'œà',
        r'\\Psi': 'Œ®', r'\\omega': 'œâ', r'\\Omega': 'Œ©',
        
        # Math operators
        r'\\times': '√ó', r'\\div': '√∑', r'\\pm': '¬±', r'\\mp': '‚àì',
        r'\\cdot': '¬∑', r'\\ast': '*', r'\\star': '‚ãÜ',
        r'\\leq': '‚â§', r'\\geq': '‚â•', r'\\neq': '‚â†',
        r'\\approx': '‚âà', r'\\sim': '‚àº', r'\\propto': '‚àù',
        r'\\infty': '‚àû', r'\\partial': '‚àÇ', r'\\nabla': '‚àá',
        r'\\forall': '‚àÄ', r'\\exists': '‚àÉ', r'\\in': '‚àà', r'\\notin': '‚àâ',
        r'\\subset': '‚äÇ', r'\\subseteq': '‚äÜ', r'\\supset': '‚äÉ', r'\\supseteq': '‚äá',
        r'\\cup': '‚à™', r'\\cap': '‚à©', r'\\wedge': '‚àß', r'\\vee': '‚à®',
        r'\\neg': '¬¨', r'\\rightarrow': '‚Üí', r'\\Rightarrow': '‚áí',
        r'\\leftarrow': '‚Üê', r'\\Leftarrow': '‚áê', r'\\leftrightarrow': '‚Üî',
        r'\\Leftrightarrow': '‚áî',
        
        # Fractions
        r'\\frac\{([^}]+)\}\{([^}]+)\}': lambda m: f"({m.group(1)})/({m.group(2)})",
        r'\\frac ([^ ]+) ([^ ]+)': lambda m: f"({m.group(1)})/({m.group(2)})",
        
        # Superscripts and subscripts
        r'\^\{([^}]+)\}': lambda m: '^' + m.group(1),
        r'_\{([^}]+)\}': lambda m: '_' + m.group(1),
        r'\^(\d+)': lambda m: '^' + m.group(1),
        r'_(\d+)': lambda m: '_' + m.group(1),
        
        # Square roots
        r'\\sqrt\{([^}]+)\}': lambda m: '‚àö(' + m.group(1) + ')',
        r'\\sqrt\[([^]]+)\]\{([^}]+)\}': lambda m: m.group(1) + '‚àö(' + m.group(2) + ')',
        
        # Integrals and sums
        r'\\int': '‚à´', r'\\sum': '‚àë', r'\\prod': '‚àè',
        
        # Common functions
        r'\\sin': 'sin', r'\\cos': 'cos', r'\\tan': 'tan',
        r'\\log': 'log', r'\\ln': 'ln', r'\\exp': 'exp',
        
        # Remove LaTeX environments
        r'\\begin\{[^}]+\}': '', r'\\end\{[^}]+\}': '',
        r'\$': '', r'\\[': '', r'\\]': '',
        
        # Remove braces but keep content
        r'\{([^}]+)\}': lambda m: m.group(1),
    }
    
    # Apply conversions
    converted = text
    for pattern, replacement in latex_to_unicode.items():
        if callable(replacement):
            converted = re.sub(pattern, replacement, converted)
        else:
            converted = converted.replace(pattern, replacement)
    
    # Remove any remaining LaTeX artifacts
    converted = re.sub(r'\\[a-zA-Z]+', '', converted)
    converted = re.sub(r'\s+', ' ', converted).strip()
    
    return converted

# ========================================
#  CLEAN TEXT FUNCTION
# ========================================
def clean_text(text):
    """Remove emojis, markdown, and ensure proper formatting"""
    if not isinstance(text, str):
        return text
    
    # Remove emojis and emoticons
    text = re.sub(r'[\U00010000-\U0010ffff]', '', text)
    text = re.sub(r'[^\x00-\x7F]+', '', text)
    
    # Remove markdown formatting
    text = re.sub(r'[*_`~#]', '', text)
    text = re.sub(r'\[([^\]]+)\]\([^)]+\)', r'\1', text)  # Remove markdown links
    
    # Remove any HTML tags except table tags
    text = re.sub(r'<(?!table|tr|th|td|/table|/tr|/th|/td)[^>]*>', '', text)
    
    # Ensure proper line breaks
    text = re.sub(r'\n\s*\n\s*\n+', '\n\n', text)
    
    # Convert LaTeX to Unicode
    text = convert_latex_to_unicode(text)
    
    return text.strip()

# ========================================
#  ANSWER GENERATION MODULE
# ========================================
class AnswerGenerator:
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://api.openai.com/v1/chat/completions"
        self.headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {api_key}"
        }

    # ==========================================
    # ANSWER GENERATION
    # ==========================================
    def analyze_question(self, q: Dict) -> Dict:
        """
        Generate answers for questions - handles both MCQ and Fill-in-Blank
        """
        qtype = q.get("type", "MCQ")
        
        # Get question text with image references
        question_text = self._prepare_question_text(q)

        if qtype == "FILL_IN_BLANK":
            return self._answer_fill_blank(q, question_text)
        else:
            return self._answer_mcq(q, question_text)

    # ------------------------------------
    # PREPARE QUESTION TEXT WITH IMAGE REFERENCES
    # ------------------------------------
    def _prepare_question_text(self, q):
        """Prepare question text with image references if present"""
        text = q.get('text', '')
        
        # Add image references if present
        if q.get('has_q_image', '').lower() == 'true':
            text += "\n[Note: This question includes an image. Refer to the image in the question when solving.]"
        
        # Add option images if present
        opt_images = q.get('opt_images', '')
        if opt_images and opt_images.strip():
            # Parse the comma-separated list of image URLs
            image_urls = [url.strip() for url in opt_images.split(',') if url.strip()]
            for i, url in enumerate(image_urls):
                # Clean the URL - remove any extra quotes or brackets
                url = url.strip('"\'[]')
                if url.startswith('http'):
                    text += f"\n[Option {chr(65+i)} image: {url}]"
        
        # Add instructions if present
        instructions = q.get('instructions', '')
        if instructions and instructions.strip():
            text += f"\n\nInstructions: {instructions}"
        
        return text

    # ------------------------------------
    # ANSWER FILL-IN-THE-BLANK
    # ------------------------------------
    def _answer_fill_blank(self, q, question_text):
        prompt = f"""
You are an exam-solving expert. This is a FILL-IN-THE-BLANK question.

Question:
{question_text}

CRITICAL REQUIREMENTS:
1. For fill-in-blank questions, the answer MUST be the ACTUAL CALCULATED VALUE or TEXT that fills the blank
2. NEVER use A, B, C, or D as the answer for fill-in-blank questions
3. Provide the exact numeric value, text, or formula result
4. Give a CLEAR solution with essential steps and brief explanation
5. Use Unicode math symbols only (NO LaTeX, NO $$, NO \frac, etc.)
6. Confidence score 0-100
7. If you need to show a table, use proper HTML table tags: <table><tr><th>Header</th></tr><tr><td>Data</td></tr></table>
8. No emojis, no markdown, no asterisks for emphasis
9. Solution should be BALANCED: not too verbose, not too brief. Include key reasoning.
10. Include necessary formulas, substitutions, and the final calculation.

IMPORTANT: The "correct_answer" field must contain ONLY the actual value that fills the blank, not an option letter.

GOOD EXAMPLE FORMAT:
"Using the velocity formula v = u + at. Given: initial velocity u = 0 m/s, acceleration a = 2.5 m/s¬≤, time t = 5 s.
Substitute values: v = 0 + 2.5 √ó 5 = 12.5 m/s."

JSON FORMAT (EXACTLY as shown below, with proper field names):
{{
  "correct_answer": "12.5",
  "solution": "Using v = u + at. Given u = 0 m/s, a = 2.5 m/s¬≤, t = 5 s. Substituting: v = 0 + 2.5 √ó 5 = 12.5 m/s.",
  "confidence": 92
}}

CRITICAL: Response must be valid JSON with these EXACT field names: "correct_answer", "solution", "confidence"
"""

        result = self._call_answer_model(prompt, qtype="FILL_IN_BLANK")
        
        # Clean the result
        result["correct_answer"] = clean_text(result.get("correct_answer", ""))
        result["solution"] = clean_text(result.get("solution", ""))
        
        # CRITICAL FIX: Extract actual value from solution if answer is still an option letter
        answer = result.get("correct_answer", "").strip().upper()
        solution = result.get("solution", "")
        
        # If answer is still A/B/C/D, try to extract the actual value from the solution
        if answer in ["A", "B", "C", "D"]:
            print(f"‚ö†Ô∏è  GPT returned option '{answer}' instead of value. Extracting from solution...")
            
            # Try to find numeric values in the solution
            numeric_values = re.findall(r'\b\d+\.?\d*\b', solution)
            calculated_values = re.findall(r'=\s*([\d\.]+)', solution)
            final_values = re.findall(r'(\d+\.?\d*)\s*(?:m/s|N|kg|s|m|¬∞|percent|%|V|A|Œ©|Hz|Pa|W|J)', solution, re.IGNORECASE)
            
            # Combine all found values
            all_values = numeric_values + calculated_values + final_values
            
            if all_values:
                # Take the last calculated value (usually the final answer)
                actual_value = all_values[-1]
                result["correct_answer"] = actual_value
                print(f"‚úÖ Extracted value '{actual_value}' from solution")
            else:
                # If no value found, retry with STRICT instruction
                print("üîÑ No value found in solution, retrying with strict instruction...")
                strict_prompt = prompt + "\n\nCRITICAL: The 'correct_answer' MUST be a numeric value like '12.5', '45', or text answer. NEVER use A, B, C, D."
                result = self._call_answer_model(strict_prompt, qtype="FILL_IN_BLANK")
                
                # Clean the retry result
                result["correct_answer"] = clean_text(result.get("correct_answer", ""))
                result["solution"] = clean_text(result.get("solution", ""))
                
                # Double-check the retry result
                retry_answer = result.get("correct_answer", "").strip().upper()
                if retry_answer in ["A", "B", "C", "D"]:
                    # Force a default value
                    result["correct_answer"] = "0"
                    result["solution"] = "ERROR: Could not extract proper value. " + result["solution"]
                    result["confidence"] = 0
            
        return result

    # ------------------------------------
    # ANSWER MCQ - BALANCED SOLUTIONS
    # ------------------------------------
    def _answer_mcq(self, q, question_text):
        prompt = f"""
You are an exam-solving expert. Solve this MCQ with clear, balanced reasoning.

Question:
{question_text}

Options:
A: {q.get('option_a','')}
B: {q.get('option_b','')}
C: {q.get('option_c','')}
D: {q.get('option_d','')}

CRITICAL REQUIREMENTS FOR BALANCED SOLUTIONS:
1. Choose ONLY A, B, C, or D
2. Provide a CLEAR, BALANCED solution with key reasoning
3. Not too verbose, not too brief. Include essential steps and logic.
4. For calculation problems: Show formula, substitutions, and calculation
5. For conceptual problems: Explain the key concept and why other options are incorrect
6. Use Unicode math symbols only (NO LaTeX, NO $$, NO \frac, etc.)
7. Confidence score 0-100
8. If you need to show a table, use proper HTML table tags
9. No emojis, no markdown, no asterisks
10. If images are mentioned, refer to them appropriately

BALANCED SOLUTION EXAMPLES:
Calculation Example:
"Using stress formula œÉ = P/A. Given P = 5000 N, diameter = 20 mm ‚Üí radius = 10 mm = 0.01 m.
Area A = œÄr¬≤ = œÄ √ó (0.01)¬≤ = 3.1416 √ó 0.0001 = 0.000314 m¬≤.
Stress œÉ = 5000 / 0.000314 = 15.92 √ó 10‚Å∂ Pa = 15.92 MPa.
This matches Option B."

Conceptual Example:
"For subsonic passenger aircraft, fuel efficiency is critical. High-bypass turbofan engines provide the best specific fuel consumption due to their high propulsive efficiency from moving large air mass at lower velocity. Turbojets with afterburners are inefficient for subsonic flight. Option C shows the correct engine type."

JSON FORMAT (EXACTLY as shown below, with proper field names):
{{
  "correct_answer": "B",
  "solution": "Using œÉ = P/A where P = 5000 N. Diameter = 20 mm ‚Üí radius = 10 mm = 0.01 m. Area A = œÄr¬≤ = œÄ √ó (0.01)¬≤ = 0.000314 m¬≤. Stress œÉ = 5000 / 0.000314 = 15.92 MPa, which matches Option B.",
  "confidence": 92
}}

CRITICAL: Response must be valid JSON with these EXACT field names: "correct_answer", "solution", "confidence"
"""

        return self._call_answer_model(prompt, qtype="MCQ")

    # ------------------------------------
    # CALL GPT-4.1 WITH JSON PARSING
    # ------------------------------------
    def _call_answer_model(self, prompt, qtype="MCQ"):
        payload = {
            "model": ANSWER_MODEL,
            "temperature": ANSWER_TEMP,
            "messages": [{"role": "user", "content": prompt}],
            "max_tokens": 1000,  # Balanced for medium-length solutions
            "response_format": {"type": "json_object"}  # Force JSON response
        }

        try:
            r = requests.post(self.base_url, headers=self.headers, json=payload, timeout=60)
            if r.status_code != 200:
                return {
                    "correct_answer": "Error",
                    "solution": f"API error: {r.status_code}",
                    "confidence": 0
                }

            content = r.json()["choices"][0]["message"]["content"]
            
            # Parse JSON with robust error handling
            result = self._safe_json(content, qtype)
            
            # Clean the parsed result
            result["correct_answer"] = clean_text(result.get("correct_answer", ""))
            result["solution"] = clean_text(result.get("solution", ""))
            
            # Check if solution is balanced (not too brief)
            if result["solution"] and len(result["solution"].split()) < 15:
                print(f"‚ö†Ô∏è  Solution too brief ({len(result['solution'].split())} words), requesting more detail...")
                # Retry with emphasis on balanced solution
                balance_prompt = prompt + "\n\nIMPORTANT: Provide a more balanced solution with key reasoning, not just the final answer."
                balance_result = self._call_answer_model(balance_prompt, qtype)
                if len(balance_result.get("solution", "").split()) >= 15:
                    result = balance_result
            
            return result

        except Exception as e:
            print(f"‚ùå API call error: {e}")
            return {
                "correct_answer": "Error",
                "solution": f"Exception: {e}",
                "confidence": 0
            }

    # ------------------------------------
    # SAFE JSON PARSER FOR ANSWERS
    # ------------------------------------
    def _safe_json(self, text, qtype="MCQ"):
        # Clean the text first
        text = text.strip()
        
        # Remove markdown code blocks
        text = re.sub(r'```json|```', '', text)
        
        # Try to find JSON object with very flexible parsing
        json_match = re.search(r'\{.*\}', text, re.DOTALL)
        if json_match:
            json_str = json_match.group()
            
            try:
                # Try to parse as JSON
                result = json.loads(json_str)
                
                # Fix common field name issues
                field_mapping = {
                    'correctanswer': 'correct_answer',
                    'correctAnswer': 'correct_answer',
                    'CorrectAnswer': 'correct_answer',
                    'Answer': 'correct_answer',
                    'answer': 'correct_answer',
                    'Solution': 'solution',
                    'solution_text': 'solution',
                    'explanation': 'solution',
                    'Explanation': 'solution',
                    'detailed_solution': 'solution',
                    'Confidence': 'confidence',
                    'confidence_score': 'confidence',
                    'confidence_level': 'confidence'
                }
                
                # Rename fields if needed
                for old_key, new_key in field_mapping.items():
                    if old_key in result and new_key not in result:
                        result[new_key] = result.pop(old_key)
                
                # Ensure all required fields exist with defaults
                if "correct_answer" not in result:
                    # Try to extract answer from text
                    if qtype == "MCQ":
                        # Look for A/B/C/D in the text
                        match = re.search(r'[ABCD]', text, re.IGNORECASE)
                        result["correct_answer"] = match.group().upper() if match else ""
                    else:
                        result["correct_answer"] = ""
                else:
                    # Ensure correct_answer is string and uppercase for MCQ
                    if qtype == "MCQ":
                        result["correct_answer"] = str(result["correct_answer"]).strip().upper()
                        if result["correct_answer"] not in ["A", "B", "C", "D"]:
                            # Try to find A/B/C/D in the solution
                            solution_text = result.get("solution", "")
                            match = re.search(r'[ABCD]', solution_text, re.IGNORECASE)
                            if match:
                                result["correct_answer"] = match.group().upper()
                    
                if "solution" not in result:
                    # Use the full text as solution
                    result["solution"] = text
                else:
                    # Ensure solution is a string and clean it
                    result["solution"] = str(result["solution"])
                
                if "confidence" not in result:
                    result["confidence"] = 0
                else:
                    try:
                        result["confidence"] = int(float(str(result["confidence"])))
                    except:
                        result["confidence"] = 0
                
                return result
                
            except json.JSONDecodeError:
                # Fall back to manual parsing
                pass
        
        # If JSON parsing fails, try to extract information manually
        # Extract answer
        correct_answer = ""
        if qtype == "MCQ":
            # Look for A/B/C/D in the text
            match = re.search(r'["\']?(correct_?answer|answer|correct)["\']?\s*[:=]\s*["\']?([ABCD])["\']?', text, re.IGNORECASE)
            if match:
                correct_answer = match.group(2).upper()
            else:
                # Try to find standalone A/B/C/D
                match = re.search(r'\b([ABCD])\b', text, re.IGNORECASE)
                if match:
                    correct_answer = match.group(1).upper()
        else:
            # For fill-in-blank, look for numeric or text answers
            match = re.search(r'["\']?(correct_?answer|answer)["\']?\s*[:=]\s*["\']?([^"\',}]+)["\']?', text, re.IGNORECASE)
            if match:
                correct_answer = match.group(2).strip()
        
        # Extract confidence
        confidence = 0
        conf_match = re.search(r'["\']?confidence["\']?\s*[:=]\s*["\']?(\d+)["\']?', text, re.IGNORECASE)
        if conf_match:
            try:
                confidence = int(conf_match.group(1))
            except:
                confidence = 0
        
        # Extract solution
        solution = ""
        sol_match = re.search(r'["\']?solution["\']?\s*[:=]\s*["\']?([^"\']+)["\']?', text, re.IGNORECASE | re.DOTALL)
        if sol_match:
            solution = sol_match.group(1).strip()
        else:
            # Try to find solution content between quotes or after field name
            sol_match2 = re.search(r'solution["\']?\s*[:=]\s*["\']([^"\']+)["\']', text, re.IGNORECASE | re.DOTALL)
            if sol_match2:
                solution = sol_match2.group(1).strip()
            else:
                # Use everything after the answer as solution
                lines = text.split('\n')
                for i, line in enumerate(lines):
                    if re.search(r'correct_?answer|answer|correct', line, re.IGNORECASE):
                        # Take the next lines as solution
                        solution = '\n'.join(lines[i+1:]).strip()
                        break
                if not solution:
                    solution = text
        
        return {
            "correct_answer": clean_text(correct_answer),
            "solution": clean_text(solution),
            "confidence": confidence
        }

    # -----------------------------------------------
    # GET ANSWERS SEQUENTIALLY
    # -----------------------------------------------
    def get_answers_sequential(self, questions: List[Dict]) -> List[Dict]:
        output = []

        for i, q in enumerate(questions):
            if "error" in q:
                output.append(q)
                continue

            print(f"\n{'='*60}")
            print(f"üß† Solving question {i+1}/{len(questions)}: {q.get('number', 'Unknown')} ({q.get('type', 'MCQ')})")
            print(f"{'='*60}")
            
            # Show question preview
            q_text_preview = q.get('text', '')[:100] + "..." if len(q.get('text', '')) > 100 else q.get('text', '')
            print(f"üìã Question: {q_text_preview}")
            
            try:
                ans = self.analyze_question(q)
                combined = {**q, **ans}
                output.append(combined)
                
                # Show answer details
                correct_answer = ans.get('correct_answer', '')
                confidence = ans.get('confidence', 0)
                print(f"‚úÖ Correct Answer: {correct_answer}")
                print(f"üìä Confidence: {confidence}%")
                
                # Show solution preview
                solution = ans.get('solution', '')
                if solution:
                    solution_preview = solution[:120] + "..." if len(solution) > 120 else solution
                    print(f"üìù Solution: {solution_preview}")
                    
                    # Show word count for quality check
                    word_count = len(solution.split())
                    if word_count < 15:
                        print(f"‚ö†Ô∏è  Solution might be too brief ({word_count} words)")
                    elif word_count > 150:
                        print(f"‚ÑπÔ∏è  Solution is detailed ({word_count} words)")
                    else:
                        print(f"‚úì  Balanced solution ({word_count} words)")
                
            except Exception as e:
                print(f"‚ùå Error: {e}")
                output.append({**q, "correct_answer": "Error", "solution": f"Processing error: {e}", "confidence": 0})

            time.sleep(1.0)

        return output


# =====================================================
#  GOOGLE SHEET ANSWER PROCESSOR
# =====================================================
class GoogleSheetAnswerProcessor:
    def __init__(self, credentials_file: str, sheet_id: str, api_key: str, sheet_tab: str):
        self.sheet_id = sheet_id
        self.sheet_tab = sheet_tab
        self.answer_generator = AnswerGenerator(api_key)
        self.service = self._auth(credentials_file)

    # ----------------------
    # AUTH
    # ----------------------
    def _auth(self, credentials_file):
        try:
            scopes = ['https://www.googleapis.com/auth/spreadsheets']
            creds = service_account.Credentials.from_service_account_file(
                credentials_file, scopes=scopes)
            return build('sheets', 'v4', credentials=creds)
        except Exception as e:
            print("Google Sheets Auth Failed:", e)
            raise

    # ----------------------
    # READ EXISTING QUESTIONS FROM SHEET
    # ----------------------
    def read_existing_questions(self):
        """
        Read already extracted questions from sheet (columns A-M)
        """
        try:
            result = self.service.spreadsheets().values().get(
                spreadsheetId=self.sheet_id,
                range=f"{self.sheet_tab}!A:M"
            ).execute()

            values = result.get("values", [])
            if len(values) < 2:
                return []

            questions = []
            
            for i, row in enumerate(values[1:], start=2):
                if len(row) < 4:
                    continue
                    
                question = {
                    "file_name": row[0] if len(row) > 0 else "",
                    "type": row[1] if len(row) > 1 else "",
                    "number": row[2] if len(row) > 2 else "",
                    "text": row[3] if len(row) > 3 else "",
                    "option_a": row[4] if len(row) > 4 else "",
                    "option_b": row[5] if len(row) > 5 else "",
                    "option_c": row[6] if len(row) > 6 else "",
                    "option_d": row[7] if len(row) > 7 else "",
                    "has_q_image": row[8] if len(row) > 8 else "",
                    "opt_images": row[9] if len(row) > 9 else "",
                    "has_instructions": row[10] if len(row) > 10 else "",
                    "instructions": row[11] if len(row) > 11 else "",
                    "row_number": i
                }
                
                if question["text"] and question["text"].strip():
                    questions.append(question)

            print(f"üìñ Read {len(questions)} existing questions from sheet")
            return questions

        except Exception as e:
            print("Error reading questions from sheet:", e)
            return []

    # ----------------------
    # CHECK PENDING STATUS IN COLUMN O
    # ----------------------
    def check_pending_questions(self):
        """
        Check column O for "pending" status to determine which questions need answers
        Returns: set of row numbers that have "pending" in column O
        """
        try:
            result = self.service.spreadsheets().values().get(
                spreadsheetId=self.sheet_id,
                range=f"{self.sheet_tab}!O:O"
            ).execute()

            values = result.get("values", [])
            if len(values) < 2:
                return set()
            
            pending_rows = set()
            for i, row in enumerate(values[1:], start=2):
                if len(row) > 0 and row[0].strip().lower() == "pending":
                    pending_rows.add(i)
            
            print(f"üìä Found {len(pending_rows)} rows with 'pending' status in column O")
            return pending_rows

        except Exception as e:
            print("Error checking pending status:", e)
            return set()

    # ----------------------
    # CHECK EXISTING ANSWERS IN COLUMNS L-N
    # ----------------------
    def check_existing_answers(self):
        """
        Check if answers already exist in columns L-N
        Returns: set of row numbers that have valid answers
        """
        try:
            result = self.service.spreadsheets().values().get(
                spreadsheetId=self.sheet_id,
                range=f"{self.sheet_tab}!L:N"
            ).execute()

            values = result.get("values", [])
            if len(values) < 2:
                return set()
            
            answered_rows = set()
            for i, row in enumerate(values[1:], start=2):
                # Check if column L (correct_answer) has content and is not "Error"
                if len(row) >= 1 and row[0] and row[0].strip() and row[0].strip().lower() != "error":
                    answered_rows.add(i)
            
            print(f"üìä Found {len(answered_rows)} rows with existing answers")
            return answered_rows

        except Exception as e:
            print("Error checking existing answers:", e)
            return set()

    # ----------------------
    # UPDATE SHEET WITH ANSWERS AND STATUS
    # ----------------------
    def update_sheet_with_answers(self, questions_with_answers: List[Dict]):
        if not questions_with_answers:
            print("No answers to update")
            return

        updates = []
        overwrite_count = 0
        new_count = 0
        
        for q in questions_with_answers:
            row_num = q.get("row_number", 0)
            if row_num == 0:
                continue
                
            confidence = q.get("confidence", 0)
            if isinstance(confidence, str):
                confidence_match = re.search(r'\d+', str(confidence))
                confidence = confidence_match.group() if confidence_match else "0"
            
            # Update columns L, M, N with answers and column O with "Done"
            updates.append({
                "range": f"{self.sheet_tab}!L{row_num}:O{row_num}",
                "values": [[
                    q.get("correct_answer", ""),  # Column L: correct_answer
                    q.get("solution", ""),        # Column M: solution
                    str(confidence),              # Column N: confidence
                    "Done"                        # Column O: status update
                ]]
            })
            
            # Track whether this is an overwrite or new answer
            if q.get("has_existing_answer", False):
                overwrite_count += 1
            else:
                new_count += 1

        try:
            body = {
                "valueInputOption": "RAW",
                "data": updates
            }
            result = self.service.spreadsheets().values().batchUpdate(
                spreadsheetId=self.sheet_id,
                body=body
            ).execute()
            
            print(f"\n‚úÖ Updated {len(updates)} rows:")
            print(f"   - New answers: {new_count}")
            print(f"   - Overwritten answers: {overwrite_count}")
            
        except Exception as e:
            print("Update failed:", e)

    # ----------------------
    # PROCESS ANSWERS FOR ALL QUESTIONS
    # ----------------------
    def process_all_answers(self, overwrite_pending=True):
        print("üîç Reading existing questions from sheet...")
        questions = self.read_existing_questions()
        
        if not questions:
            print("‚ùå No questions found in sheet")
            return

        # Check which questions have "pending" in column O
        pending_rows = self.check_pending_questions()
        
        # Check which rows already have answers
        answered_rows = self.check_existing_answers()
        
        if not pending_rows:
            print("\nüéâ No pending questions found in column O!")
            return

        # Get pending rows that already have answers
        pending_with_answers = {row: True for row in pending_rows if row in answered_rows}
        
        if pending_with_answers:
            print(f"\n‚ö†Ô∏è  Found {len(pending_with_answers)} rows with 'pending' status that already have answers")
            print(f"   These answers will be {'OVERWRITTEN' if overwrite_pending else 'SKIPPED'}")
            
            if not overwrite_pending:
                print("   Skipping these rows as per overwrite_pending=False")
                # Remove these from pending_rows
                pending_rows = pending_rows - set(pending_with_answers.keys())

        questions_to_process = []
        for q in questions:
            row_num = q.get("row_number")
            
            # Skip if not pending in column O
            if row_num not in pending_rows:
                continue
                
            # Check if this row already has an answer
            has_existing_answer = row_num in answered_rows
            
            # If overwrite is disabled and row has existing answer, skip it
            if has_existing_answer and not overwrite_pending:
                continue
            
            # Add flag to track overwrites
            q["has_existing_answer"] = has_existing_answer
            questions_to_process.append(q)
        
        print(f"\nüìù Questions to process: {len(questions_to_process)}")
        
        if questions_to_process:
            mcq_count = len([q for q in questions_to_process if q.get("type") == "MCQ"])
            fill_count = len([q for q in questions_to_process if q.get("type") == "FILL_IN_BLANK"])
            overwrite_count = len([q for q in questions_to_process if q.get("has_existing_answer", False)])
            new_count = len(questions_to_process) - overwrite_count
            
            print(f"üìä Breakdown:")
            print(f"   - MCQ: {mcq_count}")
            print(f"   - Fill-in-Blank: {fill_count}")
            print(f"   - New answers: {new_count}")
            print(f"   - Overwrite existing: {overwrite_count}")
        else:
            print("\nüéâ No questions to process!")
            return

        print("\nüß† Generating balanced solutions...")
        print("‚ö†Ô∏è  Note: Solutions will be balanced - not too verbose, not too brief")
        
        questions_with_answers = self.answer_generator.get_answers_sequential(questions_to_process)

        print("\nüíæ Saving answers to sheet and updating status...")
        self.update_sheet_with_answers(questions_with_answers)

        print("\n" + "="*60)
        print("üéâ ANSWER GENERATION COMPLETED!")
        print("="*60)
        print("üìä Summary:")
        print(f"  - Total processed: {len(questions_with_answers)}")
        print(f"  - Column L: correct_answer")
        print(f"  - Column M: solution (balanced explanation)")
        print(f"  - Column N: confidence")
        print(f"  - Column O: Updated to 'Done'")
        print("="*60)


# =====================================================
# MAIN RUNNER
# =====================================================

def main():
    OPENAI_API_KEY = "your_openai_api_key_here"

    if not OPENAI_API_KEY or OPENAI_API_KEY == "your_openai_api_key_here":
        print("‚ùå ERROR: Please put your real OpenAI API key in the script.")
        return

    GOOGLE_SHEET_ID = "1U6gW0yqh3GZlkyxvhF_5k3sXMP8GwZT-TNsXqKv7S1o"
    CREDENTIALS_FILE = "service-account.json"
    SHEET_TAB = "Sheet4"
    OVERWRITE_PENDING = True  # Set to True to overwrite existing answers for pending rows

    print("\n" + "="*80)
    print(" üß† BALANCED ANSWER GENERATION SCRIPT")
    print("="*80)
    print(f" Answer Model     : {ANSWER_MODEL}")
    print(f" Overwrite Pending: {'YES' if OVERWRITE_PENDING else 'NO'}")
    print(f" Status Column    : O (pending/Done)")
    print("="*80)
    print(" KEY FEATURES:")
    print(" 1. BALANCED solutions - not too verbose, not too brief")
    print(" 2. Includes essential reasoning and key steps")
    print(" 3. Auto-retry if solution is too brief (<15 words)")
    print(" 4. Overwrites existing answers for rows with 'pending' status")
    print(" 5. Processes ONLY rows with 'pending' in column O")
    print("="*80)

    try:
        processor = GoogleSheetAnswerProcessor(
            CREDENTIALS_FILE,
            GOOGLE_SHEET_ID,
            OPENAI_API_KEY,
            SHEET_TAB
        )

        processor.process_all_answers(overwrite_pending=OVERWRITE_PENDING)

    except Exception as e:
        print("\n‚ùå FATAL ERROR:", e)
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
