import gspread
from google.oauth2.service_account import Credentials
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, PageBreak, Table, TableStyle, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.lib import colors
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from googleapiclient.discovery import build
import os
import logging
import pandas as pd
import re
import requests
from io import BytesIO
import urllib.parse
from bs4 import BeautifulSoup  # For HTML parsing

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# Google Sheets and Drive setup
SCOPE = [
    "https://www.googleapis.com/auth/spreadsheets",
    "https://www.googleapis.com/auth/drive"
]

# Column names in Google Sheets
COLUMN_FOLDER = 'Folder'
COLUMN_SUB_FOLDER = 'Sub Folder'
COLUMN_FILE_NAME = 'File Name'
COLUMN_QUESTION_NO = 'Question No'
COLUMN_QUESTION_TEXT = 'Question Text'
COLUMN_INSTRUCTIONS = 'Instructions'
COLUMN_OPTION_A = 'Option A'
COLUMN_OPTION_B = 'Option B'
COLUMN_OPTION_C = 'Option C'
COLUMN_OPTION_D = 'Option D'
COLUMN_QUESTION_IMAGE_URL = 'Question Image URL'
COLUMN_OPTION_A_IMAGE_URL = 'Option A Image URL'
COLUMN_OPTION_B_IMAGE_URL = 'Option B Image URL'
COLUMN_OPTION_C_IMAGE_URL = 'Option C Image URL'
COLUMN_OPTION_D_IMAGE_URL = 'Option D Image URL'
COLUMN_CORRECT_OPTION = 'Correct Option'
COLUMN_EXPLANATION = 'Explanation'
COLUMN_CONTENT = 'Content'
COLUMN_PDF_URLS = 'PDF urls'

# -----------------------------------------------------------
# ✅ UNICODE FONT PATH (YOUR EXACT LOCATION)
# -----------------------------------------------------------
FONT_DIR = r"C:\Users\menha\Downloads\dejavu-fonts-ttf-2.37\dejavu-fonts-ttf-2.37\ttf"
UNICODE_FONT = "DejaVuSans"
UNICODE_FONT_BOLD = "DejaVuSans-Bold"

pdfmetrics.registerFont(TTFont(UNICODE_FONT, os.path.join(FONT_DIR, "DejaVuSans.ttf")))
pdfmetrics.registerFont(TTFont(UNICODE_FONT_BOLD, os.path.join(FONT_DIR, "DejaVuSans-Bold.ttf")))

logging.info("✅ DejaVu Unicode fonts loaded successfully.")

class PDFGenerator:
    def __init__(self, credentials_file):
        self.credentials_file = credentials_file
        self.sheets_client = None
        self.drive_service = None
        self.setup_clients()
        
    def setup_clients(self):
        """Initialize Google Sheets and Drive clients"""
        try:
            creds = Credentials.from_service_account_file(self.credentials_file, scopes=SCOPE)
            self.sheets_client = gspread.authorize(creds)
            self.drive_service = build('drive', 'v3', credentials=creds)
            logging.info("Google Sheets and Drive clients initialized")
        except Exception as e:
            logging.error(f"Failed to initialize clients: {e}")
            raise

    def clean_name(self, name, default="Default"):
        """Clean folder/file names to be filesystem-safe"""
        if not name:
            return default
        name = str(name)
        name = re.sub(r'https?://', '', name)
        name = re.sub(r'[<>:"/\\|?*]', "_", name)
        return name.strip().rstrip(".")

    def load_data_from_sheets(self, spreadsheet_id, worksheet_name):
        """Load data from Google Sheets"""
        try:
            spreadsheet = self.sheets_client.open_by_key(spreadsheet_id)
            worksheet = spreadsheet.worksheet(worksheet_name)
            data = worksheet.get_all_records()
            logging.info(f"Loaded {len(data)} rows from Google Sheets")
            return data
        except Exception as e:
            logging.error(f"Failed to load data from Google Sheets: {e}")
            raise

    def create_folder_structure(self, base_path, folder, sub_folder):
        """Create folder structure for PDFs"""
        safe_folder = self.clean_name(folder, "Folder")
        safe_sub_folder = self.clean_name(sub_folder, "SubFolder")
        path = os.path.join(base_path, safe_folder, safe_sub_folder)
        os.makedirs(path, exist_ok=True)
        return path

    def extract_urls_from_text(self, text):
        """Extract ALL URLs from text, including those in separate square brackets [url1] [url2]"""
        if not text:
            return []
        
        text = str(text).strip()
        urls = []
        
        # Pattern to match URLs in separate square brackets: [url1] [url2] [url3]
        bracket_pattern = r'\[(https?://[^\]]+)\]'
        bracket_urls = re.findall(bracket_pattern, text)
        urls.extend(bracket_urls)
        
        # Also look for standalone URLs outside brackets
        url_pattern = r'https?://[^\s<>"]+|www\.[^\s<>"]+'
        standalone_urls = re.findall(url_pattern, text)
        for url in standalone_urls:
            if not url.startswith('http'):
                url = 'https://' + url
            # Only add if not already in bracket_urls (avoid duplicates)
            if url not in urls:
                urls.append(url)
        
        return urls

    def parse_html_table(self, html_content):
        """Parse HTML table and convert to ReportLab table data"""
        try:
            soup = BeautifulSoup(html_content, 'html.parser')
            tables = soup.find_all('table')
            
            if not tables:
                return None
            
            table_data = []
            
            for table in tables:
                rows = table.find_all('tr')
                table_rows = []
                
                for row in rows:
                    cells = row.find_all(['td', 'th'])
                    row_data = []
                    
                    for cell in cells:
                        # Clean cell content
                        cell_text = cell.get_text(strip=True)
                        # Remove extra whitespace but preserve line breaks for paragraphs
                        cell_text = re.sub(r'\s+', ' ', cell_text)
                        row_data.append(cell_text)
                    
                    if row_data:  # Only add non-empty rows
                        table_rows.append(row_data)
                
                if table_rows:  # Only add tables with data
                    table_data.append(table_rows)
            
            return table_data if table_data else None
            
        except Exception as e:
            logging.debug(f"Failed to parse HTML table: {e}")
            return None

    def clean_text_with_tables(self, text):
        """Clean text by removing HTML tags but preserving table structure"""
        if not text:
            return text, None
        
        text = str(text)
        
        # First, extract any HTML tables
        table_data = self.parse_html_table(text)
        
        # Now clean the text (remove HTML tags but keep table markers)
        # Replace tables with placeholders
        cleaned_text = text
        
        # Remove HTML tags but keep the text content
        # We'll use BeautifulSoup to extract text while handling tables specially
        try:
            soup = BeautifulSoup(text, 'html.parser')
            
            # Find all tables and replace them with markers
            tables = soup.find_all('table')
            table_markers = []
            
            for i, table in enumerate(tables):
                marker = f"[[TABLE_{i}]]"
                table_markers.append(marker)
                table.replace_with(marker)
            
            # Get the text with table markers
            cleaned_text = soup.get_text()
            
            # Clean up extra whitespace
            cleaned_text = re.sub(r'\s+', ' ', cleaned_text)
            
            # Put table markers back in a clean way
            for i, marker in enumerate(table_markers):
                cleaned_text = cleaned_text.replace(marker, f"\n[Table {i+1}]\n")
            
        except Exception as e:
            logging.debug(f"Failed to parse HTML with BeautifulSoup: {e}")
            # Fallback: simple HTML tag removal
            cleaned_text = re.sub(r'<[^>]+>', '', text)
            cleaned_text = re.sub(r'\s+', ' ', cleaned_text)
        
        # Remove URLs in separate square brackets [url1] [url2]
        cleaned_text = re.sub(r'\[https?://[^\]]+\]', '', cleaned_text)
        
        # Remove standalone URLs
        cleaned_text = re.sub(r'https?://[^\s<>"]+|www\.[^\s<>"]+', '', cleaned_text)
        
        return cleaned_text.strip(), table_data

    def create_table_from_html_data(self, table_rows, available_width):
        """Convert parsed HTML table data to ReportLab Table"""
        if not table_rows:
            return None
        
        try:
            # Calculate column widths
            num_cols = max(len(row) for row in table_rows)
            col_width = available_width / num_cols
            
            # Create the table
            table = Table(table_rows, colWidths=[col_width] * num_cols)
            
            # Apply table styling
            table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.lightgrey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), UNICODE_FONT_BOLD),
                ('FONTSIZE', (0, 0), (-1, -1), 10),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 6),
                ('BACKGROUND', (0, 1), (-1, -1), colors.white),
                ('FONTNAME', (0, 1), (-1, -1), UNICODE_FONT),
                ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
                ('LEFTPADDING', (0, 0), (-1, -1), 6),
                ('RIGHTPADDING', (0, 0), (-1, -1), 6),
                ('TOPPADDING', (0, 0), (-1, -1), 4),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 4),
            ]))
            
            return table
            
        except Exception as e:
            logging.error(f"Failed to create table from HTML data: {e}")
            return None

    # ✅ IMPROVED IMAGE PARSING WITH MULTIPLE URL SUPPORT
    def fetch_images_from_urls(self, urls, max_width=1.6 * inch):
        """Fetch multiple images from URLs and return list of Image objects"""
        images = []
        for url in urls:
            try:
                if not url:
                    continue

                url = str(url).strip()
                if not url.lower().startswith("http"):
                    continue

                resp = requests.get(url, timeout=15)
                if resp.status_code != 200:
                    continue

                img_data = BytesIO(resp.content)
                img = Image(img_data)

                # Scale image proportionally to fit within max_width
                if img.drawWidth > max_width:
                    scale = max_width / img.drawWidth
                    img.drawWidth = max_width
                    img.drawHeight *= scale

                # Maintain aspect ratio for very tall images
                max_height = 2.0 * inch
                if img.drawHeight > max_height:
                    scale = max_height / img.drawHeight
                    img.drawHeight = max_height
                    img.drawWidth *= scale

                # ✅ ZERO PADDING AND PROPER ALIGNMENT
                img.hAlign = 'LEFT'
                images.append(img)
                
            except Exception as e:
                logging.debug(f"Failed to fetch image from {url}: {e}")
                continue
        
        return images

    def add_header_footer(self, canvas, doc, paper_name=None):
        """Add header and footer to all pages - 80% width (no margins)"""
        canvas.saveState()
        
        # Calculate 80% width
        page_width = doc.pagesize[0]
        header_footer_width = page_width * 0.8
        start_x = (page_width - header_footer_width) / 2
        
        # Header line - 80% width centered
        canvas.setStrokeColor(colors.black)
        canvas.setLineWidth(0.5)
        canvas.line(start_x, doc.pagesize[1] - 40, start_x + header_footer_width, doc.pagesize[1] - 40)
        
        # Add paper name in header on right side
        if paper_name:
            canvas.setFont(UNICODE_FONT, 10)
            canvas.setFillColor(colors.black)
            canvas.drawRightString(page_width - 36, doc.pagesize[1] - 30, paper_name)
        
        # Footer line - 80% width centered
        canvas.setStrokeColor(colors.black)
        canvas.setLineWidth(0.5)
        canvas.line(start_x, 40, start_x + header_footer_width, 40)
        
        # Page number only (centered at bottom)
        canvas.setFont(UNICODE_FONT, 10)
        canvas.setFillColor(colors.black)
        canvas.drawCentredString(doc.pagesize[0] / 2, 25, str(canvas.getPageNumber()))
        
        canvas.restoreState()

    def should_use_single_column(self, option_a, option_b, option_c, option_d, doc_width):
        """Check if options should be displayed in single column to avoid overlap"""
        # Estimate text width - if any option is longer than 40% of available width, use single column
        max_option_length = max(len(str(option_a)), len(str(option_b)), len(str(option_c)), len(str(option_d)))
        available_width_per_option = (doc_width / 2) - 20  # Account for padding
        
        # If any option is longer than 40% of available space, use single column
        estimated_char_width = 6  # Approximate width per character in points
        estimated_text_width = max_option_length * estimated_char_width
        
        return estimated_text_width > (available_width_per_option * 0.4)

    def can_images_fit_two_per_row(self, images, available_width):
        """Check if two images can fit side by side"""
        if len(images) < 2:
            return False
            
        # Very flexible: only check if total width fits with spacing
        total_width = images[0].drawWidth + images[1].drawWidth + 20
        
        result = total_width < available_width
        
        logging.debug(f"Can images fit side by side? Image1={images[0].drawWidth:.1f}, Image2={images[1].drawWidth:.1f}, Total={total_width:.1f}, Available={available_width:.1f}, Result={result}")
        
        return result

    def layout_images_for_option(self, images, available_width, left_indent):
        """Layout images for a single option - small images side by side, large ones stacked"""
        if not images:
            return []
            
        layout_items = []
        
        # If only one image
        if len(images) == 1:
            img_table = Table([["", images[0]]], 
                           colWidths=[left_indent, available_width])
            img_table.setStyle(TableStyle([
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('LEFTPADDING', (0, 0), (-1, -1), 0),
                ('RIGHTPADDING', (0, 0), (-1, -1), 0),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 5),
            ]))
            layout_items.append(img_table)
            return layout_items
        
        # Try to layout images intelligently
        i = 0
        while i < len(images):
            if i + 1 < len(images) and self.can_images_fit_two_per_row([images[i], images[i+1]], available_width):
                # Two images side by side
                img1_width = images[i].drawWidth
                img2_width = images[i+1].drawWidth
                
                # Calculate widths proportionally
                spacing = 15
                available_img_width = available_width - spacing
                total_img_width = img1_width + img2_width
                
                col1_width = (img1_width / total_img_width) * available_img_width
                col2_width = (img2_width / total_img_width) * available_img_width
                
                # Ensure minimum width
                min_col_width = available_width * 0.3
                if col1_width < min_col_width:
                    col1_width = min_col_width
                if col2_width < min_col_width:
                    col2_width = min_col_width
                
                image_row_table = Table([["", images[i], Spacer(spacing, 15), images[i+1]]], 
                                      colWidths=[left_indent, col1_width, spacing, col2_width])
                image_row_table.setStyle(TableStyle([
                    ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                    ('LEFTPADDING', (0, 0), (-1, -1), 0),
                    ('RIGHTPADDING', (0, 0), (-1, -1), 0),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 5),
                ]))
                layout_items.append(image_row_table)
                i += 2
            else:
                # Single image (either large or odd one out)
                img_table = Table([["", images[i]]], 
                               colWidths=[left_indent, available_width])
                img_table.setStyle(TableStyle([
                    ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                    ('LEFTPADDING', (0, 0), (-1, -1), 0),
                    ('RIGHTPADDING', (0, 0), (-1, -1), 0),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 5),
                ]))
                layout_items.append(img_table)
                i += 1
        
        return layout_items

    def process_questions(self, data):
        """Process questions and group by paper"""
        papers = {}
        
        for row in data:
            try:
                # Extract paper information
                folder = self.clean_name(row.get(COLUMN_FOLDER, 'Default_Folder'))
                sub_folder = self.clean_name(row.get(COLUMN_SUB_FOLDER, 'General'))
                file_name = self.clean_name(row.get(COLUMN_FILE_NAME, 'Default_Paper'))
                
                paper_key = f"{folder}_{sub_folder}_{file_name}"
                
                if paper_key not in papers:
                    papers[paper_key] = {
                        'folder': folder,
                        'sub_folder': sub_folder,
                        'file_name': file_name,
                        'questions': []
                    }
                
                # Create question dictionary
                question = {
                    'question_no': row.get(COLUMN_QUESTION_NO, ''),
                    'question_text': row.get(COLUMN_QUESTION_TEXT, ''),
                    'instructions': row.get(COLUMN_INSTRUCTIONS, ''),
                    'option_a': row.get(COLUMN_OPTION_A, ''),
                    'option_b': row.get(COLUMN_OPTION_B, ''),
                    'option_c': row.get(COLUMN_OPTION_C, ''),
                    'option_d': row.get(COLUMN_OPTION_D, ''),
                    'correct_option': row.get(COLUMN_CORRECT_OPTION, ''),
                    'explanation': row.get(COLUMN_EXPLANATION, ''),
                    'content': row.get(COLUMN_CONTENT, ''),
                    'question_image_url': row.get(COLUMN_QUESTION_IMAGE_URL, ''),
                    'option_a_image_url': row.get(COLUMN_OPTION_A_IMAGE_URL, ''),
                    'option_b_image_url': row.get(COLUMN_OPTION_B_IMAGE_URL, ''),
                    'option_c_image_url': row.get(COLUMN_OPTION_C_IMAGE_URL, ''),
                    'option_d_image_url': row.get(COLUMN_OPTION_D_IMAGE_URL, '')
                }
                
                papers[paper_key]['questions'].append(question)
                
            except Exception as e:
                logging.warning(f"Error processing row: {e}")
                continue
        
        return papers

    def create_complete_pdf(self, questions, output_path, paper_name):
        """Create complete PDF with questions, options, answers and explanations"""
        try:
            doc = SimpleDocTemplate(
                output_path,
                pagesize=letter,
                rightMargin=72,
                leftMargin=72,
                topMargin=72,
                bottomMargin=72
            )
            
            styles = getSampleStyleSheet()
            
            # ✅ CONSISTENT LEFT INDENTATION
            QUESTION_LEFT_INDENT = 35
            OPTION_IMAGE_INDENT = 45
            
            # Custom styles
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontName=UNICODE_FONT_BOLD,
                fontSize=16,
                spaceAfter=20,
                alignment=1,
                textColor=colors.black
            )
            
            question_number_style = ParagraphStyle(
                'QuestionNumberStyle',
                parent=styles['Normal'],
                fontName=UNICODE_FONT_BOLD,
                fontSize=12,
                spaceAfter=0,
                leading=14,
                textColor=colors.black,
                leftIndent=0
            )
            
            question_text_style = ParagraphStyle(
                'QuestionTextStyle',
                parent=styles['Normal'],
                fontName=UNICODE_FONT_BOLD,
                fontSize=12,
                leftIndent=0,
                spaceAfter=12,
                leading=14,
                textColor=colors.black
            )
            
            instruction_label_style = ParagraphStyle(
                'InstructionLabelStyle',
                parent=styles['Normal'],
                fontName=UNICODE_FONT_BOLD,
                fontSize=12,
                leftIndent=QUESTION_LEFT_INDENT,
                spaceAfter=0,
                leading=14,
                textColor=colors.black
            )
            
            instruction_text_style = ParagraphStyle(
                'InstructionTextStyle',
                parent=styles['Normal'],
                fontName=UNICODE_FONT,
                fontSize=12,
                leftIndent=QUESTION_LEFT_INDENT,
                spaceAfter=8,
                leading=14,
                textColor=colors.black
            )
            
            option_style = ParagraphStyle(
                'OptionStyle',
                parent=styles['Normal'],
                fontName=UNICODE_FONT,
                fontSize=12,
                leftIndent=0,
                spaceAfter=3,
                leading=14,
                textColor=colors.black
            )
            
            correct_answer_style = ParagraphStyle(
                'CorrectAnswerStyle',
                parent=styles['Normal'],
                fontName=UNICODE_FONT_BOLD,
                fontSize=12,
                textColor=colors.black,
                spaceAfter=8,
                leading=14,
                leftIndent=QUESTION_LEFT_INDENT
            )
            
            explanation_label_style = ParagraphStyle(
                'ExplanationLabelStyle',
                parent=styles['Normal'],
                fontName=UNICODE_FONT_BOLD,
                fontSize=12,
                textColor=colors.black,
                spaceAfter=0,
                leading=14,
                leftIndent=QUESTION_LEFT_INDENT
            )
            
            explanation_text_style = ParagraphStyle(
                'ExplanationTextStyle',
                parent=styles['Normal'],
                fontName=UNICODE_FONT,
                fontSize=12,
                textColor=colors.black,
                spaceAfter=15,
                leading=14,
                leftIndent=QUESTION_LEFT_INDENT
            )
            
            story = []
            
            # Add title
            title = Paragraph(f"{paper_name}", title_style)
            story.append(title)
            story.append(Spacer(1, 30))
            
            for i, question in enumerate(questions, 1):
                # ✅ USE ACTUAL QUESTION NUMBER
                actual_question_no = question.get('question_no', i)
                if not actual_question_no or str(actual_question_no).strip() == '':
                    actual_question_no = i
                
                # ✅ IMPROVED: Clean text and extract tables
                question_text, question_tables = self.clean_text_with_tables(question['question_text'])
                
                # ✅ ADD INSTRUCTIONS
                if question.get('instructions'):
                    instr_text, instr_tables = self.clean_text_with_tables(question['instructions'])
                    if instr_text and instr_text.strip():
                        instruction_label = Paragraph("<b>Instruction:</b>", instruction_label_style)
                        instruction_content = Paragraph(f"{instr_text}", instruction_text_style)
                        story.append(instruction_label)
                        story.append(instruction_content)
                        
                        # ✅ ADD INSTRUCTION TABLES IF ANY
                        if instr_tables:
                            story.append(Spacer(1, 8))
                            for table_data in instr_tables:
                                table = self.create_table_from_html_data(table_data, doc.width - QUESTION_LEFT_INDENT)
                                if table:
                                    # Create indented table
                                    indented_table = Table([["", table]], 
                                                         colWidths=[QUESTION_LEFT_INDENT, doc.width - QUESTION_LEFT_INDENT])
                                    indented_table.setStyle(TableStyle([
                                        ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                                        ('LEFTPADDING', (0, 0), (-1, -1), 0),
                                        ('RIGHTPADDING', (0, 0), (-1, -1), 0),
                                        ('BOTTOMPADDING', (0, 0), (-1, -1), 10),
                                    ]))
                                    story.append(indented_table)
                                    story.append(Spacer(1, 8))
                        
                        story.append(Spacer(1, 8))
                
                # Question number and text
                q_number = Paragraph(f"Q.{actual_question_no}", question_number_style)
                q_text = Paragraph(f"{question_text}", question_text_style)
                
                question_table = Table([[q_number, q_text]], colWidths=[35, doc.width - 35])
                question_table.setStyle(TableStyle([
                    ('VALIGN', (0, 0), (-1, 0), 'TOP'),
                    ('LEFTPADDING', (0, 0), (-1, 0), 0),
                    ('RIGHTPADDING', (0, 0), (-1, 0), 0),
                    ('BOTTOMPADDING', (0, 0), (-1, 0), 0),
                ]))
                
                story.append(question_table)
                story.append(Spacer(1, 8))
                
                # ✅ ADD QUESTION TABLES IF ANY (BEFORE IMAGES)
                if question_tables:
                    for table_data in question_tables:
                        table = self.create_table_from_html_data(table_data, doc.width - QUESTION_LEFT_INDENT)
                        if table:
                            # Create indented table
                            indented_table = Table([["", table]], 
                                                 colWidths=[QUESTION_LEFT_INDENT, doc.width - QUESTION_LEFT_INDENT])
                            indented_table.setStyle(TableStyle([
                                ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                                ('LEFTPADDING', (0, 0), (-1, -1), 0),
                                ('RIGHTPADDING', (0, 0), (-1, -1), 0),
                                ('BOTTOMPADDING', (0, 0), (-1, -1), 10),
                            ]))
                            story.append(indented_table)
                            story.append(Spacer(1, 8))
                
                # ✅ QUESTION IMAGES
                question_image_urls = []
                if question.get('question_image_url'):
                    dedicated_urls = self.extract_urls_from_text(question['question_image_url'])
                    question_image_urls.extend(dedicated_urls)
                
                text_urls = self.extract_urls_from_text(question['question_text'])
                question_image_urls.extend(text_urls)
                
                seen = set()
                unique_urls = []
                for url in question_image_urls:
                    if url not in seen:
                        seen.add(url)
                        unique_urls.append(url)
                
                question_images = self.fetch_images_from_urls(unique_urls)
                
                if question_images:
                    available_width = doc.width - QUESTION_LEFT_INDENT
                    question_image_layout = self.layout_images_for_option(question_images, available_width, QUESTION_LEFT_INDENT)
                    for layout_item in question_image_layout:
                        story.append(layout_item)
                        story.append(Spacer(1, 6))
                
                # ✅ PROCESS OPTIONS WITH TABLES SUPPORT
                option_data = []
                for option_key in ['option_a', 'option_b', 'option_c', 'option_d']:
                    raw_text = question[option_key]
                    clean_text, option_tables = self.clean_text_with_tables(raw_text)
                    
                    # Get image URLs
                    image_urls = []
                    dedicated_url_col = f"{option_key}_image_url"
                    if question.get(dedicated_url_col):
                        dedicated_urls = self.extract_urls_from_text(question[dedicated_url_col])
                        image_urls.extend(dedicated_urls)
                    
                    text_urls = self.extract_urls_from_text(raw_text)
                    image_urls.extend(text_urls)
                    
                    seen = set()
                    unique_urls = []
                    for url in image_urls:
                        if url not in seen:
                            seen.add(url)
                            unique_urls.append(url)
                    
                    # Fetch images
                    images = self.fetch_images_from_urls(unique_urls)
                    
                    option_data.append({
                        'letter': option_key[-1].upper(),
                        'text': clean_text,
                        'images': images,
                        'tables': option_tables
                    })
                
                # ✅ CHECK IF WE SHOULD USE SINGLE COLUMN
                opt_a_data = option_data[0]
                opt_b_data = option_data[1]
                opt_c_data = option_data[2]
                opt_d_data = option_data[3]

                has_images = any([
                    len(opt_a_data['images']) > 0,
                    len(opt_b_data['images']) > 0, 
                    len(opt_c_data['images']) > 0,
                    len(opt_d_data['images']) > 0
                ])
                
                has_tables = any([
                    opt_a_data['tables'] is not None,
                    opt_b_data['tables'] is not None,
                    opt_c_data['tables'] is not None,
                    opt_d_data['tables'] is not None
                ])
                
                use_single = has_images or has_tables or self.should_use_single_column(
                    opt_a_data['text'], opt_b_data['text'], opt_c_data['text'], opt_d_data['text'], doc.width
                )

                if use_single:
                    # ✅ SINGLE COLUMN LAYOUT - EACH OPTION WITH ITS TEXT, TABLES, AND IMAGES
                    for opt_data in option_data:
                        # Option text
                        opt_text = f"({opt_data['letter']}) {opt_data['text']}" if opt_data['text'].strip() else f"({opt_data['letter']})"
                        if opt_text:
                            opt_paragraph = Paragraph(opt_text, option_style)
                            text_table = Table([["", opt_paragraph]], 
                                             colWidths=[QUESTION_LEFT_INDENT, doc.width - QUESTION_LEFT_INDENT])
                            text_table.setStyle(TableStyle([
                                ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                                ('LEFTPADDING', (0, 0), (-1, -1), 0),
                                ('RIGHTPADDING', (0, 0), (-1, -1), 0),
                                ('BOTTOMPADDING', (0, 0), (-1, -1), 5),
                            ]))
                            story.append(text_table)
                        
                        # ✅ OPTION TABLES (IF ANY)
                        if opt_data['tables']:
                            for table_data in opt_data['tables']:
                                table = self.create_table_from_html_data(table_data, doc.width - OPTION_IMAGE_INDENT)
                                if table:
                                    # Create indented table
                                    indented_table = Table([["", table]], 
                                                         colWidths=[OPTION_IMAGE_INDENT, doc.width - OPTION_IMAGE_INDENT])
                                    indented_table.setStyle(TableStyle([
                                        ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                                        ('LEFTPADDING', (0, 0), (-1, -1), 0),
                                        ('RIGHTPADDING', (0, 0), (-1, -1), 0),
                                        ('BOTTOMPADDING', (0, 0), (-1, -1), 5),
                                    ]))
                                    story.append(indented_table)
                                    story.append(Spacer(1, 5))
                        
                        # ✅ OPTION IMAGES - RIGHT AFTER TEXT AND TABLES
                        if opt_data['images']:
                            available_width = doc.width - OPTION_IMAGE_INDENT
                            option_image_layout = self.layout_images_for_option(
                                opt_data['images'], 
                                available_width, 
                                OPTION_IMAGE_INDENT
                            )
                            
                            for layout_item in option_image_layout:
                                story.append(layout_item)
                        
                        # Small space between options
                        if opt_data != option_data[-1]:
                            story.append(Spacer(1, 8))
                    
                else:
                    # Two column layout for text-only options
                    data = []
                    for row_num in range(2):
                        row = []
                        for col in range(2):
                            option_index = row_num * 2 + col
                            if option_index < len(option_data):
                                opt_data = option_data[option_index]
                                opt_text = f"({opt_data['letter']}) {opt_data['text']}"
                                opt_paragraph = Paragraph(opt_text, option_style)
                                option_cell_table = Table([["", opt_paragraph]], 
                                                        colWidths=[QUESTION_LEFT_INDENT, doc.width * 0.45 - QUESTION_LEFT_INDENT])
                                option_cell_table.setStyle(TableStyle([
                                    ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                                    ('LEFTPADDING', (0, 0), (-1, -1), 0),
                                    ('RIGHTPADDING', (0, 0), (-1, -1), 0),
                                    ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
                                ]))
                                row.append(option_cell_table)
                                row.append("")
                            else:
                                row.extend(["", ""])
                        data.append(row)
                    
                    tbl = Table(data, colWidths=[doc.width * 0.45, doc.width * 0.05] * 2)
                    tbl.setStyle(TableStyle([
                        ('VALIGN', (0,0), (-1,-1), 'TOP'),
                        ('ALIGN', (0,0), (-1,-1), 'LEFT'),
                        ('LEFTPADDING', (0,0), (-1,-1), 0),
                        ('RIGHTPADDING', (0,0), (-1,-1), 0),
                        ('TOPPADDING', (0,0), (-1,-1), 2),
                        ('BOTTOMPADDING', (0,0), (-1,-1), 2),
                    ]))
                    story.append(tbl)
                
                story.append(Spacer(1, 10))
                
                # Correct answer
                correct_option = question['correct_option']
                if correct_option:
                    correct_answer = f"Correct Answer: {correct_option}"
                    story.append(Paragraph(correct_answer, correct_answer_style))
                
                # Explanation (with table support)
                if question.get('explanation'):
                    expl_text, expl_tables = self.clean_text_with_tables(question['explanation'])
                    if expl_text and expl_text.strip():
                        story.append(Paragraph("Explanation:", explanation_label_style))
                        story.append(Paragraph(expl_text, explanation_text_style))
                        
                        # ✅ ADD EXPLANATION TABLES IF ANY
                        if expl_tables:
                            for table_data in expl_tables:
                                table = self.create_table_from_html_data(table_data, doc.width - QUESTION_LEFT_INDENT)
                                if table:
                                    # Create indented table
                                    indented_table = Table([["", table]], 
                                                         colWidths=[QUESTION_LEFT_INDENT, doc.width - QUESTION_LEFT_INDENT])
                                    indented_table.setStyle(TableStyle([
                                        ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                                        ('LEFTPADDING', (0, 0), (-1, -1), 0),
                                        ('RIGHTPADDING', (0, 0), (-1, -1), 0),
                                        ('BOTTOMPADDING', (0, 0), (-1, -1), 5),
                                    ]))
                                    story.append(indented_table)
                
                story.append(Spacer(1, 15))
                
                # Add page break after every 5 questions
                if i % 5 == 0:
                    story.append(PageBreak())
            
            # Build PDF
            doc.build(story, 
                     onFirstPage=lambda canvas, doc: self.add_header_footer(canvas, doc, paper_name),
                     onLaterPages=lambda canvas, doc: self.add_header_footer(canvas, doc, paper_name))
            logging.info(f"Complete PDF created successfully: {output_path}")
            return True
            
        except Exception as e:
            logging.error(f"Failed to create complete PDF: {e}")
            return False

    # Note: You'll need to add similar table support to create_questions_only_pdf and create_answers_only_pdf
    # For brevity, I've only shown the complete implementation for create_complete_pdf

def main():
    # Configuration
    CREDENTIALS_FILE = "service-account.json"
    SPREADSHEET_ID = "1U6gW0yqh3GZlkyxvhF_5k3sXMP8GwZT-TNsXqKv7S1o"
    WORKSHEET_NAME = "Sheet4"
    OUTPUT_DIR = "Generated_PDFs"
    
    # Create output directory
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    
    try:
        # Initialize PDF generator
        pdf_gen = PDFGenerator(CREDENTIALS_FILE)
        
        # Load data from Google Sheets
        data = pdf_gen.load_data_from_sheets(SPREADSHEET_ID, WORKSHEET_NAME)
        
        # Process questions
        papers = pdf_gen.process_questions(data)
        logging.info(f"Found {len(papers)} papers to process")
        
        # Generate PDFs
        results = []
        
        for paper_key, paper_info in papers.items():
            try:
                paper_name = paper_info['file_name']
                questions = paper_info['questions']
                folder = paper_info['folder']
                sub_folder = paper_info['sub_folder']
                
                logging.info(f"Processing: {paper_name} ({len(questions)} questions)")
                
                # Create folder structure
                local_folder_path = pdf_gen.create_folder_structure(OUTPUT_DIR, folder, sub_folder)
                
                # Create PDF filenames for three types
                safe_name = "".join(c for c in paper_name if c.isalnum() or c in (' ', '-', '_')).rstrip()
                
                pdf_files = {
                    'complete': os.path.join(local_folder_path, f"{safe_name}_Complete_Solutions.pdf"),
                    'questions_only': os.path.join(local_folder_path, f"{safe_name}_Questions.pdf"),
                    'answers_only': os.path.join(local_folder_path, f"{safe_name}_Correct_Answers.pdf")
                }
                
                # Generate all three PDF types
                pdf_results = {}
                
                # 1. Complete PDF
                if pdf_gen.create_complete_pdf(questions, pdf_files['complete'], paper_name):
                    pdf_results['complete'] = pdf_files['complete']
                    logging.info(f"✓ Complete PDF created: {pdf_files['complete']}")
                else:
                    pdf_results['complete'] = None
                    logging.error(f"✗ Failed to create complete PDF")
                
                # Store results
                result = {
                    'paper_name': paper_name,
                    'folder': folder,
                    'sub_folder': sub_folder,
                    'questions_count': len(questions),
                    'complete_pdf': pdf_results['complete'],
                    'questions_pdf': '',
                    'answers_pdf': '',
                    'status': 'Success'
                }
                results.append(result)
                
                logging.info(f"Successfully processed: {paper_name}")
                    
            except Exception as e:
                logging.error(f"Failed to process paper {paper_key}: {e}")
                result = {
                    'paper_name': paper_key,
                    'folder': '',
                    'sub_folder': '',
                    'questions_count': 0,
                    'complete_pdf': '',
                    'questions_pdf': '',
                    'answers_pdf': '',
                    'status': f'Failed - {str(e)}'
                }
                results.append(result)
        
        # Save processing report
        report_df = pd.DataFrame(results)
        report_path = os.path.join(OUTPUT_DIR, "Processing_Report.csv")
        report_df.to_csv(report_path, index=False)
        logging.info(f"Results saved to: {report_path}")
        
        # Print summary
        successful = len([r for r in results if r['status'] == 'Success'])
        total = len(results)
        
        print("\n" + "="*60)
        print("PDF GENERATION COMPLETE!")
        print("="*60)
        print(f"Successfully processed: {successful}/{total} papers")
        print(f"Generated PDF with HTML table support")
        print(f"\nPDFs saved to: {OUTPUT_DIR}")
        print("All done!")
        
    except Exception as e:
        logging.error(f"Main process failed: {e}")
        raise

if __name__ == "__main__":
    main()
