import re
import csv
import os

# Folder containing text files only
input_folder = r"C:\Users\menha\Downloads\test11"
output_file = "combined_questions.csv"

# Regular expressions
section_pattern = re.compile(r"####\s*\*\*(.*?)\*\*", re.MULTILINE)
direction_pattern = re.compile(r"\*\*(Q\.\d+\s*[‚Äì-]\s*Q\.\d+.*?)\*\*")
question_pattern = re.compile(r"\*\*Q\.(\d+)\*\*")
option_pattern = re.compile(r"\([A-D]\)")

# Store all data rows
all_rows = []

for filename in os.listdir(input_folder):
    # ‚úÖ Only process .txt files
    if not filename.lower().endswith(".txt"):
        print(f"‚è© Skipping non-text file: {filename}")
        continue

    file_path = os.path.join(input_folder, filename)
    if not os.path.isfile(file_path):
        continue

    print(f"üìÑ Processing: {filename}")

    # Try reading with UTF-8, fallback to UTF-16
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            text = f.read()
    except UnicodeError:
        with open(file_path, "r", encoding="utf-16") as f:
            text = f.read()

    # Clean unwanted content
    text = re.sub(r"\*\*Organizing Institute:.*?\*\*", "", text, flags=re.DOTALL)
    text = re.sub(r"Page\s*\d+", "", text)

    current_section = ""
    current_direction = ""
    rows = []

    # Find all section headers
    section_positions = [(m.start(), m.group(1).strip()) for m in section_pattern.finditer(text)]
    section_positions.append((len(text), ""))  # artificial end marker

    # Parse each section block
    for i in range(len(section_positions) - 1):
        section_start = section_positions[i][0]
        section_end = section_positions[i + 1][0]
        current_section = section_positions[i][1]
        section_block = text[section_start:section_end]

        # Find direction
        direction_match = direction_pattern.search(section_block)
        if direction_match:
            current_direction = direction_match.group(1).strip()

        # Split questions
        question_blocks = re.split(r"(?=\*\*Q\.\d+\*\*)", section_block)
        for qb in question_blocks:
            q_match = question_pattern.search(qb)
            if not q_match:
                continue

            q_no = f"Q.{q_match.group(1)}"
            content = re.sub(r"\*\*Q\.\d+\*\*", "", qb).strip()

            # Split options
            option_splits = option_pattern.split(content)
            option_labels = option_pattern.findall(content)

            question_text = option_splits[0].strip()
            options = {"A": "", "B": "", "C": "", "D": ""}
            for j, label in enumerate(option_labels):
                key = label.strip("()")
                if j + 1 < len(option_splits):
                    options[key] = option_splits[j + 1].strip()

            rows.append([
                filename,
                current_section,
                current_direction,
                q_no,
                question_text,
                options["A"],
                options["B"],
                options["C"],
                options["D"]
            ])

    if not rows:
        print(f"‚ö†Ô∏è No questions found in: {filename}")

    all_rows.extend(rows)

# ‚úÖ Write all results to CSV
with open(output_file, "w", newline="", encoding="utf-8") as csvfile:
    writer = csv.writer(csvfile)
    writer.writerow([
        "File Name", "Section", "Directions", "Question No",
        "Question Text", "Option A", "Option B", "Option C", "Option D"
    ])
    writer.writerows(all_rows)

print(f"\n‚úÖ Completed! Extracted {len(all_rows)} questions.")
print(f"üìÅ Output file saved as: {os.path.abspath(output_file)}")
