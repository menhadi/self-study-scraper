import requests
import json
import re
import csv
import os
import time
from google.oauth2 import service_account
from googleapiclient.discovery import build
from typing import Dict, List

# ==============================
#  MODEL SETTINGS
# ==============================
ANSWER_MODEL = "gpt-4.1"
ANSWER_TEMP = 0.0
PROGRESS_FILE = "answer_progress.csv"

# ========================================
#  ANSWER GENERATION MODULE
# ========================================
class AnswerGenerator:
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://api.openai.com/v1/chat/completions"
        self.headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {api_key}"
        }

    # ==========================================
    # ANSWER GENERATION
    # ==========================================
    def analyze_question(self, q: Dict) -> Dict:
        """
        Generate answers for questions - handles both MCQ and Fill-in-Blank
        """
        qtype = q.get("type", "MCQ")

        if qtype == "FILL_IN_BLANK":
            return self._answer_fill_blank(q)
        else:
            return self._answer_mcq(q)

    # ------------------------------------
    # ANSWER FILL-IN-THE-BLANK - COMPLETELY FIXED
    # ------------------------------------
    def _answer_fill_blank(self, q):
        prompt = f"""
You are an exam-solving expert. This is a FILL-IN-THE-BLANK question.

Question:
{q.get('text','')}

CRITICAL REQUIREMENTS:
1. For fill-in-blank questions, the answer MUST be the ACTUAL CALCULATED VALUE or TEXT that fills the blank
2. NEVER use A, B, C, or D as the answer for fill-in-blank questions
3. Provide the exact numeric value, text, or formula result
4. Give a natural, flowing explanation
5. Use Unicode math only (no LaTeX)
6. Confidence score 0-100

IMPORTANT: The "correct_answer" field must contain ONLY the actual value that fills the blank, not an option letter.

JSON FORMAT:
{{
  "correct_answer": "12.5",
  "solution": "To solve this, we apply the velocity formula v = u + at. Given initial velocity u = 0, acceleration a = 2.5 m/s¬≤, and time t = 5 seconds, we calculate v = 0 + 2.5 √ó 5 = 12.5 m/s.",
  "confidence": 92
}}
"""

        result = self._call_answer_model(prompt)
        
        # CRITICAL FIX: Extract actual value from solution if answer is still an option letter
        answer = result.get("correct_answer", "").strip().upper()
        solution = result.get("solution", "")
        
        # If answer is still A/B/C/D, try to extract the actual value from the solution
        if answer in ["A", "B", "C", "D"]:
            print(f"‚ö†Ô∏è  GPT returned option '{answer}' instead of value. Extracting from solution...")
            
            # Try to find numeric values in the solution
            numeric_values = re.findall(r'\b\d+\.?\d*\b', solution)
            calculated_values = re.findall(r'=\s*([\d\.]+)', solution)
            final_values = re.findall(r'(\d+\.?\d*)\s*(?:m/s|N|kg|s|m|¬∞|percent|%)', solution, re.IGNORECASE)
            
            # Combine all found values
            all_values = numeric_values + calculated_values + final_values
            
            if all_values:
                # Take the last calculated value (usually the final answer)
                actual_value = all_values[-1]
                result["correct_answer"] = actual_value
                print(f"‚úÖ Extracted value '{actual_value}' from solution")
            else:
                # If no value found, retry with STRICT instruction
                print("üîÑ No value found in solution, retrying with strict instruction...")
                strict_prompt = prompt + "\n\nCRITICAL: The 'correct_answer' MUST be a numeric value like '12.5', '45', or text answer. NEVER use A, B, C, D."
                result = self._call_answer_model(strict_prompt)
                
                # Double-check the retry result
                retry_answer = result.get("correct_answer", "").strip().upper()
                if retry_answer in ["A", "B", "C", "D"]:
                    # Force a default value
                    result["correct_answer"] = "0"
                    result["solution"] = "ERROR: Could not extract proper value. " + result["solution"]
                    result["confidence"] = 0
            
        return result

    # ------------------------------------
    # ANSWER MCQ
    # ------------------------------------
    def _answer_mcq(self, q):
        prompt = f"""
You are an exam-solving expert. Solve the MCQ.

Question:
{q.get('text','')}

Options:
A: {q.get('option_a','')}
B: {q.get('option_b','')}
C: {q.get('option_c','')}
D: {q.get('option_d','')}

REQUIREMENTS:
- Choose ONLY A, B, C, or D
- Give a natural, flowing explanation
- Use Unicode math only (no LaTeX)
- Confidence score 0-100

JSON FORMAT:
{{
  "correct_answer": "B",
  "solution": "Looking at this problem, we need to calculate the force using Newton's second law. The mass is 10 kg and acceleration is 2 m/s¬≤, so force = mass √ó acceleration = 10 √ó 2 = 20 N. Comparing with the options, option B gives 20 N which matches our calculation.",
  "confidence": 88
}}
"""

        return self._call_answer_model(prompt)

    # ------------------------------------
    # CALL GPT-4.1 WITH JSON PARSING
    # ------------------------------------
    def _call_answer_model(self, prompt):
        payload = {
            "model": ANSWER_MODEL,
            "temperature": ANSWER_TEMP,
            "messages": [{"role": "user", "content": prompt}],
            "max_tokens": 800
        }

        try:
            r = requests.post(self.base_url, headers=self.headers, json=payload, timeout=60)
            if r.status_code != 200:
                return {
                    "correct_answer": "Error",
                    "solution": f"API error: {r.status_code}",
                    "confidence": 0
                }

            content = r.json()["choices"][0]["message"]["content"]
            
            # If response is cut off, try one more time with slightly more tokens
            if content.strip().endswith(('}', ']', '"')) == False:
                print("‚ö† Response appears truncated, retrying with more tokens...")
                payload["max_tokens"] = 1000
                r = requests.post(self.base_url, headers=self.headers, json=payload, timeout=60)
                content = r.json()["choices"][0]["message"]["content"]
                
            return self._safe_json(content)

        except Exception as e:
            return {
                "correct_answer": "Error",
                "solution": f"Exception: {e}",
                "confidence": 0
            }

    # ------------------------------------
    # SAFE JSON PARSER FOR ANSWERS
    # ------------------------------------
    def _safe_json(self, text):
        clean = re.sub(r'```json|```', '', text).strip()
        
        # Try to find JSON object with more flexible parsing
        try:
            # First try direct parsing
            result = json.loads(clean)
            # Ensure both fields exist
            if "correct_answer" not in result:
                result["correct_answer"] = ""
            if "solution" not in result:
                result["solution"] = ""
            if "confidence" not in result:
                result["confidence"] = 0
            return result
        except:
            pass
        
        try:
            # Try to find JSON object pattern
            match = re.search(r'\{.*\}', clean, re.DOTALL)
            if match:
                result = json.loads(match.group())
                # Ensure both fields exist
                if "correct_answer" not in result:
                    result["correct_answer"] = ""
                if "solution" not in result:
                    result["solution"] = ""
                if "confidence" not in result:
                    result["confidence"] = 0
                return result
        except:
            pass
        
        # If all parsing fails, return the raw content in solution field
        return {
            "correct_answer": "",
            "solution": clean,
            "confidence": 0
        }

    # -----------------------------------------------
    # GET ANSWERS SEQUENTIALLY
    # -----------------------------------------------
    def get_answers_sequential(self, questions: List[Dict]) -> List[Dict]:
        output = []

        for i, q in enumerate(questions):
            if "error" in q:
                output.append(q)
                continue

            print(f"üß† Solving question {i+1}/{len(questions)}: {q.get('number', 'Unknown')} ({q.get('type', 'MCQ')})")
            
            try:
                ans = self.analyze_question(q)
                combined = {**q, **ans}
                output.append(combined)
                
                # Show preview of answer
                correct_answer = ans.get('correct_answer', '')
                confidence = ans.get('confidence', 0)
                print(f"   ‚úÖ Answer: {correct_answer} | Confidence: {confidence}")
                
            except Exception as e:
                print(f"   ‚ùå Error: {e}")
                output.append({**q, "correct_answer": "Error", "solution": f"Processing error: {e}", "confidence": 0})

            time.sleep(1.0)

        return output


# =====================================================
#  GOOGLE SHEET ANSWER PROCESSOR
# =====================================================
class GoogleSheetAnswerProcessor:
    def __init__(self, credentials_file: str, sheet_id: str, api_key: str, sheet_tab: str):
        self.sheet_id = sheet_id
        self.sheet_tab = sheet_tab
        self.answer_generator = AnswerGenerator(api_key)
        self.service = self._auth(credentials_file)

    # ----------------------
    # AUTH
    # ----------------------
    def _auth(self, credentials_file):
        try:
            scopes = ['https://www.googleapis.com/auth/spreadsheets']
            creds = service_account.Credentials.from_service_account_file(
                credentials_file, scopes=scopes)
            return build('sheets', 'v4', credentials=creds)
        except Exception as e:
            print("Google Sheets Auth Failed:", e)
            raise

    # ----------------------
    # READ EXISTING QUESTIONS FROM SHEET
    # ----------------------
    def read_existing_questions(self):
        """
        Read already extracted questions from sheet (columns A-M)
        """
        try:
            result = self.service.spreadsheets().values().get(
                spreadsheetId=self.sheet_id,
                range=f"{self.sheet_tab}!A:M"
            ).execute()

            values = result.get("values", [])
            if len(values) < 2:
                return []

            questions = []
            
            for i, row in enumerate(values[1:], start=2):
                if len(row) < 4:
                    continue
                    
                question = {
                    "file_name": row[0] if len(row) > 0 else "",
                    "type": row[1] if len(row) > 1 else "",
                    "number": row[2] if len(row) > 2 else "",
                    "text": row[3] if len(row) > 3 else "",
                    "option_a": row[4] if len(row) > 4 else "",
                    "option_b": row[5] if len(row) > 5 else "",
                    "option_c": row[6] if len(row) > 6 else "",
                    "option_d": row[7] if len(row) > 7 else "",
                    "has_q_image": row[8] if len(row) > 8 else "",
                    "opt_images": row[9] if len(row) > 9 else "",
                    "has_instructions": row[10] if len(row) > 10 else "",
                    "instructions": row[11] if len(row) > 11 else "",
                    "row_number": i
                }
                
                if question["text"] and question["text"].strip():
                    questions.append(question)

            print(f"üìñ Read {len(questions)} existing questions from sheet")
            return questions

        except Exception as e:
            print("Error reading questions from sheet:", e)
            return []

    # ----------------------
    # CHECK IF ANSWERS ALREADY EXIST
    # ----------------------
    def check_existing_answers(self):
        """
        Check if answers already exist in columns N-P
        """
        try:
            result = self.service.spreadsheets().values().get(
                spreadsheetId=self.sheet_id,
                range=f"{self.sheet_tab}!N:P"
            ).execute()

            values = result.get("values", [])
            if len(values) < 2:
                return set()
            
            answered_rows = set()
            for i, row in enumerate(values[1:], start=2):
                if len(row) >= 1 and row[0] and row[0].strip() and row[0].strip() != "Error":
                    answered_rows.add(i)
            
            print(f"üìä Found {len(answered_rows)} rows with existing answers")
            return answered_rows

        except Exception as e:
            print("Error checking existing answers:", e)
            return set()

    # ----------------------
    # PROGRESS TRACKING
    # ----------------------
    def load_processed_questions(self):
        processed_questions = set()
        if os.path.exists(PROGRESS_FILE):
            try:
                with open(PROGRESS_FILE, 'r', newline='') as f:
                    reader = csv.reader(f)
                    for row in reader:
                        if row and len(row) >= 2:
                            key = f"{row[0]}_{row[1]}"
                            processed_questions.add(key)
                print(f"üìä Loaded {len(processed_questions)} processed questions from {PROGRESS_FILE}")
            except Exception as e:
                print(f"Error reading progress file: {e}")
        return processed_questions

    def save_processed_questions(self, processed_questions):
        try:
            with open(PROGRESS_FILE, 'w', newline='') as f:
                writer = csv.writer(f)
                for key in processed_questions:
                    file_name, q_number = key.split('_', 1)
                    writer.writerow([file_name, q_number])
        except Exception as e:
            print(f"Error saving progress file: {e}")

    def mark_question_processed(self, file_name, question_number, processed_questions):
        key = f"{file_name}_{question_number}"
        processed_questions.add(key)
        self.save_processed_questions(processed_questions)

    # ----------------------
    # UPDATE SHEET WITH ANSWERS
    # ----------------------
    def update_sheet_with_answers(self, questions_with_answers: List[Dict]):
        if not questions_with_answers:
            print("No answers to update")
            return

        updates = []
        for q in questions_with_answers:
            row_num = q.get("row_number", 0)
            if row_num == 0:
                continue
                
            confidence = q.get("confidence", 0)
            if isinstance(confidence, str):
                confidence_match = re.search(r'\d+', str(confidence))
                confidence = confidence_match.group() if confidence_match else "0"
            
            updates.append({
                "range": f"{self.sheet_tab}!N{row_num}:P{row_num}",
                "values": [[
                    q.get("correct_answer", ""),
                    q.get("solution", ""),
                    str(confidence)
                ]]
            })

        try:
            body = {
                "valueInputOption": "RAW",
                "data": updates
            }
            result = self.service.spreadsheets().values().batchUpdate(
                spreadsheetId=self.sheet_id,
                body=body
            ).execute()
            
            print(f"‚úÖ Updated {len(updates)} rows with answers")
            
        except Exception as e:
            print("Update failed:", e)

    # ----------------------
    # PROCESS ANSWERS FOR ALL QUESTIONS
    # ----------------------
    def process_all_answers(self, resume=True):
        print("üîç Reading existing questions from sheet...")
        questions = self.read_existing_questions()
        
        if not questions:
            print("‚ùå No questions found in sheet")
            return

        processed_questions = self.load_processed_questions()
        
        if resume and processed_questions:
            print(f"üìä Resuming - Found {len(processed_questions)} already processed questions")
        else:
            print("üÜï Starting fresh - No previous progress found")

        answered_rows = self.check_existing_answers()
        
        questions_to_process = []
        for q in questions:
            row_num = q.get("row_number")
            file_name = q.get("file_name", "")
            q_number = q.get("number", "")
            
            if row_num in answered_rows:
                continue
                
            if resume:
                key = f"{file_name}_{q_number}"
                if key in processed_questions:
                    continue
            
            questions_to_process.append(q)
        
        print(f"üìù Questions to process: {len(questions_to_process)}")
        mcq_count = len([q for q in questions_to_process if q.get("type") == "MCQ"])
        fill_count = len([q for q in questions_to_process if q.get("type") == "FILL_IN_BLANK"])
        print(f"üìä Breakdown - MCQ: {mcq_count}, Fill-in-Blank: {fill_count}")
        print(f"‚úÖ Already answered/processed: {len(questions) - len(questions_to_process)}")

        if not questions_to_process:
            print("üéâ All questions already have answers!")
            return

        print("\nüß† Generating answers...")
        questions_with_answers = self.answer_generator.get_answers_sequential(questions_to_process)

        print("\nüíæ Saving answers to sheet...")
        self.update_sheet_with_answers(questions_with_answers)

        for q in questions_with_answers:
            if "error" not in q:
                self.mark_question_processed(
                    q.get("file_name", ""), 
                    q.get("number", ""), 
                    processed_questions
                )

        print("\nüéâ ANSWER GENERATION COMPLETED!")


# =====================================================
# MAIN RUNNER
# =====================================================

def main():
    OPENAI_API_KEY = "your_openai_api_key_here"

    if not OPENAI_API_KEY or OPENAI_API_KEY == "your_openai_api_key_here":
        print("‚ùå ERROR: Please put your real OpenAI API key in the script.")
        return

    GOOGLE_SHEET_ID = "1U6gW0yqh3GZlkyxvhF_5k3sXMP8GwZT-TNsXqKv7S1o"
    CREDENTIALS_FILE = "service-account.json"
    SHEET_TAB = "Sheet4"
    RESUME_MODE = True

    print("\n" + "="*80)
    print(" üß† FIXED ANSWER GENERATION SCRIPT")
    print("="*80)
    print(f" Answer Model     : {ANSWER_MODEL}")
    print(f" Resume Mode      : {'ON' if RESUME_MODE else 'OFF'}")
    print(f" Progress File    : {PROGRESS_FILE}")
    print("="*80)

    try:
        processor = GoogleSheetAnswerProcessor(
            CREDENTIALS_FILE,
            GOOGLE_SHEET_ID,
            OPENAI_API_KEY,
            SHEET_TAB
        )

        processor.process_all_answers(resume=RESUME_MODE)

        print("\nüéâ ANSWER GENERATION COMPLETED SUCCESSFULLY!")

    except Exception as e:
        print("\n‚ùå FATAL ERROR:", e)

if __name__ == "__main__":
    main()
