import requests
import base64
import json
import re
import csv
import os
from PIL import Image
from io import BytesIO
from google.oauth2 import service_account
from googleapiclient.discovery import build
from typing import Dict, List, Tuple
import time
import concurrent.futures

# ==============================
#  MODEL SETTINGS
# ==============================
EXTRACTION_MODEL = "gpt-4o"        # OCR extraction
DETECTION_MODEL_CHEAP = "gpt-4o-mini"    # Cheap detection model first
DETECTION_MODEL_ACCURATE = "gpt-4o"      # Accurate detection model second

EXTRACTION_TEMP = 0.1
DETECTION_TEMP = 0.0

# Progress tracking file
PROGRESS_FILE = "processed_files_part1.csv"

# LESS AGGRESSIVE patterns for filename filtering
SKIP_PATTERNS = ['cover', 'title_page', 'instruction_only', 'answer_key', 'solution_manual']


# ========================================
#  MultiQuestionExtractor
# ========================================
class MultiQuestionExtractor:
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://api.openai.com/v1/chat/completions"
        self.headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {api_key}"
        }
        self.cheap_detection_count = 0
        self.accurate_detection_count = 0

    # --------------------------
    # IMAGE OPTIMIZATION - OPTIMIZED FOR COST
    # --------------------------
    def optimize_image(self, image_url, target_width=600):
        """Download + resize + convert ‚Üí base64 JPEG."""
        try:
            response = requests.get(image_url, timeout=30)
            img = Image.open(BytesIO(response.content))

            width, height = img.size
            if width > target_width:
                ratio = target_width / float(width)
                new_height = int(float(height) * ratio)
                img = img.resize((target_width, new_height), Image.Resampling.LANCZOS)

            if img.mode in ('RGBA', 'P'):
                img = img.convert('RGB')

            output = BytesIO()
            img.save(output, format='JPEG', quality=85, optimize=True)
            return base64.b64encode(output.getvalue()).decode('utf-8')

        except Exception as e:
            print(f"[Image optimization failed] {e}")
            return None

    # --------------------------
    # AUTO-FILL IMAGE OPTIONS
    # --------------------------
    def _fix_image_options(self, questions):
        for q in questions:
            if not q.get("option_a", "").strip():
                q["option_a"] = "[IMAGE]"
            if not q.get("option_b", "").strip():
                q["option_b"] = "[IMAGE]"
            if not q.get("option_c", "").strip():
                q["option_c"] = "[IMAGE]"
            if not q.get("option_d", "").strip():
                q["option_d"] = "[IMAGE]"
        return questions

    # --------------------------
    # HYBRID DETECTION - Cost-optimized approach
    # --------------------------
    def contains_questions(self, image_url: str, file_name: str) -> bool:
        """Hybrid detection: cheap model first, accurate model if uncertain"""
        
        # Step 1: Quick filename check (free)
        file_lower = file_name.lower()
        if any(pattern in file_lower for pattern in SKIP_PATTERNS):
            print(f"‚è≠Ô∏è {file_name} - Skipped by filename pattern")
            return False
        
        # Step 2: First pass with cheap model ($0.00015)
        cheap_result = self._detect_with_cheap_model(image_url, file_name)
        
        if cheap_result == "YES":
            print(f"‚úÖ {file_name} - Cheap model detected questions")
            return True
        elif cheap_result == "NO":
            print(f"‚è≠Ô∏è {file_name} - Cheap model says no questions")
            return False
        else:
            # Step 3: Second pass with accurate model ($0.0025)
            print(f"üîç {file_name} - Uncertain, using accurate model")
            accurate_result = self._detect_with_accurate_model(image_url, file_name)
            return accurate_result

    def _detect_with_cheap_model(self, image_url: str, file_name: str) -> str:
        """First pass with cheap model - cost: $0.00015 per image"""
        self.cheap_detection_count += 1
        
        base64_image = self.optimize_image(image_url, target_width=300)  # Very small for cost savings
        if not base64_image:
            return "UNCERTAIN"

        # OPTIMIZED PROMPT for chemistry questions
        detection_prompt = """
CRITICAL: This is for CHEMISTRY/SCIENCE exams. Look for:
1. Questions with numbers (Q39, 39., etc.)  
2. Chemical structures, molecular formulas, reactions
3. Multiple choice options (A) B) C) D)
4. Chemical notation like OEt, NaH, LIAH4, BuOOH
5. Structural formulas or diagrams
6. Text ending with "?" or question marks

If you see ANY chemical structures, numbered questions, or multiple choice options, answer YES.
If it's completely blank or only instructions, answer NO.

Answer ONLY "YES" or "NO".
"""

        payload = {
            "model": DETECTION_MODEL_CHEAP,
            "temperature": DETECTION_TEMP,
            "messages": [
                {
                    "role": "user",
                    "content": [
                        {"type": "text", "text": detection_prompt},
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:image/jpeg;base64,{base64_image}",
                                "detail": "low"
                            }
                        }
                    ]
                }
            ],
            "max_tokens": 5
        }

        try:
            response = requests.post(self.base_url, headers=self.headers, json=payload, timeout=20)
            if response.status_code == 200:
                content = response.json()["choices"][0]["message"]["content"].strip().upper()
                if "YES" in content:
                    return "YES"
                elif "NO" in content:
                    return "NO"
                else:
                    return "UNCERTAIN"
            else:
                print(f"Cheap detection API Error {response.status_code}")
                return "UNCERTAIN"
        except Exception as e:
            print(f"Cheap detection failed for {file_name}: {e}")
            return "UNCERTAIN"

    def _detect_with_accurate_model(self, image_url: str, file_name: str) -> bool:
        """Second pass with accurate model - cost: $0.0025 per image"""
        self.accurate_detection_count += 1
        
        base64_image = self.optimize_image(image_url, target_width=400)
        if not base64_image:
            return True  # When in doubt, process the image

        # COMPREHENSIVE PROMPT for accurate detection
        detection_prompt = """
Analyze this exam image thoroughly. Does it contain ANY question content including:

QUESTION PATTERNS:
- Numbered questions: Q39, 39., Q.39, etc.
- Multiple choice options: (A), (B), (C), (D)
- Questions ending with "?" or question text

CHEMISTRY/SCIENCE CONTENT:
- Chemical structures and molecular diagrams
- Chemical formulas: OEt, NaH, LIAH4, BuOOH, Ti(OPt)4, etc.
- Reaction schemes and chemical equations
- Structural formulas and organic chemistry notation
- Scientific diagrams and graphs

If you see ANY of the above question elements, chemical structures, or multiple choice content, answer YES.
If it's completely blank, only instructions, or a cover page, answer NO.

Answer ONLY "YES" or "NO".
"""

        payload = {
            "model": DETECTION_MODEL_ACCURATE,
            "temperature": DETECTION_TEMP,
            "messages": [
                {
                    "role": "user",
                    "content": [
                        {"type": "text", "text": detection_prompt},
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:image/jpeg;base64,{base64_image}",
                                "detail": "low"
                            }
                        }
                    ]
                }
            ],
            "max_tokens": 5
        }

        try:
            response = requests.post(self.base_url, headers=self.headers, json=payload, timeout=25)
            if response.status_code == 200:
                content = response.json()["choices"][0]["message"]["content"].strip().upper()
                result = "YES" in content
                print(f"üéØ Accurate detection for {file_name}: {'‚úÖ QUESTION' if result else '‚ùå NO QUESTION'}")
                return result
            else:
                print(f"Accurate detection API Error {response.status_code}")
                return True  # When in doubt, process
        except Exception as e:
            print(f"Accurate detection failed for {file_name}: {e}")
            return True  # When in doubt, process

    def print_detection_stats(self):
        """Print cost statistics for detection"""
        cheap_cost = self.cheap_detection_count * 0.00015
        accurate_cost = self.accurate_detection_count * 0.0025
        total_cost = cheap_cost + accurate_cost
        
        print(f"\nüí∞ DETECTION COST STATISTICS:")
        print(f"Cheap model detections: {self.cheap_detection_count} (${cheap_cost:.4f})")
        print(f"Accurate model detections: {self.accurate_detection_count} (${accurate_cost:.4f})")
        print(f"Total detection cost: ${total_cost:.4f}")
        print(f"Average cost per image: ${total_cost/(self.cheap_detection_count + self.accurate_detection_count):.6f}")

    # ----------------------------------------------
    # MAIN EXTRACTION: gpt-4o (OCR + question split)
    # ----------------------------------------------
    def extract_all_questions_from_image(self, image_url: str, file_name: str) -> List[Dict]:

        base64_image = self.optimize_image(image_url, target_width=600)
        if not base64_image:
            return [{"error": "Image processing failed", "file_name": file_name}]

        # IMPROVED PROMPT for chemistry questions
        prompt = """
You are an OCR expert for scientific exams. Extract ALL questions from this image.

SPECIAL ATTENTION FOR CHEMISTRY:
- Look for questions with chemical structures, reactions, and molecular formulas
- Preserve ALL chemical notation exactly: OEt, NaH, LIAH4, BuOOH, Ti(OPt)4, etc.
- Structural formulas may be represented with [IMAGE] placeholders
- Chemical compounds like "D-(Œ≥)-diethyl tartrate" should be preserved exactly

CRITICAL RULES:
1. PRESERVE ALL chemical notation, formulas, and symbols EXACTLY
2. Extract questions even if they use chemical structures instead of traditional numbering
3. For options with structural formulas, use [IMAGE] placeholders
4. Detect question type: "MCQ" or "FILL_IN_BLANK"
5. Extract instructions before questions
6. Output ONLY a valid JSON array

LOOK FOR THESE QUESTION PATTERNS:
- "Q.39", "39.", "Q39" etc.
- Questions about chemical reactions, products, structures
- Multiple choice options (A), B), C), D) even with chemical structures
- Questions ending with question marks

JSON SCHEMA:
[
  {
    "number": "Q39",
    "type": "MCQ", 
    "text": "question text [IMAGE] [IMAGE]",
    "option_a": "chemical formula or [IMAGE]",
    "option_b": "chemical formula or [IMAGE]", 
    "option_c": "chemical formula or [IMAGE]",
    "option_d": "chemical formula or [IMAGE]",
    "instructions": "any instructions before the question"
  }
]
"""

        payload = {
            "model": EXTRACTION_MODEL,
            "temperature": EXTRACTION_TEMP,
            "messages": [
                {
                    "role": "user",
                    "content": [
                        {"type": "text", "text": prompt},
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:image/jpeg;base64,{base64_image}",
                                "detail": "high"
                            }
                        }
                    ]
                }
            ],
            "max_tokens": 3000
        }

        try:
            print(f"üß™ Extracting chemistry questions from: {file_name}")
            response = requests.post(self.base_url, headers=self.headers, json=payload, timeout=90)

            if response.status_code != 200:
                error_msg = f"OCR API Error: {response.status_code}"
                if response.status_code == 400:
                    error_msg += " - Bad Request (check image format or size)"
                elif response.status_code == 429:
                    error_msg += " - Rate Limit Exceeded"
                elif response.status_code == 500:
                    error_msg += " - Internal Server Error"
                elif response.status_code == 503:
                    error_msg += " - Service Unavailable"
                
                print(f"{error_msg} for {file_name}")
                return [{"error": error_msg, "file_name": file_name}]

            content = response.json()["choices"][0]["message"]["content"].strip()

            # Parse JSON
            questions = self._parse_questions_json(content)
            if not questions:
                print("‚ö† OCR JSON parsing failed ‚Üí fallback text parser")
                return self._fallback_parse(content, file_name)

            # ADDED: Auto-fill image options
            questions = self._fix_image_options(questions)

            # Add defaults with safe type handling
            for q in questions:
                q["file_name"] = file_name
                q.setdefault("type", "MCQ")
                q.setdefault("option_a", "")
                q.setdefault("option_b", "")
                q.setdefault("option_c", "")
                q.setdefault("option_d", "")
                q.setdefault("instructions", "")

            print(f"‚úÖ Extracted {len(questions)} questions from {file_name}")
            return questions

        except Exception as e:
            return [{"error": f"Extraction failed: {e}", "file_name": file_name}]

    # --------------------------
    # JSON PARSER
    # --------------------------
    def _parse_questions_json(self, text):
        text = text.strip()

        # Direct array
        try:
            obj = json.loads(text)
            if isinstance(obj, list):
                return obj
        except:
            pass

        # Code block
        m = re.search(r'```json\s*(\[.*?\])\s*```', text, re.DOTALL)
        if m:
            try:
                return json.loads(m.group(1))
            except:
                pass

        # None found
        return None

    # -----------------------------------
    # FALLBACK TEXT PARSER (simple regex)
    # -----------------------------------
    def _fallback_parse(self, raw_text, file_name):

        lines = raw_text.split("\n")
        questions = []
        current = None
        instructions = []
        question_found = False

        for line in lines:
            t = line.strip()
            if not t:
                continue

            # instructions block BEFORE first question
            if not question_found and re.match(r'(instruction|direction|read)', t, re.I):
                instructions.append(t)
                continue

            # IMPROVED question detection for chemistry
            qmatch = re.match(r'(Q\.?\s*\d+|\d+\.)', t, re.I)
            if qmatch:
                question_found = True

                if current:
                    current["instructions"] = " ".join(instructions)
                    questions.append(current)

                num = qmatch.group(1)
                txt = t[len(num):].strip()

                current = {
                    "number": num.replace(".", ""),
                    "type": "MCQ",
                    "text": txt,
                    "option_a": "",
                    "option_b": "",
                    "option_c": "",
                    "option_d": "",
                    "instructions": "",
                    "file_name": file_name
                }
                continue

            # detect options
            if current:
                om = re.match(r'([A-D])[\.\)]\s*(.+)', t)
                if om:
                    key = f"option_{om.group(1).lower()}"
                    current[key] = om.group(2)
                    continue

                # add to question text
                current["text"] += " " + t

        # last question
        if current:
            current["instructions"] = " ".join(instructions)
            questions.append(current)

        return questions

    # -----------------------------------------------
    # PROCESS IMAGES IN BATCHES (OCR ONLY) - MAINTAINS ORDER
    # -----------------------------------------------
    def process_image_batch(self, image_batch: List[Tuple[str, str]]) -> List[Dict]:
        results = []
        
        # First, detect which images contain actual questions
        print("üîç Hybrid detection: cheap model first, accurate if uncertain...")
        valid_images = []
        
        for name, url in image_batch:
            if self.contains_questions(url, name):
                print(f"‚úÖ {name} - Contains questions")
                valid_images.append((name, url))
            else:
                print(f"‚è≠Ô∏è {name} - No questions found")
        
        if not valid_images:
            return results
            
        # Process only images with actual questions
        with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
            # Submit all tasks and store them in order
            future_to_index = {
                executor.submit(self.extract_all_questions_from_image, url, name): i 
                for i, (name, url) in enumerate(valid_images)
            }
            
            # Create a list to store results in original order
            temp_results = [None] * len(valid_images)
            
            for future in concurrent.futures.as_completed(future_to_index):
                index = future_to_index[future]
                fname, url = valid_images[index]
                try:
                    res = future.result()
                    temp_results[index] = res
                    # Request delay between API calls
                    time.sleep(2)
                except Exception as e:
                    temp_results[index] = [{"error": str(e), "file_name": fname}]
            
            # Flatten the results while maintaining order
            for result in temp_results:
                if result is not None:
                    results.extend(result)
        
        return results


# =====================================================
#  GOOGLE SHEET PROCESSOR - PART 1
# =====================================================
class GoogleSheetProcessorPart1:
    def __init__(self, credentials_file: str, sheet_id: str, api_key: str, sheet_tab: str):
        self.sheet_id = sheet_id
        self.sheet_tab = sheet_tab
        self.extractor = MultiQuestionExtractor(api_key)
        self.service = self._auth(credentials_file)

    # ----------------------
    # AUTH
    # ----------------------
    def _auth(self, credentials_file):
        try:
            scopes = ['https://www.googleapis.com/auth/spreadsheets']
            creds = service_account.Credentials.from_service_account_file(
                credentials_file, scopes=scopes)
            return build('sheets', 'v4', credentials=creds)
        except Exception as e:
            print("Google Sheets Auth Failed:", e)
            raise

    # ----------------------
    # READ SHEET
    # ----------------------
    def read_sheet(self):
        try:
            result = self.service.spreadsheets().values().get(
                spreadsheetId=self.sheet_id,
                range=f"{self.sheet_tab}!A:B"  # Only read file names and URLs
            ).execute()

            return result.get("values", [])
        except Exception as e:
            print("Error reading sheet:", e)
            return []

    # ----------------------
    # PROGRESS TRACKING - CSV BASED
    # ----------------------
    def load_processed_files(self):
        """Load already processed files from CSV"""
        processed_files = set()
        if os.path.exists(PROGRESS_FILE):
            try:
                with open(PROGRESS_FILE, 'r', newline='') as f:
                    reader = csv.reader(f)
                    for row in reader:
                        if row:
                            processed_files.add(row[0])
                print(f"üìä Loaded {len(processed_files)} processed files from {PROGRESS_FILE}")
            except Exception as e:
                print(f"Error reading progress file: {e}")
        return processed_files

    def save_processed_files(self, processed_files):
        """Save processed files to CSV"""
        try:
            with open(PROGRESS_FILE, 'w', newline='') as f:
                writer = csv.writer(f)
                for file_name in processed_files:
                    writer.writerow([file_name])
            print(f"üíæ Saved {len(processed_files)} processed files to {PROGRESS_FILE}")
        except Exception as e:
            print(f"Error saving progress file: {e}")

    def mark_file_processed(self, file_name, processed_files):
        """Mark a file as processed and save to CSV"""
        processed_files.add(file_name)
        self.save_processed_files(processed_files)

    # ----------------------
    # CLEAR OUTPUT COLUMNS (OPTIONAL - now only for full reset)
    # ----------------------
    def clear_output(self):
        try:
            # Clear columns C to N (question data columns)
            self.service.spreadsheets().values().clear(
                spreadsheetId=self.sheet_id,
                range=f"{self.sheet_tab}!C:N"
            ).execute()
            print("Old question data cleared (C:N).")
        except Exception as e:
            print("Clear failed:", e)

    # ----------------------
    # UPDATE SHEET
    # ----------------------
    def update_sheet(self, rows: List[List], start_row: int = 2):
        try:
            self.service.spreadsheets().values().update(
                spreadsheetId=self.sheet_id,
                range=f"{self.sheet_tab}!C{start_row}",
                valueInputOption="RAW",
                body={"values": rows}
            ).execute()
            print(f"Sheet updated successfully from row {start_row}.")
        except Exception as e:
            print("Update failed:", e)

    # =====================================================
    # PROCESS ALL IMAGES WITH RESUME CAPABILITY
    # =====================================================
    def process_all_images(self, batch_size=3, resume=True):

        data = self.read_sheet()

        if len(data) < 2:
            print("No data in sheet.")
            return

        # Load processed files from CSV
        processed_files = self.load_processed_files()
        
        if resume and processed_files:
            print(f"üìä Resuming - Found {len(processed_files)} already processed files")
        else:
            print("üÜï Starting fresh - No previous progress found")

        # Don't clear output if resuming and there are processed files
        if not resume or not processed_files:
            self.clear_output()

        # build batches, skip already processed files
        batches = []
        temp = []
        processed_count = 0

        for i, row in enumerate(data[1:], start=2):
            if len(row) < 2:
                continue

            fname = row[0]
            url = row[1]

            if not url.startswith("http"):
                continue

            # Skip already processed files when resuming
            if resume and fname in processed_files:
                processed_count += 1
                continue

            temp.append((fname, url))

            if len(temp) == batch_size:
                batches.append(temp)
                temp = []

        if temp:
            batches.append(temp)

        print(f"üìÅ New files to process: {sum(len(b) for b in batches)}")
        print(f"‚úÖ Already processed: {processed_count}")

        if not batches:
            print("üéâ All files already processed!")
            return

        # process batches
        all_questions = []

        for i, b in enumerate(batches, start=1):
            print(f"\n=== Processing batch {i}/{len(batches)} ===")
            qlist = self.extractor.process_image_batch(b)

            # Mark files as processed
            for q in qlist:
                if "file_name" in q and q["file_name"] not in processed_files:
                    self.mark_file_processed(q["file_name"], processed_files)

            all_questions.extend(qlist)
            time.sleep(3)  # Delay between batches

        # Print cost statistics
        self.extractor.print_detection_stats()

        # format sheet rows (only question data, no answers)
        # NEW COLUMN ORDER:
        # C=Type, D=Number, E=File Name, F=Instructions, G=Text, H=Option A, I=Option B, J=Option C, K=Option D
        rows = []

        for q in all_questions:
            if "error" in q:
                rows.append([
                    "ERROR",           # C: Type
                    "",                # D: Number  
                    q.get("file_name",""),  # E: File Name
                    "",               # F: Instructions
                    q["error"],        # G: Text
                    "", "", "", ""     # H-K: Options A-D
                ])
                continue
            
            rows.append([
                q.get("type",""),      # C: Type
                q.get("number",""),    # D: Number
                q.get("file_name",""), # E: File Name
                q.get("instructions",""),  # F: Instructions
                q.get("text",""),      # G: Text
                q.get("option_a",""),  # H: Option A
                q.get("option_b",""),  # I: Option B  
                q.get("option_c",""),  # J: Option C
                q.get("option_d","")   # K: Option D
            ])

        # Find the next empty row for appending
        existing_data_rows = len(data) - 1 if len(data) > 1 else 0
        next_row = existing_data_rows + 2  # +2 because header is row 1, data starts at row 2
        
        if rows:
            self.update_sheet(rows, next_row)
            print(f"‚úÖ Successfully updated {len(rows)} question rows to the sheet")
        else:
            print("‚ö† No question rows to update")

# =====================================================
# MAIN RUNNER - PART 1
# =====================================================

def main_part1():

    # ====== IMPORTANT CONFIGURATION ======
    OPENAI_API_KEY = "your_openai_api_key_here"

    if not OPENAI_API_KEY or OPENAI_API_KEY == "your_openai_api_key_here":
        print("‚ùå ERROR: Please put your real OpenAI API key in the script.")
        return

    GOOGLE_SHEET_ID = "1U6gW0yqh3GZlkyxvhF_5k3sXMP8GwZT-TNsXqKv7S1o"
    CREDENTIALS_FILE = "service-account.json"
    SHEET_TAB = "Sheet4"

    BATCH_SIZE = 3            # OCR images per batch
    RESUME_MODE = True        # Set to False to start from scratch

    print("\n" + "="*80)
    print(" üîç PART 1: QUESTION EXTRACTION WITH HYBRID DETECTION ")
    print("="*80)
    print(f" Extraction Model : {EXTRACTION_MODEL}")
    print(f" Detection Models : {DETECTION_MODEL_CHEAP} + {DETECTION_MODEL_ACCURATE}")
    print(f" Batch Size       : {BATCH_SIZE}")
    print(f" Resume Mode      : {'ON' if RESUME_MODE else 'OFF'}")
    print(f" Progress File    : {PROGRESS_FILE}")
    print("="*80)
    print("üí∞ Cost Strategy: Cheap detection first ($0.00015), accurate if uncertain ($0.0025)")
    print("="*80)

    try:
        processor = GoogleSheetProcessorPart1(
            CREDENTIALS_FILE,
            GOOGLE_SHEET_ID,
            OPENAI_API_KEY,
            SHEET_TAB
        )

        processor.process_all_images(batch_size=BATCH_SIZE, resume=RESUME_MODE)

        print("\nüéâ PART 1 COMPLETED SUCCESSFULLY!")
        print("All questions extracted and saved to sheet columns C through K.")

    except Exception as e:
        print(f"\n‚ùå FATAL ERROR: {e}")
        import traceback
        traceback.print_exc()


# =====================================================
# ENTRY POINT
# =====================================================
if __name__ == "__main__":
    main_part1()
