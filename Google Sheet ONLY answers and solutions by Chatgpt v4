import gspread
from oauth2client.service_account import ServiceAccountCredentials
from openai import OpenAI
import time

# ======================================
# ✅ GOOGLE SHEET CONFIG
# ======================================

GOOGLE_SHEET_ID = "1U6gW0yqh3GZlkyxvhF_5k3sXMP8GwZT-TNsXqKv7S1o"
CREDENTIALS_FILE = "service-account.json"
SHEET_TAB = "GATE PYQ1"

# ======================================
# ✅ OPENAI CONFIG
# ======================================

OPENAI_API_KEY = "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"
TEMPERATURE = 0

client = OpenAI(api_key=OPENAI_API_KEY)

# ======================================
# ✅ MODEL SELECTION (COST OPTIMIZED)
# ======================================

def choose_model(text):
    technical_keywords = [
        "calculate", "find the value", "solve", "integral", "derivative",
        "velocity", "current", "resistance", "probability", "matrix",
        "compound interest", "force", "acceleration", "voltage", "ohm",
        "energy", "power", "reactance", "frequency", "trigonometry"
    ]

    text = text.lower()
    for word in technical_keywords:
        if word in text:
            return "gpt-4.1"

    return "gpt-4o-mini"

# ======================================
# ✅ GOOGLE SHEET CONNECTION
# ======================================

scope = [
    "https://spreadsheets.google.com/feeds",
    "https://www.googleapis.com/auth/drive"
]

creds = ServiceAccountCredentials.from_json_keyfile_name(CREDENTIALS_FILE, scope)
gs_client = gspread.authorize(creds)

sheet = gs_client.open_by_key(GOOGLE_SHEET_ID).worksheet(SHEET_TAB)

data = sheet.get_all_values()
headers = data[0]
rows = data[1:]

def col(name):
    return headers.index(name)

IDX_TYPE     = col("Question type")
IDX_QTEXT    = col("question")
IDX_OPTA     = col("option1")
IDX_OPTB     = col("option2")
IDX_OPTC     = col("option3")
IDX_OPTD     = col("option4")
IDX_CORRECT  = col("Correct Option")
IDX_SOLUTION = col("explanation")
IDX_PENDING  = col("Pending")

# ======================================
# ✅ SMART HTML TABLE DETECTION
# ======================================

def smart_html_solution(raw_solution):
    if "|" in raw_solution and "\n" in raw_solution:
        rows = raw_solution.strip().split("\n")
        html_rows = ""
        for r in rows:
            cols = [c.strip() for c in r.split("|") if c.strip()]
            if cols:
                html_rows += "<tr>" + "".join(f"<td>{c}</td>" for c in cols) + "</tr>"

        return f"<table border='1' cellpadding='6' cellspacing='0' width='100%'>{html_rows}</table>"
    else:
        return raw_solution

# ======================================
# ✅ GPT SOLVER
# ======================================

def solve_question(qtype, question, optA, optB, optC, optD):
    model = choose_model(question)

    if qtype.lower() == "mcq":
        prompt = f"""
Question:
{question}

Options:
A) {optA}
B) {optB}
C) {optC}
D) {optD}

Return exactly:

Correct Option: A/B/C/D
Solution: Clear explanation (Unicode only, no LaTeX)
"""
    else:
        prompt = f"""
Fill in the blank:
{question}

Return exactly:

Answer: VALUE ONLY
Solution: Clear explanation (Unicode only, no LaTeX)
"""

    response = client.chat.completions.create(
        model=model,
        temperature=TEMPERATURE,
        messages=[{"role": "user", "content": prompt}]
    )

    return response.choices[0].message.content.strip()

# ======================================
# ✅ MAIN LOOP
# ======================================

for i, row in enumerate(rows, start=2):
    if row[IDX_PENDING].strip().lower() != "pending":
        continue

    qtype = row[IDX_TYPE].strip()
    qtext = row[IDX_QTEXT].strip()
    optA  = row[IDX_OPTA].strip()
    optB  = row[IDX_OPTB].strip()
    optC  = row[IDX_OPTC].strip()
    optD  = row[IDX_OPTD].strip()

    print(f"✅ Solving row {i}...")

    result = solve_question(qtype, qtext, optA, optB, optC, optD)

    if qtype.lower() == "mcq":
        correct = result.split("Correct Option:")[1].split("\n")[0].strip()
        raw_solution = result.split("Solution:")[1].strip()
    else:
        correct = result.split("Answer:")[1].split("\n")[0].strip()
        raw_solution = result.split("Solution:")[1].strip()

    solution = smart_html_solution(raw_solution)

    sheet.update_cell(i, IDX_CORRECT + 1, correct)
    sheet.update_cell(i, IDX_SOLUTION + 1, solution)
    sheet.update_cell(i, IDX_PENDING + 1, "done")

    time.sleep(1)

print("✅ ALL QUESTIONS SOLVED WITH COST OPTIMIZATION ✅")
