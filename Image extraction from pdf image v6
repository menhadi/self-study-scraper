import cv2
import numpy as np
import os
import csv
from collections import defaultdict
import traceback

# ======================================
# ‚úÖ CORRECT PATHS
# ======================================
INPUT_ROOT  = r"D:\Vector Academy\Contents\PYQ\GATE\Image"
OUTPUT_ROOT = r"D:\Vector Academy\Contents\PYQ\GATE\Image1"
CSV_PATH    = r"C:\Users\menha\Downloads\input.csv"  # Keep your original CSV path
DEBUG_DIR   = r"C:\Users\menha\Downloads\test\debug"

os.makedirs(OUTPUT_ROOT, exist_ok=True)
os.makedirs(DEBUG_DIR, exist_ok=True)

min_area = 3500

def crop_header_footer(img):
    h, w, _ = img.shape
    top = int(0.06 * h)
    bottom = int(0.95 * h)
    return img[top:bottom, :]

def iou(boxA, boxB):
    xA = max(boxA[0], boxB[0])
    yA = max(boxA[1], boxB[1])
    xB = min(boxA[0] + boxA[2], boxB[0] + boxB[2])
    yB = min(boxA[1] + boxA[3], boxB[1] + boxB[3])
    inter = max(0, xB - xA) * max(0, yB - yA)
    union = boxA[2]*boxA[3] + boxB[2]*boxB[3] - inter
    return inter / union if union != 0 else 0

def non_max_suppression(boxes, thresh=0.45):
    if not boxes:
        return []
    boxes = sorted(boxes, key=lambda b: b[2]*b[3], reverse=True)
    final = []
    while boxes:
        best = boxes.pop(0)
        final.append(best)
        boxes = [b for b in boxes if iou(best, b) < thresh]
    return final

def pad_box(x, y, w, h, img_w, img_h, pad_ratio=0.10):
    px = int(w * pad_ratio)
    py = int(h * pad_ratio)
    x0 = max(0, x - px)
    y0 = max(0, y - py)
    x1 = min(img_w, x + w + px)
    y1 = min(img_h, y + h + py)
    return x0, y0, x1 - x0, y1 - y0

def is_text_like(crop, threshold=0.20):
    if crop.size == 0:
        return True
    gray = cv2.cvtColor(crop, cv2.COLOR_BGR2GRAY)
    edges = cv2.Canny(gray, 60, 160)
    density = np.sum(edges > 0) / edges.size
    return density > threshold

def visualize_page_detection(page_cropped, boxes, questions, file_name, save_dir):
    """Visualize detected boxes and question positions for debugging"""
    debug_img = page_cropped.copy()
    
    # Draw all detected boxes
    for i, (x, y, w, h) in enumerate(boxes):
        cv2.rectangle(debug_img, (x, y), (x+w, y+h), (0, 255, 0), 2)
        cv2.putText(debug_img, f"Box {i}", (x, y-10), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
    
    # Draw estimated question positions
    H, W = page_cropped.shape[:2]
    for i, (question_num, _, _) in enumerate(questions):
        estimated_y = int((H / len(questions)) * (i + 0.5))
        cv2.line(debug_img, (0, estimated_y), (W, estimated_y), (255, 0, 0), 2)
        cv2.putText(debug_img, f"Q{question_num}", (10, estimated_y-10), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 0, 0), 2)
    
    # Clean file name for saving
    clean_name = os.path.splitext(file_name)[0].replace(' ', '_').replace('/', '_')
    debug_path = os.path.join(save_dir, f"debug_{clean_name}.png")
    cv2.imwrite(debug_path, debug_img)
    print(f"   üìä Debug visualization saved: {debug_path}")
    return debug_path

def extract_images_from_page(page_cropped, boxes, questions, save_dir, folder, subfolder, file_name):
    """Extract images using improved matching logic"""
    H, W = page_cropped.shape[:2]
    questions_sorted = sorted(questions, key=lambda x: x[0])
    boxes_sorted = sorted(boxes, key=lambda b: b[1])  # Sort by y-coordinate
    
    print(f"   üì¶ Processing {len(boxes_sorted)} boxes for {len(questions_sorted)} questions")
    
    # If we have exactly one box per question, use direct matching
    if len(boxes_sorted) == len(questions_sorted):
        print(f"   ‚úÖ Direct 1:1 matching")
        for i, ((_, question_no_str, image_name), box) in enumerate(zip(questions_sorted, boxes_sorted)):
            x, y, w, h = box
            crop = page_cropped[y:y + h, x:x + w]
            
            if is_text_like(crop):
                print(f"   ‚ö†Ô∏è  Box {i} for Q{question_no_str} looks like text")
                continue
            
            if not os.path.splitext(image_name)[1]:
                image_name += ".png"
            
            out_path = os.path.join(save_dir, image_name)
            cv2.imwrite(out_path, crop)
            print(f"   ‚úÖ Q{question_no_str} ‚Üí {image_name}")
        return True
    
    # If we have more boxes than questions, we need to filter and match
    print(f"   üîç Need to match {len(boxes_sorted)} boxes to {len(questions_sorted)} questions")
    
    # First, filter out text-like boxes
    image_boxes = []
    for i, box in enumerate(boxes_sorted):
        x, y, w, h = box
        crop = page_cropped[y:y + h, x:x + w]
        if not is_text_like(crop):
            image_boxes.append((i, box, crop))
    
    print(f"   üìä After filtering text: {len(image_boxes)} image-like boxes")
    
    # If we still have more boxes than questions, use size and position heuristics
    if len(image_boxes) >= len(questions_sorted):
        # Sort boxes by size (largest first) and take top N
        image_boxes_sorted = sorted(image_boxes, key=lambda b: b[1][2]*b[1][3], reverse=True)
        top_boxes = image_boxes_sorted[:len(questions_sorted)]
        
        # Sort top boxes by y-coordinate
        top_boxes_sorted = sorted(top_boxes, key=lambda b: b[1][1])
        
        for i, ((_, question_no_str, image_name), (orig_idx, box, _)) in enumerate(zip(questions_sorted, top_boxes_sorted)):
            x, y, w, h = box
            crop = page_cropped[y:y + h, x:x + w]
            
            if not os.path.splitext(image_name)[1]:
                image_name += ".png"
            
            out_path = os.path.join(save_dir, image_name)
            cv2.imwrite(out_path, crop)
            print(f"   ‚úÖ Q{question_no_str} ‚Üí {image_name} (box {orig_idx})")
        return True
    
    # If we have fewer image boxes than questions
    print(f"   ‚ö†Ô∏è  Only {len(image_boxes)} suitable image boxes found for {len(questions_sorted)} questions")
    
    # Match available boxes to questions based on position
    for i, (orig_idx, box, _) in enumerate(image_boxes):
        if i < len(questions_sorted):
            _, question_no_str, image_name = questions_sorted[i]
            x, y, w, h = box
            crop = page_cropped[y:y + h, x:x + w]
            
            if not os.path.splitext(image_name)[1]:
                image_name += ".png"
            
            out_path = os.path.join(save_dir, image_name)
            cv2.imwrite(out_path, crop)
            print(f"   ‚úÖ Q{question_no_str} ‚Üí {image_name} (box {orig_idx})")
    
    return len(image_boxes) > 0

# ======================================
# ‚úÖ LOAD CSV - GROUP BY FILE NAME
# ======================================
file_groups = defaultdict(list)

try:
    with open(CSV_PATH, newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        print("\n‚úÖ CSV HEADERS FOUND:", reader.fieldnames)
        
        # folder and file_name are mandatory, sub_folder is optional
        required_fields = ["folder", "file_name", "question_no", "image name"]
        if not all(field in reader.fieldnames for field in required_fields):
            print(f"‚ùå Missing required fields in CSV")
            print(f"   Required: {required_fields}")
            print(f"   Found: {reader.fieldnames}")
            exit(1)

        for row_num, row in enumerate(reader, 1):
            try:
                # Get folder (mandatory)
                folder = row["folder"].strip()
                if not folder:
                    print(f"‚ö†Ô∏è  Row {row_num}: Missing folder")
                    continue
                
                # Get file_name (mandatory, replacing page_no)
                file_name = row["file_name"].strip()
                if not file_name:
                    print(f"‚ö†Ô∏è  Row {row_num}: Missing file_name")
                    continue
                
                # Get sub_folder (optional)
                sub_folder = row.get("sub_folder", "").strip()
                
                # Create key: (folder, sub_folder, file_name)
                # sub_folder can be empty string
                key = (folder, sub_folder, file_name)
                
                question_no = row["question_no"].strip()
                image_name = row["image name"].strip()
                
                # Validate other data
                if not question_no or not image_name:
                    print(f"‚ö†Ô∏è  Row {row_num}: Missing question_no or image name")
                    continue
                    
                # Convert question_no to integer for sorting, keep original for display
                try:
                    question_num = int(question_no)
                except ValueError:
                    print(f"‚ö†Ô∏è  Row {row_num}: Invalid question number '{question_no}', using 999")
                    question_num = 999
                
                file_groups[key].append((question_num, question_no, image_name))
                
            except Exception as e:
                print(f"‚ùå Error processing row {row_num}: {e}")
                continue

except Exception as e:
    print(f"‚ùå Error reading CSV: {e}")
    traceback.print_exc()
    exit(1)

print(f"\n‚úÖ Loaded {sum(len(v) for v in file_groups.values())} images from CSV")
print(f"‚úÖ Found {len(file_groups)} unique files")

# Sort files for consistent processing
sorted_files = sorted(file_groups.items(), key=lambda x: (
    x[0][0],  # folder
    x[0][1],  # subfolder (can be empty)
    x[0][2]   # file_name
))

# ======================================
# ‚úÖ FILE FINDER
# ======================================
def find_file_path(folder, subfolder, file_name):
    """
    Find file with the given name in the folder/subfolder structure.
    subfolder can be empty string.
    """
    # Build path based on whether subfolder is provided
    if subfolder:  # subfolder is not empty
        folder_path = os.path.join(INPUT_ROOT, folder, subfolder)
    else:  # no subfolder
        folder_path = os.path.join(INPUT_ROOT, folder)
    
    if not os.path.isdir(folder_path):
        print(f"‚ùå Folder not found: {folder_path}")
        return None
    
    # Check if file exists directly
    file_path = os.path.join(folder_path, file_name)
    if os.path.exists(file_path):
        return file_path
    
    # Try to find file with different extensions
    base_name = os.path.splitext(file_name)[0]
    files = os.listdir(folder_path)
    
    # Common image extensions to try
    extensions = ['.png', '.jpg', '.jpeg', '.PNG', '.JPG', '.JPEG', '.bmp', '.BMP']
    
    for ext in extensions:
        possible_file = base_name + ext
        if possible_file in files:
            return os.path.join(folder_path, possible_file)
    
    # Try case-insensitive match
    file_lower = file_name.lower()
    for f in files:
        if f.lower() == file_lower:
            return os.path.join(folder_path, f)
    
    # Try matching base name without extension
    for f in files:
        if os.path.splitext(f)[0] == base_name:
            return os.path.join(folder_path, f)
    
    print(f"   üîç File '{file_name}' not found in {folder_path}")
    print(f"   üìÇ Available files: {files[:10]}" + ("..." if len(files) > 10 else ""))
    return None

# ======================================
# ‚úÖ MAIN EXTRACTION WITH ERROR HANDLING
# ======================================
successful_files = 0
failed_files = []

for (folder, subfolder, file_name), questions in sorted_files:
    print(f"\n{'='*60}")
    print(f"üìÑ Processing: Folder={folder}, Sub={subfolder or '(none)'}, File={file_name}")
    print(f"   Questions: {[q[1] for q in sorted(questions, key=lambda x: x[0])]}")
    
    try:
        # Find the file
        file_path = find_file_path(folder, subfolder, file_name)
        
        if not file_path:
            print(f"‚ùå File not found")
            failed_files.append((folder, subfolder, file_name, "File not found"))
            continue
        
        # Load the image
        img = cv2.imread(file_path)
        if img is None:
            print(f"‚ùå Failed to load image: {file_path}")
            failed_files.append((folder, subfolder, file_name, "Failed to load image"))
            continue
        
        print(f"   ‚úÖ Loaded file: {os.path.basename(file_path)} ({img.shape[1]}x{img.shape[0]})")
        
        # Crop header and footer
        page_cropped = crop_header_footer(img)
        H, W = page_cropped.shape[:2]
        print(f"   üìê Cropped size: {W}x{H}")
        
        # Try multiple preprocessing methods
        gray = cv2.cvtColor(page_cropped, cv2.COLOR_BGR2GRAY)
        
        # Method 1: Adaptive threshold
        th1 = cv2.adaptiveThreshold(
            gray, 255,
            cv2.ADAPTIVE_THRESH_MEAN_C,
            cv2.THRESH_BINARY_INV,
            17, 3
        )
        
        # Method 2: Canny edges
        edges = cv2.Canny(gray, 60, 160)
        
        # Method 3: Simple threshold (for different image types)
        _, th2 = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
        
        # Combine methods
        combined = cv2.bitwise_or(th1, edges)
        combined = cv2.bitwise_or(combined, th2)
        
        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (4, 4))
        dilated = cv2.dilate(combined, kernel, iterations=2)
        
        # Try different contour retrieval modes
        contours1, _ = cv2.findContours(dilated, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        contours2, _ = cv2.findContours(dilated, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
        
        # Use the method that finds more contours
        contours = contours1 if len(contours1) > len(contours2) else contours2
        
        print(f"   üîç Found {len(contours)} contours")
        
        raw_boxes = []
        for cnt in contours:
            x, y, w, h = cv2.boundingRect(cnt)
            area = w * h
            aspect = w / h if h != 0 else 0
            
            # Check if file_name contains "2" (like page_2.png)
            if "2" in file_name or "page2" in file_name.lower():
                if area > 2000 and 60 < w < 2500 and 60 < h < 1800 and 0.1 < aspect < 10.0:
                    x, y, w, h = pad_box(x, y, w, h, W, H)
                    raw_boxes.append((x, y, w, h))
            else:
                if area > min_area and 80 < w < 2200 and 80 < h < 1600 and 0.15 < aspect < 7.0:
                    x, y, w, h = pad_box(x, y, w, h, W, H)
                    raw_boxes.append((x, y, w, h))
        
        boxes = non_max_suppression(raw_boxes)
        print(f"   üì¶ After NMS: {len(boxes)} boxes")
        
        # Create save directory
        # Include subfolder in output path only if it exists
        if subfolder:
            save_dir = os.path.join(OUTPUT_ROOT, folder, subfolder)
        else:
            save_dir = os.path.join(OUTPUT_ROOT, folder)
        
        os.makedirs(save_dir, exist_ok=True)
        
        # Visualize for debugging
        debug_path = visualize_page_detection(page_cropped, boxes, questions, file_name, DEBUG_DIR)
        
        # Extract images
        success = extract_images_from_page(page_cropped, boxes, questions, save_dir, folder, subfolder, file_name)
        
        if success:
            successful_files += 1
            print(f"   ‚úÖ File '{file_name}' processed successfully")
        else:
            failed_files.append((folder, subfolder, file_name, "No images extracted"))
            print(f"   ‚ö†Ô∏è  No images extracted from file '{file_name}'")
            
    except Exception as e:
        print(f"‚ùå Error processing file '{file_name}': {e}")
        traceback.print_exc()
        failed_files.append((folder, subfolder, file_name, f"Error: {str(e)}"))

print(f"\n{'='*60}")
print("üéØ EXTRACTION SUMMARY")
print(f"{'='*60}")
print(f"‚úÖ Successful files: {successful_files}/{len(sorted_files)}")
print(f"‚ùå Failed files: {len(failed_files)}")

if failed_files:
    print("\nFailed files:")
    for folder, subfolder, file_name, reason in failed_files:
        subfolder_display = subfolder if subfolder else "(none)"
        print(f"  - {folder}/{subfolder_display}/{file_name}: {reason}")

print(f"\nüìÇ Input folder: {INPUT_ROOT}")
print(f"üìÇ Output base folder: {OUTPUT_ROOT}")
print(f"üêõ Debug visualizations: {DEBUG_DIR}")
