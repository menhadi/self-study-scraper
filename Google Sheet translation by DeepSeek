import requests
import json
from google.oauth2 import service_account
from googleapiclient.discovery import build
from typing import List, Tuple, Dict
import time
import concurrent.futures
import re

# ==============================
#  CONFIGURATION
# ==============================
DEEPSEEK_API_KEY = "your_deepseek_api_key_here"
GOOGLE_SHEET_ID = "1U6gW0yqh3GZlkyxvhF_5k3sXMP8GwZT-TNsXqKv7S1o"
CREDENTIALS_FILE = "service-account.json"
SHEET_TAB = "Sheet4"

# Target languages
TARGET_LANGUAGES = ["Hindi", "Bengali"]

# Performance settings
MAX_WORKERS = 3

# ==============================
#  COMPLETELY PERMISSIVE TRANSLATION SERVICE
# ==============================
class DeepSeekTranslationService:
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://api.deepseek.com/v1/chat/completions"
        self.headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {api_key}"
        }
        self.translation_cache = {}

    def should_skip_translation(self, text: str) -> bool:
        """VERY PERMISSIVE - only skip truly untranslatable content"""
        if not text or not text.strip():
            return True
        
        text_clean = text.strip()
        
        # Skip ONLY these specific patterns (very restrictive list)
        skip_patterns = [
            # Pure numbers with units: "1.0 J", "7 NS" 
            r'^\d+\.?\d*\s*[A-Z]{1,2}$',
            # Pure fractions: "2/3", "1/2"
            r'^\d+\/\d+$',
            # Single mathematical symbols with operators: "I‚ÇÄ/4"
            r'^[A-Za-zŒ±-œâŒë-Œ©‚ÇÄ-‚Çâ]+\s*[\/\*\^]\s*[\d\.]+$',
            # Pure numbers/decimal: "0.5", "123"
            r'^\d+\.?\d*$',
            # Single letters: "A", "B", "C"
            r'^[A-Z]$',
        ]
        
        for pattern in skip_patterns:
            if re.match(pattern, text_clean):
                return True
                
        # SPECIAL CASE: If text ends with "‡§π‡•à" (Hindi) or similar, it's already translated
        if any(marker in text_clean for marker in ['‡§π‡•à', '‡§π‡•ã‡§§‡§æ', '‡§ï‡§∞', '‡§ó‡§Ø‡§æ', '‡§§‡•Ä', '‡§§‡§æ']):
            print(f"‚ö†Ô∏è  Already translated text detected: {text_clean[:50]}...")
            return True
            
        # DEFAULT: Translate everything else
        return False

    def translate_batch(self, texts_with_info: List[Tuple[str, str, str, int]]) -> List[Tuple[str, str, int]]:
        """Translate multiple texts using DeepSeek API"""
        results = []
        
        # Separate cached texts and texts needing translation
        texts_to_translate = []
        
        for text, lang, field_type, row_idx in texts_with_info:
            cache_key = f"{text}_{lang}"
            
            if cache_key in self.translation_cache:
                results.append((self.translation_cache[cache_key], field_type, row_idx))
            elif self.should_skip_translation(text):
                results.append((text, field_type, row_idx))
                self.translation_cache[cache_key] = text
            else:
                texts_to_translate.append((text, lang, field_type, row_idx, cache_key))
        
        if not texts_to_translate:
            return results
            
        print(f"üî§ Translating {len(texts_to_translate)} texts for row {texts_to_translate[0][3]}...")
        
        # Show what we're translating
        for text, _, field_type, _, _ in texts_to_translate[:3]:  # Show first 3
            print(f"   üìÑ {field_type}: {text[:80]}{'...' if len(text) > 80 else ''}")
            
        # Process texts needing translation
        with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
            future_to_info = {
                executor.submit(self._translate_single, text, lang): 
                (text, lang, field_type, row_idx, cache_key)
                for text, lang, field_type, row_idx, cache_key in texts_to_translate
            }
            
            for future in concurrent.futures.as_completed(future_to_info):
                text, lang, field_type, row_idx, cache_key = future_to_info[future]
                try:
                    translated = future.result()
                    results.append((translated, field_type, row_idx))
                    self.translation_cache[cache_key] = translated
                    
                    # Show translation result
                    if translated != text:
                        print(f"   ‚úÖ Translated: {translated[:80]}{'...' if len(translated) > 80 else ''}")
                    
                except Exception as e:
                    print(f"DeepSeek translation failed for row {row_idx}: {e}")
                    results.append((text, field_type, row_idx))
                    self.translation_cache[cache_key] = text
                    
        return results

    def _translate_single(self, text: str, target_language: str) -> str:
        """Translate single text using DeepSeek"""
        if self.should_skip_translation(text):
            return text
            
        prompt = f"""
Translate the following technical/scientific/mathematical text to {target_language}, but follow these rules carefully:

RULES:
1. Translate ALL words, phrases, and descriptive text to {target_language}
2. PRESERVE EXACTLY the following in original form:
   - Mathematical symbols: xÃá, Œît, Œª‚Çô, œÄ, etc.
   - Equations and formulas
   - Numbers, units, constants
   - Variables and function names: f(x), x‚Çô, etc.
   - Proper nouns: Euler, etc.
   - Acronyms and technical abbreviations
3. Maintain the original technical meaning completely
4. Keep mathematical notation and symbols unchanged
5. Translate only the natural language parts

Text to translate:
"{text}"

Return ONLY the translated text, no explanations.
"""

        payload = {
            "model": "deepseek-chat",
            "temperature": 0.1,
            "messages": [{"role": "user", "content": prompt}],
            "max_tokens": 1500,  # Increased for longer technical texts
            "stream": False
        }

        try:
            response = requests.post(self.base_url, headers=self.headers, json=payload, timeout=90)
            if response.status_code == 200:
                content = response.json()["choices"][0]["message"]["content"].strip()
                # Remove quotes if present
                content = content.strip('"')
                return content
            else:
                print(f"DeepSeek API error: {response.status_code}")
                return text
        except requests.exceptions.Timeout:
            print("DeepSeek API timeout, using original text")
            return text
        except Exception as e:
            print(f"DeepSeek API exception: {e}")
            return text

# ==============================
#  GOOGLE SHEET MANAGER
# ==============================
class GoogleSheetManager:
    def __init__(self, credentials_file: str, sheet_id: str, sheet_tab: str):
        self.sheet_id = sheet_id
        self.sheet_tab = sheet_tab
        self.service = self._auth(credentials_file)

    def _auth(self, credentials_file):
        try:
            scopes = ['https://www.googleapis.com/auth/spreadsheets']
            creds = service_account.Credentials.from_service_account_file(
                credentials_file, scopes=scopes)
            return build('sheets', 'v4', credentials=creds)
        except Exception as e:
            print("Google Sheets Auth Failed:", e)
            raise

    def read_sheet_data(self):
        try:
            result = self.service.spreadsheets().values().get(
                spreadsheetId=self.sheet_id,
                range=f"{self.sheet_tab}!A:O"
            ).execute()
            return result.get("values", [])
        except Exception as e:
            print("Error reading sheet:", e)
            return []

    def update_translations(self, translations_data: List[List]):
        if not translations_data:
            print("No translation data to update")
            return

        try:
            self.service.spreadsheets().values().clear(
                spreadsheetId=self.sheet_id,
                range=f"{self.sheet_tab}!R:ZZ"
            ).execute()
            print("Cleared previous translations (R:ZZ)")

            self.service.spreadsheets().values().update(
                spreadsheetId=self.sheet_id,
                range=f"{self.sheet_tab}!R1",
                valueInputOption="RAW",
                body={"values": translations_data}
            ).execute()
            print("Translations updated successfully")
        except Exception as e:
            print("Update failed:", e)

# ==============================
#  TRANSLATION PROCESSOR WITH DETAILED LOGGING
# ==============================
class TranslationProcessor:
    def __init__(self, sheet_manager: GoogleSheetManager, translation_service: DeepSeekTranslationService):
        self.sheet_manager = sheet_manager
        self.translation_service = translation_service

    def process_translations(self):
        print("üìñ Reading sheet data...")
        data = self.sheet_manager.read_sheet_data()
        
        if len(data) < 2:
            print("No data found in sheet")
            return

        # Prepare headers
        headers = ["Original Text"]
        for lang in TARGET_LANGUAGES:
            headers.extend([
                f"{lang} - Question Text",
                f"{lang} - Option A", 
                f"{lang} - Option B",
                f"{lang} - Option C",
                f"{lang} - Option D",
                f"{lang} - Solution"
            ])

        translation_rows = [headers]

        print(f"üîÑ Processing {len(data)-1} rows with COMPLETELY PERMISSIVE logic...")
        print("üí° Translating EVERYTHING except pure numbers/symbols")
        
        total_texts = 0
        skipped_texts = 0
        
        for row_index, row in enumerate(data[1:], start=2):
            if len(row) < 15:
                row.extend([''] * (15 - len(row)))
            
            question_text = row[5] if len(row) > 5 else ""
            option_a = row[6] if len(row) > 6 else ""
            option_b = row[7] if len(row) > 7 else ""
            option_c = row[8] if len(row) > 8 else ""
            option_d = row[9] if len(row) > 9 else ""
            solution = row[13] if len(row) > 13 else ""

            translation_row = [f"Row {row_index}"]
            
            # Check what will be translated vs skipped
            all_texts = [question_text, option_a, option_b, option_c, option_d, solution]
            field_names = ["Question", "Option A", "Option B", "Option C", "Option D", "Solution"]
            
            print(f"\nüìã Row {row_index} Analysis:")
            for text, field_name in zip(all_texts, field_names):
                if text and text.strip():
                    if self.translation_service.should_skip_translation(text):
                        print(f"   ‚è≠Ô∏è  {field_name}: SKIPPED - '{text}'")
                    else:
                        print(f"   ‚úÖ {field_name}: WILL TRANSLATE - '{text}'")
            
            for lang in TARGET_LANGUAGES:
                texts_to_translate = [
                    (question_text, lang, "question", row_index),
                    (option_a, lang, "option_a", row_index),
                    (option_b, lang, "option_b", row_index),
                    (option_c, lang, "option_c", row_index),
                    (option_d, lang, "option_d", row_index),
                    (solution, lang, "solution", row_index)
                ]
                
                total_texts += len(texts_to_translate)
                
                # Count skipped vs translated
                for text, _, _, _ in texts_to_translate:
                    if self.translation_service.should_skip_translation(text):
                        skipped_texts += 1

                translated_results = self.translation_service.translate_batch(texts_to_translate)
                
                result_map = {}
                for translated_text, field_type, _ in translated_results:
                    result_map[field_type] = translated_text
                
                translation_row.extend([
                    result_map.get("question", question_text),
                    result_map.get("option_a", option_a),
                    result_map.get("option_b", option_b),
                    result_map.get("option_c", option_c),
                    result_map.get("option_d", option_d),
                    result_map.get("solution", solution)
                ])

            translation_rows.append(translation_row)
            
            time.sleep(0.5)  # Slightly longer delay for stability
            
            if (row_index - 1) % 1 == 0:  # Show progress every row
                print(f"‚úÖ Completed {row_index-1}/{len(data)-1} rows...")

        cost_estimate = self._calculate_cost_estimate(total_texts - skipped_texts)
        print(f"\nüìä FINAL SUMMARY:")
        print(f"   Total texts processed: {total_texts}")
        print(f"   Texts translated: {total_texts - skipped_texts}")
        print(f"   Texts skipped: {skipped_texts}")
        print(f"   Translation rate: {(total_texts - skipped_texts)/total_texts*100:.1f}%")
        print(f"üí∞ Estimated cost: ${cost_estimate:.4f}")
        
        self.sheet_manager.update_translations(translation_rows)

    def _calculate_cost_estimate(self, translated_texts_count: int) -> float:
        """Estimate DeepSeek API cost"""
        estimated_tokens = translated_texts_count * 250  # Slightly higher for technical text
        cost_per_million = 0.28
        return (estimated_tokens / 1_000_000) * cost_per_million

# ==============================
#  MAIN EXECUTION
# ==============================
def main():
    if not DEEPSEEK_API_KEY or DEEPSEEK_API_KEY == "your_deepseek_api_key_here":
        print("‚ùå ERROR: Please set your DeepSeek API key")
        print("üí° Get API key from: https://platform.deepseek.com/api_keys")
        return

    print("\n" + "="*70)
    print("üåç COMPLETELY PERMISSIVE DEEPSEEK TRANSLATION SCRIPT")
    print("="*70)
    print(f"Target Languages: {', '.join(TARGET_LANGUAGES)}")
    print("‚ú® TRANSLATING: All technical/scientific text with English words")
    print("‚ú® INCLUDING: 'Euler iteration formula', 'differential equations', etc.")
    print("‚è≠Ô∏è  SKIPPING ONLY: Pure numbers (1.0 J), fractions (2/3), single symbols")
    print("="*70)

    try:
        sheet_manager = GoogleSheetManager(CREDENTIALS_FILE, GOOGLE_SHEET_ID, SHEET_TAB)
        translation_service = DeepSeekTranslationService(DEEPSEEK_API_KEY)
        processor = TranslationProcessor(sheet_manager, translation_service)

        start_time = time.time()
        processor.process_translations()
        end_time = time.time()

        print(f"\nüéâ COMPLETE TRANSLATION FINISHED!")
        print(f"‚è±Ô∏è  Total time: {end_time - start_time:.2f} seconds")
        print("üí° All meaningful content including technical text should now be translated")

    except Exception as e:
        print(f"\n‚ùå TRANSLATION FAILED: {e}")

if __name__ == "__main__":
    main()
