/******************************
 * CONFIGURATION
 ******************************/
const DB_URL  = 'jdbc:mysql://38.242.242.133:3306/exampace1';
const DB_USER = 'sheet_user';
const DB_PASS = 'StrongPassword123!';
const BATCH_SIZE = 300;
const TIMESTAMP_FORMAT = 'yyyy-MM-dd HH:mm:ss';

/******************************
 * üîº PUSH FUNCTION (Sheet ‚Üí DB)
 * Pushes "Pending" rows to DB
 ******************************/
function pushSheetToDB() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getActiveSheet();
  const tableName = sheet.getName();
  Logger.log(`üîº Pushing data from Sheet "${tableName}" ‚Üí DB...`);

  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const statusCol = headers.findIndex(h => h.trim().toLowerCase() === 'syncstatus');
  if (statusCol === -1) return Logger.log('‚ùå Missing SyncStatus column.');

  const lastRow = sheet.getLastRow();
  if (lastRow < 2) return Logger.log('‚ÑπÔ∏è No data rows.');

  const statusVals = sheet.getRange(2, statusCol + 1, lastRow - 1).getValues().flat();
  const pending = statusVals.map((v, i) => v && v.toString().toLowerCase() === 'pending' ? i + 2 : null).filter(Boolean);
  if (!pending.length) return Logger.log(`‚úÖ No pending rows to push for ${tableName}`);

  const conn = Jdbc.getConnection(DB_URL, DB_USER, DB_PASS);
  conn.createStatement().execute('SET foreign_key_checks = 0;');

  let pushed = 0;
  for (const r of pending.slice(0, BATCH_SIZE)) {
    const row = sheet.getRange(r, 1, 1, headers.length).getValues()[0];
    const cols = headers.filter(h => h.trim().toLowerCase() !== 'syncstatus');
    const vals = [];

    for (let c = 0; c < headers.length; c++) {
      if (c === statusCol) continue;
      const name = headers[c].trim().toLowerCase();
      let val = row[c];

      if ((name === 'created_at' || name === 'updated_at') && (!val || val === '')) { vals.push('NOW()'); continue; }
      if (val === null || val === '' || val.toString().toLowerCase() === 'null') { vals.push('NULL'); continue; }
      if (Object.prototype.toString.call(val) === '[object Date]') {
        vals.push(`'${Utilities.formatDate(val, Session.getScriptTimeZone(), TIMESTAMP_FORMAT)}'`); continue;
      }
      if (typeof val === 'string') { vals.push(`'${val.replace(/'/g, "''")}'`); continue; }
      vals.push(val);
    }

    const q = `
      INSERT INTO ${tableName} (${cols.join(',')})
      VALUES (${vals.join(',')})
      ON DUPLICATE KEY UPDATE ${cols.map(c => `${c}=VALUES(${c})`).join(',')}, updated_at=NOW();
    `;

    try {
      conn.createStatement().execute(q);
      sheet.getRange(r, statusCol + 1).setValue('Synced');
      pushed++;
    } catch (e) {
      Logger.log(`‚ö†Ô∏è SQL error row ${r}: ${e.message}`);
      sheet.getRange(r, statusCol + 1).setValue('Error');
    }
  }

  conn.createStatement().execute('SET foreign_key_checks = 1;');
  conn.close();
  Logger.log(`‚úÖ ${pushed} rows pushed successfully.`);
}

/******************************
 * ‚¨áÔ∏è PULL FUNCTION (DB ‚Üí Sheet)
 * Updates, Inserts & Deletes (Mirror)
 ******************************/
function pullDBToSheet() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getActiveSheet();
  const tableName = sheet.getName();
  Logger.log(`‚¨áÔ∏è Pulling (mirror sync) data from DB ‚Üí Sheet "${tableName}"...`);

  const props = PropertiesService.getScriptProperties();
  const lastSync = props.getProperty(`lastSync_${tableName}`) || '1970-01-01 00:00:00';
  const conn = Jdbc.getConnection(DB_URL, DB_USER, DB_PASS);

  try {
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const idIndex = headers.findIndex(h => h.trim().toLowerCase() === 'id');
    if (idIndex === -1) { Logger.log('‚ùå Missing "id" column.'); conn.close(); return; }
    const hasSyncStatus = headers.some(h => h.trim().toLowerCase() === 'syncstatus');

    const totalRows = sheet.getLastRow();
    let existingIds = [];
    if (totalRows >= 2) {
      existingIds = sheet.getRange(2, idIndex + 1, totalRows - 1, 1).getValues().flat()
        .filter(v => v != null && v !== '')
        .map(v => v.toString());
    }

    // ‚úÖ Create temp table with sheet IDs
    const stmt = conn.createStatement();
    stmt.execute('DROP TEMPORARY TABLE IF EXISTS tmp_sheet_ids;');
    stmt.execute('CREATE TEMPORARY TABLE tmp_sheet_ids (id BIGINT PRIMARY KEY);');
    const CHUNK = 1000;
    for (let i = 0; i < existingIds.length; i += CHUNK) {
      const chunk = existingIds.slice(i, i + CHUNK).map(id => `(${id})`).join(',');
      if (chunk) stmt.execute(`INSERT IGNORE INTO tmp_sheet_ids (id) VALUES ${chunk}`);
    }

    // ‚úÖ Get updates & new inserts
    const rs = stmt.executeQuery(`
      SELECT t.* FROM ${tableName} t
      LEFT JOIN tmp_sheet_ids s ON t.id = s.id
      WHERE s.id IS NULL OR t.updated_at > '${lastSync}'
      ORDER BY t.updated_at ASC;
    `);

    const meta = rs.getMetaData(), cols = meta.getColumnCount();
    const dbCols = Array.from({ length: cols }, (_, i) => meta.getColumnName(i + 1));
    const sheetData = totalRows >= 2 ? sheet.getRange(2, 1, totalRows - 1, sheet.getLastColumn()).getValues() : [];
    const idToRow = {};
    for (let i = 0; i < sheetData.length; i++) {
      const id = sheetData[i][idIndex];
      if (id != null && id !== '') idToRow[id.toString()] = i + 2;
    }

    const toUpdate = [], toAppend = [];
    let maxUpdatedAt = null, u = 0, a = 0;

    while (rs.next()) {
      const dbRow = Array.from({ length: cols }, (_, i) => rs.getString(i + 1));
      const dbId = rs.getString('id');
      const updatedAt = rs.getString('updated_at');
      if (updatedAt && (!maxUpdatedAt || new Date(updatedAt) > new Date(maxUpdatedAt))) maxUpdatedAt = updatedAt;

      const syncRow = hasSyncStatus ? [...dbRow, 'Synced'] : dbRow;
      const rowNum = dbId ? idToRow[dbId] : null;
      if (rowNum) { toUpdate.push({ rowNum, values: syncRow }); u++; }
      else { toAppend.push(syncRow); a++; }
    }

    // ‚úÖ Apply updates and inserts
    toUpdate.forEach(x => sheet.getRange(x.rowNum, 1, 1, x.values.length).setValues([x.values]));
    if (toAppend.length) {
      const start = sheet.getLastRow() + 1;
      sheet.getRange(start, 1, toAppend.length, toAppend[0].length).setValues(toAppend);
    }

    // ‚úÖ Detect and delete missing rows
    const rsDelete = stmt.executeQuery(`SELECT id FROM tmp_sheet_ids WHERE id NOT IN (SELECT id FROM ${tableName});`);
    const idsToDelete = [];
    while (rsDelete.next()) idsToDelete.push(rsDelete.getString('id'));
    if (idsToDelete.length) {
      Logger.log(`üóëÔ∏è Deleting ${idsToDelete.length} rows removed from DB...`);
      const rowsToRemove = idsToDelete.map(id => idToRow[id]).filter(Boolean).sort((a,b)=>b-a);
      rowsToRemove.forEach(r => sheet.deleteRow(r));
      Logger.log(`‚úÖ Deleted ${rowsToRemove.length} missing rows.`);
    }

    // ‚úÖ Update lastSync timestamp
    const nowStr = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), TIMESTAMP_FORMAT);
    props.setProperty(`lastSync_${tableName}`, maxUpdatedAt || nowStr);
    Logger.log(`‚úÖ Pull complete: Updated ${u}, Inserted ${a}, Deleted ${idsToDelete.length}. lastSync=${maxUpdatedAt || nowStr}`);

    rs.close(); rsDelete.close(); stmt.close(); conn.close();
  } catch (e) {
    Logger.log(`‚ùå Pull error: ${e.message}`);
    try { conn.close(); } catch (_) {}
  }
}

/******************************
 * ü™Ñ AUTO MARK EDITED ROWS AS PENDING
 ******************************/
function onEdit(e) {
  const sheet = e.range.getSheet();
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const syncCol = headers.findIndex(h => h.trim().toLowerCase() === 'syncstatus');
  if (syncCol === -1) return;
  if (e.range.getRow() > 1 && e.range.getColumn() !== syncCol + 1) {
    const cell = sheet.getRange(e.range.getRow(), syncCol + 1);
    if (cell.getValue().toString().toLowerCase() !== 'pending') cell.setValue('Pending');
  }
}

/******************************
 * ‚ôªÔ∏è RESET LAST SYNC (Manual use)
 ******************************/
function resetLastSync(tableName) {
  PropertiesService.getScriptProperties().deleteProperty('lastSync_' + tableName);
  Logger.log(`üîÅ lastSync_${tableName} reset.`);
}
