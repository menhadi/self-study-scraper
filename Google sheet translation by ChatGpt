import requests
import json
from google.oauth2 import service_account
from googleapiclient.discovery import build
from typing import List, Tuple, Dict
import time
import concurrent.futures
import re

# ==============================
#  CONFIGURATION
# ==============================
OPENAI_API_KEY = "your_openai_api_key_here"
GOOGLE_SHEET_ID = "1U6gW0yqh3GZlkyxvhF_5k3sXMP8GwZT-TNsXqKv7S1o"
CREDENTIALS_FILE = "service-account.json"
SHEET_TAB = "Sheet4"

# Target languages
TARGET_LANGUAGES = ["Hindi", "Bengali"]

# Cost optimization settings
USE_GPT35 = True  # Set to False for GPT-4 (better quality but 20x more expensive)
SKIP_SHORT_TEXT = True  # Skip translation for very short/technical text
MIN_TEXT_LENGTH = 10  # Minimum characters to translate
BATCH_TEXT = True  # Combine multiple texts in one API call
MAX_WORKERS = 2  # Reduce concurrent calls to avoid rate limits

# ==============================
#  TRANSLATION SERVICE (OPTIMIZED)
# ==============================
class TranslationService:
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://api.openai.com/v1/chat/completions"
        self.headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {api_key}"
        }
        self.translation_cache = {}  # Cache to avoid duplicate translations

    def should_skip_translation(self, text: str) -> bool:
        """Check if text should be skipped from translation to save costs"""
        if not text or not text.strip():
            return True
            
        if SKIP_SHORT_TEXT:
            # Skip very short text
            if len(text.strip()) < MIN_TEXT_LENGTH:
                return True
            
            # Skip text that's mostly numbers/symbols
            clean_text = re.sub(r'[0-9\s\.\/\-]', '', text)
            if len(clean_text) < 3:
                return True
                
            # Skip common technical terms that don't need translation
            skip_patterns = [
                r'^\d+\.?\d*\s*[A-Z]*$',  # "1.0 J", "7 NS" etc.
                r'^[A-Za-z]+\/?[A-Za-z]*$',  # Single words/acronyms
                r'^[‚Öì‚Öî¬º¬æ¬Ω‚Öõ‚Öú‚Öù‚Öû]$',  # Fractions
            ]
            
            for pattern in skip_patterns:
                if re.match(pattern, text.strip()):
                    return True
                    
        return False

    def translate_batch_optimized(self, texts_with_info: List[Tuple[str, str, str, int]]) -> List[Tuple[str, str, int]]:
        """Optimized batch translation with cost savings"""
        results = []
        
        # Filter out texts that don't need translation
        texts_to_process = []
        cache_keys = []
        
        for text, lang, field_type, row_idx in texts_with_info:
            cache_key = f"{text}_{lang}"
            
            if cache_key in self.translation_cache:
                # Use cached translation
                results.append((self.translation_cache[cache_key], field_type, row_idx))
            elif self.should_skip_translation(text):
                # Skip translation, use original
                results.append((text, field_type, row_idx))
                self.translation_cache[cache_key] = text  # Cache the decision
            else:
                # Needs translation
                texts_to_process.append((text, lang, field_type, row_idx, cache_key))
        
        if not texts_to_process:
            return results
            
        # Process remaining texts
        if BATCH_TEXT and len(texts_to_process) > 1:
            # Try to batch multiple texts in one API call
            batched_results = self._translate_batch_single_call(texts_to_process)
            results.extend(batched_results)
        else:
            # Process individually
            individual_results = self._translate_individual(texts_to_process)
            results.extend(individual_results)
            
        return results

    def _translate_batch_single_call(self, texts_to_process: List[Tuple]) -> List[Tuple]:
        """Batch multiple texts in a single API call"""
        try:
            # Group by language for more efficient batching
            lang_groups = {}
            for text, lang, field_type, row_idx, cache_key in texts_to_process:
                if lang not in lang_groups:
                    lang_groups[lang] = []
                lang_groups[lang].append((text, field_type, row_idx, cache_key))
            
            batch_results = []
            
            for lang, lang_texts in lang_groups.items():
                if len(lang_texts) == 1:
                    # Single text, process individually
                    text, field_type, row_idx, cache_key = lang_texts[0]
                    translated = self._translate_single_optimized(text, lang)
                    batch_results.append((translated, field_type, row_idx))
                    self.translation_cache[cache_key] = translated
                else:
                    # Multiple texts for same language - batch them
                    batch_prompt = self._create_batch_prompt(lang_texts, lang)
                    batch_response = self._call_api_optimized(batch_prompt)
                    
                    if batch_response:
                        parsed_results = self._parse_batch_response(batch_response, lang_texts, lang)
                        batch_results.extend(parsed_results)
                    else:
                        # Fallback to individual translation
                        for text, field_type, row_idx, cache_key in lang_texts:
                            translated = self._translate_single_optimized(text, lang)
                            batch_results.append((translated, field_type, row_idx))
                            self.translation_cache[cache_key] = translated
                            
            return batch_results
            
        except Exception as e:
            print(f"Batch translation failed, falling back to individual: {e}")
            return self._translate_individual(texts_to_process)

    def _create_batch_prompt(self, lang_texts: List[Tuple], target_language: str) -> str:
        """Create a batch prompt for multiple texts"""
        prompt_parts = [
            f"Translate the following texts to {target_language}. Follow these rules:",
            "1. Translate ONLY common words and conversational phrases",
            "2. PRESERVE scientific terms, numbers, symbols, equations in original English",
            "3. Return translations in the EXACT same order as input",
            "4. Format: 'TRANSLATION: [translated text]' for each",
            "",
            "TEXTS TO TRANSLATE:"
        ]
        
        for i, (text, _, _, _) in enumerate(lang_texts, 1):
            prompt_parts.append(f"{i}. {text}")
            
        prompt_parts.append("\nTRANSLATIONS:")
        return "\n".join(prompt_parts)

    def _parse_batch_response(self, response: str, lang_texts: List[Tuple], target_language: str) -> List[Tuple]:
        """Parse batch API response"""
        results = []
        lines = response.strip().split('\n')
        translation_map = {}
        
        current_num = None
        for line in lines:
            line = line.strip()
            if line.startswith('TRANSLATION:'):
                trans_text = line.replace('TRANSLATION:', '').strip()
                if current_num is not None and 1 <= current_num <= len(lang_texts):
                    translation_map[current_num] = trans_text
            elif re.match(r'^\d+\.', line):
                try:
                    current_num = int(line.split('.')[0])
                except:
                    pass
        
        # Map translations back to original texts
        for i, (text, field_type, row_idx, cache_key) in enumerate(lang_texts, 1):
            translated = translation_map.get(i, text)  # Fallback to original
            results.append((translated, field_type, row_idx))
            self.translation_cache[cache_key] = translated
            
        return results

    def _translate_individual(self, texts_to_process: List[Tuple]) -> List[Tuple]:
        """Fallback individual translation"""
        results = []
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
            future_to_info = {
                executor.submit(self._translate_single_optimized, text, lang): 
                (text, lang, field_type, row_idx, cache_key)
                for text, lang, field_type, row_idx, cache_key in texts_to_process
            }
            
            for future in concurrent.futures.as_completed(future_to_info):
                text, lang, field_type, row_idx, cache_key = future_to_info[future]
                try:
                    translated = future.result()
                    results.append((translated, field_type, row_idx))
                    self.translation_cache[cache_key] = translated
                except Exception as e:
                    print(f"Individual translation failed: {e}")
                    results.append((text, field_type, row_idx))  # Fallback to original
                    
        return results

    def _translate_single_optimized(self, text: str, target_language: str) -> str:
        """Optimized single text translation"""
        if self.should_skip_translation(text):
            return text
            
        prompt = f"""
Translate to {target_language} but preserve technical terms/numbers:
{text}

Return ONLY the translated text.
"""

        return self._call_api_optimized(prompt)

    def _call_api_optimized(self, prompt: str) -> str:
        """Make optimized API call"""
        model = "gpt-3.5-turbo" if USE_GPT35 else "gpt-4"
        
        payload = {
            "model": model,
            "temperature": 0.1,
            "messages": [{"role": "user", "content": prompt}],
            "max_tokens": 500  # Reduced for cost savings
        }

        try:
            response = requests.post(self.base_url, headers=self.headers, json=payload, timeout=60)
            if response.status_code == 200:
                return response.json()["choices"][0]["message"]["content"].strip()
            return None
        except Exception as e:
            print(f"API call failed: {e}")
            return None

# ==============================
#  GOOGLE SHEET MANAGER (SAME AS BEFORE)
# ==============================
class GoogleSheetManager:
    def __init__(self, credentials_file: str, sheet_id: str, sheet_tab: str):
        self.sheet_id = sheet_id
        self.sheet_tab = sheet_tab
        self.service = self._auth(credentials_file)

    def _auth(self, credentials_file):
        try:
            scopes = ['https://www.googleapis.com/auth/spreadsheets']
            creds = service_account.Credentials.from_service_account_file(
                credentials_file, scopes=scopes)
            return build('sheets', 'v4', credentials=creds)
        except Exception as e:
            print("Google Sheets Auth Failed:", e)
            raise

    def read_sheet_data(self):
        try:
            result = self.service.spreadsheets().values().get(
                spreadsheetId=self.sheet_id,
                range=f"{self.sheet_tab}!A:O"
            ).execute()
            return result.get("values", [])
        except Exception as e:
            print("Error reading sheet:", e)
            return []

    def update_translations(self, translations_data: List[List]):
        if not translations_data:
            print("No translation data to update")
            return

        try:
            self.service.spreadsheets().values().clear(
                spreadsheetId=self.sheet_id,
                range=f"{self.sheet_tab}!R:ZZ"
            ).execute()
            print("Cleared previous translations (R:ZZ)")

            self.service.spreadsheets().values().update(
                spreadsheetId=self.sheet_id,
                range=f"{self.sheet_tab}!R1",
                valueInputOption="RAW",
                body={"values": translations_data}
            ).execute()
            print("Translations updated successfully")
        except Exception as e:
            print("Update failed:", e)

# ==============================
#  TRANSLATION PROCESSOR (OPTIMIZED)
# ==============================
class TranslationProcessor:
    def __init__(self, sheet_manager: GoogleSheetManager, translation_service: TranslationService):
        self.sheet_manager = sheet_manager
        self.translation_service = translation_service

    def process_translations(self):
        print("üìñ Reading sheet data...")
        data = self.sheet_manager.read_sheet_data()
        
        if len(data) < 2:
            print("No data found in sheet")
            return

        # Prepare headers
        headers = ["Original Text"]
        for lang in TARGET_LANGUAGES:
            headers.extend([
                f"{lang} - Question Text",
                f"{lang} - Option A", 
                f"{lang} - Option B",
                f"{lang} - Option C",
                f"{lang} - Option D",
                f"{lang} - Solution"
            ])

        translation_rows = [headers]

        print(f"üîÑ Processing {len(data)-1} rows with cost optimization...")
        print(f"üí∞ Using: {'GPT-3.5 Turbo' if USE_GPT35 else 'GPT-4'}")
        print(f"‚ö° Skipping short text: {SKIP_SHORT_TEXT}")
        print(f"üì¶ Batch processing: {BATCH_TEXT}")
        
        total_texts = 0
        skipped_texts = 0
        
        for row_index, row in enumerate(data[1:], start=2):
            if len(row) < 15:
                row.extend([''] * (15 - len(row)))
            
            question_text = row[5] if len(row) > 5 else ""
            option_a = row[6] if len(row) > 6 else ""
            option_b = row[7] if len(row) > 7 else ""
            option_c = row[8] if len(row) > 8 else ""
            option_d = row[9] if len(row) > 9 else ""
            solution = row[13] if len(row) > 13 else ""

            translation_row = [f"Row {row_index}"]
            
            for lang in TARGET_LANGUAGES:
                texts_to_translate = [
                    (question_text, lang, "question", row_index),
                    (option_a, lang, "option_a", row_index),
                    (option_b, lang, "option_b", row_index),
                    (option_c, lang, "option_c", row_index),
                    (option_d, lang, "option_d", row_index),
                    (solution, lang, "solution", row_index)
                ]
                
                total_texts += len(texts_to_translate)
                
                # Count skipped texts for reporting
                for text, _, _, _ in texts_to_translate:
                    if self.translation_service.should_skip_translation(text):
                        skipped_texts += 1

                translated_results = self.translation_service.translate_batch_optimized(texts_to_translate)
                
                result_map = {}
                for translated_text, field_type, _ in translated_results:
                    result_map[field_type] = translated_text
                
                translation_row.extend([
                    result_map.get("question", question_text),
                    result_map.get("option_a", option_a),
                    result_map.get("option_b", option_b),
                    result_map.get("option_c", option_c),
                    result_map.get("option_d", option_d),
                    result_map.get("solution", solution)
                ])

            translation_rows.append(translation_row)
            
            if (row_index - 1) % 5 == 0:
                print(f"‚úÖ Completed {row_index-1}/{len(data)-1} rows...")

        print(f"üìä Cost Summary: {skipped_texts}/{total_texts} texts skipped ({skipped_texts/total_texts*100:.1f}% savings)")
        
        self.sheet_manager.update_translations(translation_rows)

# ==============================
#  MAIN EXECUTION
# ==============================
def main():
    if not OPENAI_API_KEY or OPENAI_API_KEY == "your_openai_api_key_here":
        print("‚ùå ERROR: Please set your OpenAI API key")
        return

    print("\n" + "="*60)
    print("üåç COST-OPTIMIZED TRANSLATION SCRIPT")
    print("="*60)
    print(f"Target Languages: {', '.join(TARGET_LANGUAGES)}")
    print(f"Model: {'GPT-3.5 Turbo' if USE_GPT35 else 'GPT-4'}")
    print(f"Cost Savings: Skip short text, Batch processing, Caching")
    print("="*60)

    try:
        sheet_manager = GoogleSheetManager(CREDENTIALS_FILE, GOOGLE_SHEET_ID, SHEET_TAB)
        translation_service = TranslationService(OPENAI_API_KEY)
        processor = TranslationProcessor(sheet_manager, translation_service)

        start_time = time.time()
        processor.process_translations()
        end_time = time.time()

        print(f"\nüéâ TRANSLATION COMPLETED!")
        print(f"‚è±Ô∏è  Total time: {end_time - start_time:.2f} seconds")
        print(f"üí∞ Estimated cost reduction: 60-80% compared to original")

    except Exception as e:
        print(f"\n‚ùå TRANSLATION FAILED: {e}")

if __name__ == "__main__":
    main()
