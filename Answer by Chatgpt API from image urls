import requests
import base64
import json
import re
from PIL import Image
from io import BytesIO
from google.oauth2 import service_account
from googleapiclient.discovery import build
from typing import Dict, List, Tuple
import time
import concurrent.futures

class MultiQuestionExtractor:
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://api.openai.com/v1/chat/completions"
        self.headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {api_key}"
        }
    
    def optimize_image(self, image_url, target_width=768):
        """Optimize image for better text readability"""
        try:
            response = requests.get(image_url, timeout=30)
            img = Image.open(BytesIO(response.content))
            
            width, height = img.size
            if width > target_width:
                ratio = target_width / float(width)
                new_height = int(float(height) * ratio)
                img = img.resize((target_width, new_height), Image.Resampling.LANCZOS)
            
            if img.mode in ('RGBA', 'P'):
                img = img.convert('RGB')
                
            output = BytesIO()
            img.save(output, format='JPEG', quality=90, optimize=True)
            return base64.b64encode(output.getvalue()).decode('utf-8')
            
        except Exception as e:
            print(f"Image optimization failed: {e}")
            return None
    
    def extract_all_questions_from_image(self, image_url: str, file_name: str) -> List[Dict]:
        """Extract ALL questions from a single image containing multiple questions"""
        
        base64_image = self.optimize_image(image_url)
        if not base64_image:
            return [{"error": "Image processing failed", "file_name": file_name}]
        
        prompt = """ANALYZE THIS EDUCATIONAL QUESTION PAPER IMAGE:

EXTRACTION RULES:
1. Extract EACH question separately
2. DETERMINE QUESTION TYPE: "MCQ" or "FILL_IN_BLANK"
3. EXTRACT any INSTRUCTIONS that appear
4. For MATHEMATICAL EQUATIONS and CHEMICAL FORMULAS, convert to UNICODE TEXT format (NOT LaTeX)
5. DETECT if there are any DIAGRAMS, IMAGES, or VISUAL ELEMENTS

CRITICAL: Return ONLY a SINGLE JSON ARRAY. Do NOT return multiple JSON objects.

OUTPUT FORMAT: Return ONLY valid JSON array:
[
  {
    "question_type": "MCQ",
    "question_number": "Q.1",
    "question_text": "question text",
    "option_a": "A text",
    "option_b": "B text",
    "option_c": "C text", 
    "option_d": "D text",
    "has_question_image": false,
    "options_with_images": [],
    "has_instruction_image": false,
    "instructions": ""
  },
  {
    "question_type": "FILL_IN_BLANK",
    "question_number": "Q.2", 
    "question_text": "question text",
    "option_a": "",
    "option_b": "",
    "option_c": "",
    "option_d": "",
    "has_question_image": false,
    "options_with_images": [],
    "has_instruction_image": false,
    "instructions": ""
  }
]

IMPORTANT: Return ONLY the JSON array, no other text."""
        
        payload = {
            "model": "gpt-4o",
            "messages": [
                {
                    "role": "user",
                    "content": [
                        {"type": "text", "text": prompt},
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:image/jpeg;base64,{base64_image}",
                                "detail": "high"
                            }
                        }
                    ]
                }
            ],
            "max_tokens": 4000,
            "temperature": 0.1
        }
        
        try:
            print(f"Extracting questions from: {file_name}")
            response = requests.post(self.base_url, headers=self.headers, json=payload, timeout=60)
            
            if response.status_code == 200:
                result = response.json()
                content = result['choices'][0]['message']['content'].strip()
                print("Raw extraction completed")
                
                # Improved JSON parsing
                questions = self._parse_questions_json_improved(content)
                
                if not questions:
                    print("âŒ No questions extracted, using enhanced fallback")
                    return self._enhanced_fallback_extraction(content, file_name)
                
                # Add file name to each question and ensure all fields exist
                for question in questions:
                    question["file_name"] = file_name
                    # Ensure all fields exist with defaults
                    question.setdefault("question_type", "UNKNOWN")
                    question.setdefault("has_question_image", False)
                    question.setdefault("options_with_images", [])
                    question.setdefault("has_instruction_image", False)
                    question.setdefault("instructions", "")
                    # For fill-in-blank questions, ensure options are empty
                    if question.get("question_type") == "FILL_IN_BLANK":
                        question["option_a"] = question.get("option_a", "")
                        question["option_b"] = question.get("option_b", "")
                        question["option_c"] = question.get("option_c", "")
                        question["option_d"] = question.get("option_d", "")
                        question["options_with_images"] = []
                
                print(f"âœ… Extracted {len(questions)} questions from {file_name}")
                return questions
            else:
                return [{"error": f"API Error: {response.status_code}", "file_name": file_name}]
                
        except Exception as e:
            return [{"error": f"Extraction failed: {str(e)}", "file_name": file_name}]
    
    def _parse_questions_json_improved(self, text: str) -> List[Dict]:
        """Improved JSON parsing with multiple fallback methods"""
        text = text.strip()
        print(f"Attempting to parse JSON from response (first 500 chars): {text[:500]}...")
        
        # Method 1: Try direct JSON array parsing
        try:
            data = json.loads(text)
            if isinstance(data, list):
                print("âœ… Method 1: Direct JSON array parsing successful")
                return data
        except json.JSONDecodeError as e:
            print(f"Method 1 failed: {e}")
        
        # Method 2: Try to extract JSON array from code blocks
        try:
            json_match = re.search(r'```(?:json)?\s*(\[.*\])\s*```', text, re.DOTALL)
            if json_match:
                data = json.loads(json_match.group(1))
                if isinstance(data, list):
                    print("âœ… Method 2: JSON from code blocks successful")
                    return data
        except (json.JSONDecodeError, AttributeError) as e:
            print(f"Method 2 failed: {e}")
        
        # Method 3: Try to find and combine multiple JSON objects
        try:
            # Find all JSON objects in the text
            json_objects = []
            pattern = r'\{[^{}]*?(?:\{[^{}]*?}[^{}]*?)*\}'
            matches = re.finditer(pattern, text, re.DOTALL)
            
            for match in matches:
                try:
                    obj = json.loads(match.group())
                    if isinstance(obj, dict) and 'question_number' in obj:
                        json_objects.append(obj)
                except json.JSONDecodeError:
                    continue
            
            if json_objects:
                print(f"âœ… Method 3: Found {len(json_objects)} JSON objects")
                return json_objects
        except Exception as e:
            print(f"Method 3 failed: {e}")
        
        # Method 4: Try wrapping in array if multiple objects detected
        try:
            if 'question_number' in text and text.count('{') > 1:
                # Try to fix by wrapping individual objects in array
                fixed_text = '[' + re.sub(r'}\s*{', '},{', text) + ']'
                data = json.loads(fixed_text)
                if isinstance(data, list):
                    print("âœ… Method 4: Array wrapping successful")
                    return data
        except json.JSONDecodeError as e:
            print(f"Method 4 failed: {e}")
        
        print("âŒ All JSON parsing methods failed")
        return []
    
    def _enhanced_fallback_extraction(self, text: str, file_name: str) -> List[Dict]:
        """Enhanced fallback extraction when JSON parsing fails"""
        print("Using enhanced fallback extraction...")
        
        questions = []
        lines = text.split('\n')
        
        current_question = None
        current_option = None
        current_instructions = ""
        question_count = 0
        
        for i, line in enumerate(lines):
            line = line.strip()
            if not line:
                continue
            
            # Enhanced question number detection
            q_match = re.match(r'^(Q\.?\s*\d+|[Qq]uestion\s*\d+|\d+\.)\s*', line)
            if q_match:
                # Save previous question
                if current_question and current_question.get('question_text'):
                    questions.append(current_question)
                    question_count += 1
                
                # Start new question
                question_number = q_match.group(0).strip()
                question_text = line[len(q_match.group(0)):].strip()
                
                current_question = {
                    "question_type": "MCQ",  # Default
                    "question_number": question_number,
                    "question_text": question_text,
                    "option_a": "", "option_b": "", "option_c": "", "option_d": "",
                    "has_question_image": False,
                    "options_with_images": [],
                    "has_instruction_image": False,
                    "instructions": current_instructions.strip() if current_instructions else "",
                    "file_name": file_name
                }
                current_option = None
                continue
            
            # Enhanced option detection
            option_match = re.match(r'^([A-D])[\.\)]\s*(.+)', line, re.IGNORECASE)
            if option_match and current_question:
                option_letter = option_match.group(1).upper()
                option_text = option_match.group(2).strip()
                option_key = f"option_{option_letter.lower()}"
                
                current_question[option_key] = option_text
                current_option = option_key
                current_question["question_type"] = "MCQ"
                continue
            
            # Continue current option or question text
            if current_option and current_question:
                current_question[current_option] += " " + line
            elif current_question:
                # Check if this might be fill-in-blank pattern
                if any(word in line.lower() for word in ['blank', 'fill in', '______', 'missing']):
                    current_question["question_type"] = "FILL_IN_BLANK"
                else:
                    current_question["question_text"] += " " + line
        
        # Add the last question
        if current_question and current_question.get('question_text'):
            # Final type determination
            if not any(current_question[opt] for opt in ['option_a', 'option_b', 'option_c', 'option_d']):
                current_question["question_type"] = "FILL_IN_BLANK"
            questions.append(current_question)
            question_count += 1
        
        print(f"âœ… Enhanced fallback extracted {question_count} questions")
        return questions
    
    def process_image_batch(self, image_batch: List[Tuple[str, str]]) -> List[Dict]:
        """Process a batch of images concurrently"""
        results = []
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
            # Submit all tasks
            future_to_image = {
                executor.submit(self.extract_all_questions_from_image, url, name): (name, url) 
                for name, url in image_batch
            }
            
            # Collect results as they complete
            for future in concurrent.futures.as_completed(future_to_image):
                name, url = future_to_image[future]
                try:
                    questions = future.result()
                    results.extend(questions)
                    print(f"âœ… Completed batch item: {name}")
                except Exception as e:
                    error_result = [{"error": f"Batch processing failed: {str(e)}", "file_name": name}]
                    results.extend(error_result)
                    print(f"âŒ Failed batch item: {name}")
        
        return results
    
    def get_correct_answers_batch(self, questions: List[Dict]) -> List[Dict]:
        """Get correct answers for a batch of questions"""
        results = []
        
        # Process questions in smaller batches to avoid rate limits
        batch_size = 5
        for i in range(0, len(questions), batch_size):
            batch = questions[i:i + batch_size]
            print(f"ðŸ”„ Analyzing answer batch {i//batch_size + 1}/{(len(questions)-1)//batch_size + 1}")
            
            for question in batch:
                if "error" in question:
                    results.append(question)
                    continue
                
                answer_result = self._analyze_single_question(question)
                # Combine question data with answer
                combined = {**question, **answer_result}
                results.append(combined)
                
                # Smaller delay for batch processing
                time.sleep(1)
        
        return results
    
    def _analyze_single_question(self, question: Dict) -> Dict:
        """Analyze a single question for correct answer"""
        
        question_type = question.get("question_type", "MCQ")
        
        if question_type == "FILL_IN_BLANK":
            prompt = f"""This is a FILL-IN-THE-BLANK question:
            Question: {question.get('question_text', '')}
            
            Provide the CORRECT ANSWER to fill in the blank(s) and a brief explanation.
            
            Return ONLY JSON:
            {{
                "correct_answer": "the actual answer to fill in the blank",
                "explanation": "brief explanation why this is the correct answer"
            }}"""
        else:
            context_info = ""
            if question.get("has_question_image"):
                context_info = " [Note: Question contains diagram/image]"
            if question.get("options_with_images"):
                context_info += f" [Options with images: {', '.join(question['options_with_images'])}]"
            if question.get("instructions"):
                context_info += f" [Instructions: {question['instructions']}]"
            
            prompt = f"""This is a MULTIPLE CHOICE QUESTION (MCQ):
            Question: {question.get('question_text', '')}{context_info}
            Options:
            A: {question.get('option_a', '')}
            B: {question.get('option_b', '')} 
            C: {question.get('option_c', '')}
            D: {question.get('option_d', '')}

            Determine the CORRECT OPTION (A, B, C, or D) and provide brief explanation.
            
            Return ONLY JSON:
            {{
                "correct_answer": "A/B/C/D",
                "explanation": "brief explanation why this option is correct"
            }}"""
        
        payload = {
            "model": "gpt-4o",
            "messages": [{"role": "user", "content": prompt}],
            "max_tokens": 300,
            "temperature": 0.1
        }
        
        try:
            response = requests.post(self.base_url, headers=self.headers, json=payload, timeout=30)
            if response.status_code == 200:
                result = response.json()
                content = result['choices'][0]['message']['content'].strip()
                parsed_result = self._parse_json_response(content)
                
                # For fill-in-blank, ensure we have the actual answer, not an option letter
                if question_type == "FILL_IN_BLANK" and parsed_result.get("correct_answer") in ["A", "B", "C", "D"]:
                    return self._get_fill_in_blank_answer(question)
                
                return parsed_result
            else:
                return {"correct_answer": "Error", "explanation": f"API: {response.status_code}"}
        except Exception as e:
            return {"correct_answer": "Error", "explanation": f"Analysis failed: {str(e)}"}
    
    def _get_fill_in_blank_answer(self, question: Dict) -> Dict:
        """Specialized function to get fill-in-blank answer"""
        prompt = f"""This is specifically a FILL-IN-THE-BLANK question (NOT multiple choice).
        
        Question: {question.get('question_text', '')}
        
        What is the ACTUAL ANSWER that should fill in the blank(s)? 
        Provide the exact word, phrase, number, or expression.
        
        Return ONLY JSON:
        {{
            "correct_answer": "the actual fill-in answer",
            "explanation": "why this is the correct answer"
        }}"""
        
        payload = {
            "model": "gpt-4o",
            "messages": [{"role": "user", "content": prompt}],
            "max_tokens": 200,
            "temperature": 0.1
        }
        
        try:
            response = requests.post(self.base_url, headers=self.headers, json=payload, timeout=30)
            if response.status_code == 200:
                result = response.json()
                content = result['choices'][0]['message']['content'].strip()
                return self._parse_json_response(content)
            else:
                return {"correct_answer": "Error", "explanation": "Failed to get fill-in answer"}
        except Exception as e:
            return {"correct_answer": "Error", "explanation": f"Fill-in analysis failed: {str(e)}"}
    
    def _parse_json_response(self, text: str) -> Dict:
        """Parse single JSON response"""
        try:
            clean_text = re.sub(r'```json|```', '', text).strip()
            return json.loads(clean_text)
        except:
            return {"correct_answer": "", "explanation": text}

# The rest of the GoogleSheetProcessor class remains the same as previous version
# [Include the complete GoogleSheetProcessor class from the previous response here]

class GoogleSheetProcessor:
    def __init__(self, credentials_file: str, sheet_id: str, api_key: str, sheet_tab: str = "Sheet4"):
        self.sheet_id = sheet_id
        self.sheet_tab = sheet_tab
        self.extractor = MultiQuestionExtractor(api_key)
        self.service = self._authenticate_google_sheets(credentials_file)
    
    def _authenticate_google_sheets(self, credentials_file: str):
        """Authenticate with Google Sheets API"""
        try:
            SCOPES = ['https://www.googleapis.com/auth/spreadsheets']
            creds = service_account.Credentials.from_service_account_file(
                credentials_file, scopes=SCOPES)
            
            return build('sheets', 'v4', credentials=creds)
        except Exception as e:
            print(f"Google Sheets authentication failed: {e}")
            raise
    
    def read_sheet_data(self, sheet_range: str = None) -> List[List]:
        """Read image URLs and file names from Google Sheets"""
        if sheet_range is None:
            sheet_range = f"{self.sheet_tab}!A:B"
            
        try:
            sheet = self.service.spreadsheets()
            result = sheet.values().get(
                spreadsheetId=self.sheet_id,
                range=sheet_range
            ).execute()
            
            values = result.get('values', [])
            print(f"Read {len(values)} rows from sheet")
            return values
        except Exception as e:
            print(f"Error reading sheet data: {e}")
            return []
    
    def update_sheet(self, updates: List[List], range: str):
        """Update Google Sheets with results"""
        try:
            body = {'values': updates}
            sheet = self.service.spreadsheets()
            result = sheet.values().update(
                spreadsheetId=self.sheet_id,
                range=range,
                valueInputOption='RAW',
                body=body
            ).execute()
            
            print(f"Updated {len(updates)} rows in range {range}")
            return result
        except Exception as e:
            print(f"Error updating sheet: {e}")
            raise
    
    def clear_previous_data(self, range: str):
        """Clear previous data from specified range"""
        try:
            sheet = self.service.spreadsheets()
            result = sheet.values().clear(
                spreadsheetId=self.sheet_id,
                range=range
            ).execute()
            print(f"Cleared previous data from {range}")
            return result
        except Exception as e:
            print(f"Error clearing data: {e}")
    
    def process_all_images(self, batch_size: int = 3):
        """Process all images in batches and extract multiple questions from each"""
        data = self.read_sheet_data(f"{self.sheet_tab}!A:B")
        
        if not data or len(data) < 2:
            print("No data found or insufficient columns")
            return
        
        all_questions = []
        total_images = 0
        
        # Clear previous results (columns C through Q)
        self.clear_previous_data(f"{self.sheet_tab}!C:Q")
        
        # Prepare image batches
        image_batches = []
        current_batch = []
        
        for i, row in enumerate(data[1:], start=2):
            while len(row) < 2:
                row.append("")
            
            file_name = row[0] if len(row) > 0 else f"Image_{i}"
            image_url = row[1]
            
            if not image_url or not image_url.startswith('http'):
                print(f"Skipping row {i}: No valid URL")
                continue
            
            current_batch.append((file_name, image_url))
            
            # When batch is full, process it
            if len(current_batch) >= batch_size:
                image_batches.append(current_batch)
                current_batch = []
        
        # Add remaining images as last batch
        if current_batch:
            image_batches.append(current_batch)
        
        print(f"\nðŸ“¦ Processing {len(image_batches)} batches with {batch_size} images each")
        
        # Process each batch
        for batch_num, image_batch in enumerate(image_batches, 1):
            print(f"\n{'='*70}")
            print(f"ðŸ”„ PROCESSING BATCH {batch_num}/{len(image_batches)}")
            print(f"{'='*70}")
            
            # Process batch concurrently
            batch_questions = self.extractor.process_image_batch(image_batch)
            
            # Filter out errors and get correct answers
            valid_questions = [q for q in batch_questions if "error" not in q]
            if valid_questions:
                print(f"ðŸ”„ Getting correct answers for {len(valid_questions)} questions...")
                complete_questions = self.extractor.get_correct_answers_batch(valid_questions)
                all_questions.extend(complete_questions)
                total_images += len(image_batch)
            
            # Add error questions as well
            error_questions = [q for q in batch_questions if "error" in q]
            all_questions.extend(error_questions)
            
            print(f"âœ… Batch {batch_num} completed: {len(valid_questions)} questions extracted")
            
            # Rate limiting between batches
            if batch_num < len(image_batches):
                print("â³ Waiting before next batch...")
                time.sleep(5)
        
        # Prepare updates for Google Sheets
        updates = []
        for question in all_questions:
            if "error" in question:
                updates.append([
                    question.get("file_name", ""),         # Column C: File Name
                    question.get("source_row", ""),        # Column D: Source Row
                    f"Error: {question['error']}",         # Column E: Error
                    "", "", "", "", "", "", "", "", "", "", "" # Empty columns for consistency
                ])
            else:
                # Format image information
                has_question_image = "Yes" if question.get("has_question_image") else "No"
                options_with_images = ", ".join(question.get("options_with_images", [])) or "None"
                has_instruction_image = "Yes" if question.get("has_instruction_image") else "No"
                instructions = question.get("instructions", "") or ""
                question_type = question.get("question_type", "UNKNOWN")
                
                updates.append([
                    question.get("file_name", ""),         # Column C: File Name
                    question.get("source_row", ""),        # Column D: Source Row  
                    question_type,                         # Column E: Question Type
                    question.get("question_number", ""),   # Column F: Question Number
                    question.get("question_text", ""),     # Column G: Question Text
                    question.get("option_a", ""),          # Column H: Option A
                    question.get("option_b", ""),          # Column I: Option B
                    question.get("option_c", ""),          # Column J: Option C
                    question.get("option_d", ""),          # Column K: Option D
                    has_question_image,                    # Column L: Question Has Image
                    options_with_images,                   # Column M: Options With Images
                    has_instruction_image,                 # Column N: Instructions Have Image
                    instructions,                          # Column O: Instructions
                    question.get("correct_answer", ""),    # Column P: Correct Answer
                    question.get("explanation", "")        # Column Q: Explanation
                ])
        
        # Write all questions to sheet
        if updates:
            # Write header row
            header = [
                "File Name", "Source Row", "Question Type", "Q Number", "Question Text", 
                "Option A", "Option B", "Option C", "Option D", 
                "Question Has Image", "Options With Images", 
                "Instructions Have Image", "Instructions",
                "Correct Answer", "Explanation"
            ]
            updates.insert(0, header)
            
            update_range = f"{self.sheet_tab}!C2:Q{len(updates)+1}"
            self.update_sheet(updates, update_range)
            
            print(f"\nðŸŽ‰ PROCESSING COMPLETED!")
            print(f"ðŸ“Š Total Images Processed: {total_images}")
            print(f"ðŸ“ Total Questions Extracted: {len([q for q in all_questions if 'error' not in q])}")
            
            # Count question types
            mcq_count = len([q for q in all_questions if q.get("question_type") == "MCQ" and "error" not in q])
            fill_count = len([q for q in all_questions if q.get("question_type") == "FILL_IN_BLANK" and "error" not in q])
            
            print(f"ðŸ“‹ Question Types: {mcq_count} MCQ, {fill_count} Fill-in-Blank")
            print(f"ðŸ’¾ Results saved to columns C-Q")
        else:
            print("âŒ No questions were extracted")

def main():
    # Configuration
    OPENAI_API_KEY = "your_openai_api_key_here"
    
    if not OPENAI_API_KEY or OPENAI_API_KEY == "your_openai_api_key_here":
        print("âŒ Please set your OpenAI API key")
        return
    
    SHEET_TAB = "Sheet4"
    GOOGLE_SHEET_ID = "1U6gW0yqh3GZlkyxvhF_5k3sXMP8GwZT-TNsXqKv7S1o"
    CREDENTIALS_FILE = "service-account.json"
    
    # ðŸŽ¯ CONFIGURATION: Change batch size here
    BATCH_SIZE = 3  # Process 3 images at a time
    
    try:
        print("\n" + "="*80)
        print("IMPROVED MULTI-QUESTION EXTRACTION WITH ROBUST JSON PARSING")
        print(f"Batch Size: {BATCH_SIZE} images per batch")
        print("Features:")
        print("âœ“ Enhanced JSON parsing with multiple fallback methods")
        print("âœ“ Improved question type detection (MCQ/Fill-in-Blank)")
        print("âœ“ Better error handling and fallback extraction")
        print("="*80)
        
        processor = GoogleSheetProcessor(CREDENTIALS_FILE, GOOGLE_SHEET_ID, OPENAI_API_KEY, SHEET_TAB)
        processor.process_all_images(batch_size=BATCH_SIZE)
    except Exception as e:
        print(f"âŒ Processing failed: {e}")

if __name__ == "__main__":
    main()
