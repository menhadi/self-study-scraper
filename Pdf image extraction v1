import os
import fitz  # PyMuPDF
import pandas as pd
from pathlib import Path
import base64
import requests
import json
import csv
import re
import time

class ContextAwareImageExtractor:
    def __init__(self, api_key):
        self.api_key = api_key
        self.base_url = "https://api.deepseek.com/v1/chat/completions"
        self.image_counter = 0
    
    def call_deepseek_api(self, prompt, max_tokens=2000):
        """Call DeepSeek API for text analysis"""
        if not self.api_key:
            return None
            
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        
        payload = {
            "model": "deepseek-chat",
            "messages": [{"role": "user", "content": prompt}],
            "max_tokens": max_tokens,
            "temperature": 0.1
        }
        
        try:
            response = requests.post(self.base_url, headers=headers, json=payload, timeout=60)
            if response.status_code == 200:
                return response.json()["choices"][0]["message"]["content"]
            else:
                print(f"      API Error {response.status_code}")
                return None
        except Exception as e:
            print(f"      API call failed: {e}")
            return None
    
    def analyze_page_context(self, page_text, page_num):
        """Use AI to analyze page content and identify questions/options/solutions"""
        prompt = f"""Analyze this exam paper page content and identify all questions, options, and solutions. Return ONLY valid JSON:

PAGE CONTENT:
{page_text[:8000]}  # Limit text length

IMPORTANT: Return ONLY this JSON format:
{{
    "page_analysis": [
        {{
            "question_number": "1",
            "context_type": "question/option_a/option_b/option_c/option_d/solution/explanation",
            "content_preview": "brief content preview",
            "confidence": "high/medium/low"
        }}
    ]
}}

Rules:
1. Identify question numbers (1, 2, 3, etc.)
2. For options, use: option_a, option_b, option_c, option_d
3. For solutions/answers, use: solution
4. For explanations, use: explanation
5. Include confidence level
6. Return empty array if no questions found"""

        response = self.call_deepseek_api(prompt)
        
        if response:
            try:
                # Extract JSON from response
                json_match = re.search(r'\{.*\}', response, re.DOTALL)
                if json_match:
                    return json.loads(json_match.group())
                else:
                    return {"page_analysis": []}
            except Exception as e:
                print(f"      JSON parsing error: {e}")
        
        return {"page_analysis": []}
    
    def extract_images_with_context(self, pdf_path, output_dir, pdf_name):
        """Extract images and assign contextual names"""
        images_data = []
        
        try:
            doc = fitz.open(pdf_path)
            print(f"üìÑ Context-Aware Extraction: {pdf_name}")
            print(f"üìñ Total pages: {len(doc)}")
            
            for page_num in range(len(doc)):
                page = doc.load_page(page_num)
                print(f"    üîç Page {page_num+1}: Extracting with context...")
                
                # Step 1: Extract page text for context analysis
                page_text = page.get_text()
                
                # Step 2: Analyze page context with AI
                context_analysis = self.analyze_page_context(page_text, page_num)
                contexts = context_analysis.get("page_analysis", [])
                print(f"      AI identified {len(contexts)} context areas")
                
                # Step 3: Extract images
                image_list = page.get_images()
                print(f"      Found {len(image_list)} embedded images")
                
                for img_index, img in enumerate(image_list):
                    xref = img[0]
                    
                    try:
                        base_image = doc.extract_image(xref)
                        
                        if base_image and base_image.get("image"):
                            self.image_counter += 1
                            
                            width = base_image.get("width", 0)
                            height = base_image.get("height", 0)
                            image_data = base_image["image"]
                            size_kb = len(image_data) / 1024
                            
                            # Step 4: Determine image context
                            image_bbox = self._get_image_bbox(page, xref)
                            image_context = self._determine_image_context(image_bbox, contexts, page_text)
                            
                            # Step 5: Create contextual filename
                            img_ext = base_image.get("ext", "png")
                            contextual_filename = self._create_contextual_filename(
                                pdf_name, page_num + 1, self.image_counter, 
                                image_context, img_ext
                            )
                            img_path = output_dir / contextual_filename
                            
                            # Save image
                            with open(img_path, "wb") as img_file:
                                img_file.write(image_data)
                            
                            if self._is_substantial_image(width, height, size_kb):
                                image_info = {
                                    'pdf_name': pdf_name,
                                    'page_number': page_num + 1,
                                    'image_number': self.image_counter,
                                    'filename': contextual_filename,
                                    'filepath': str(img_path),
                                    'width': width,
                                    'height': height,
                                    'size_kb': round(size_kb, 2),
                                    'question_number': image_context.get('question_number', ''),
                                    'context_type': image_context.get('context_type', 'unknown'),
                                    'confidence': image_context.get('confidence', 'low'),
                                    'type': 'embedded_image',
                                    'image_format': base_image.get("ext", "unknown"),
                                    'xref': xref
                                }
                                images_data.append(image_info)
                                print(f"      ‚úÖ {contextual_filename}")
                                print(f"        Context: Q{image_context.get('question_number', '?')} {image_context.get('context_type', 'unknown')}")
                            else:
                                os.remove(img_path)
                        
                    except Exception as e:
                        print(f"      ‚ö†Ô∏è Image {img_index} error: {e}")
                
                # Add delay to avoid rate limiting
                time.sleep(1)
            
            doc.close()
            
        except Exception as e:
            print(f"‚ùå Error: {e}")
            import traceback
            traceback.print_exc()
        
        return images_data
    
    def _get_image_bbox(self, page, xref):
        """Get approximate bounding box of image on page"""
        # This is a simplified approach - images don't have direct bbox in PyMuPDF
        # We'll use a fallback: assume images are near text with similar characteristics
        return fitz.Rect(0, 0, 100, 100)  # Default small bbox
    
    def _determine_image_context(self, image_bbox, contexts, page_text):
        """Determine which question/option the image belongs to"""
        if not contexts:
            return {"question_number": "unknown", "context_type": "unknown", "confidence": "low"}
        
        # Simple heuristic: use the first high-confidence context
        high_confidence = [ctx for ctx in contexts if ctx.get('confidence') == 'high']
        if high_confidence:
            return high_confidence[0]
        
        # Fallback to first context
        return contexts[0] if contexts else {"question_number": "unknown", "context_type": "unknown", "confidence": "low"}
    
    def _create_contextual_filename(self, pdf_name, page_num, img_num, context, extension):
        """Create filename with question context"""
        question_num = context.get('question_number', 'unknown')
        context_type = context.get('context_type', 'unknown')
        
        # Clean and format the context type
        if context_type.startswith('option_'):
            # option_a -> A, option_b -> B, etc.
            option_letter = context_type.replace('option_', '').upper()
            context_str = f"q{question_num}_{option_letter}"
        elif context_type == 'solution':
            context_str = f"q{question_num}_solution"
        elif context_type == 'explanation':
            context_str = f"q{question_num}_explanation"
        elif context_type == 'question':
            context_str = f"q{question_num}_question"
        else:
            context_str = f"q{question_num}_{context_type}"
        
        return f"{pdf_name}_p{page_num}_{context_str}_img{img_num:03d}.{extension}"
    
    def _is_substantial_image(self, width, height, size_kb, 
                            min_width=100, min_height=100, min_size_kb=5):
        """Check if image is substantial"""
        return (width >= min_width and 
                height >= min_height and 
                size_kb >= min_size_kb)
    
    def create_images_csv(self, images_data, output_path):
        """Create CSV with contextual image information"""
        if not images_data:
            print("No images to save")
            return
        
        headers = [
            'PDF Name', 'Page Number', 'Image Number', 'Filename',
            'Question Number', 'Context Type', 'Confidence',
            'Width', 'Height', 'Size (KB)', 'Image Format', 'Filepath'
        ]
        
        with open(output_path, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow(headers)
            
            for image in images_data:
                row = [
                    image.get('pdf_name', ''),
                    image.get('page_number', ''),
                    image.get('image_number', ''),
                    image.get('filename', ''),
                    image.get('question_number', ''),
                    image.get('context_type', ''),
                    image.get('confidence', ''),
                    image.get('width', ''),
                    image.get('height', ''),
                    round(image.get('size_kb', 0), 2),
                    image.get('image_format', ''),
                    image.get('filepath', '')
                ]
                writer.writerow(row)
        
        print(f"‚úÖ Contextual Images CSV: {output_path}")
    
    def process_pdf(self, pdf_path, output_dir):
        """Process a single PDF"""
        pdf_name = Path(pdf_path).stem
        images_dir = output_dir / "contextual_images"
        images_dir.mkdir(exist_ok=True)
        
        print(f"\n{'='*60}")
        print(f"üîÑ Context-Aware Processing: {pdf_name}")
        print(f"{'='*60}")
        
        # Reset counter
        self.image_counter = 0
        
        images = self.extract_images_with_context(pdf_path, images_dir, pdf_name)
        
        if images:
            csv_path = output_dir / f"{pdf_name}_contextual_images.csv"
            self.create_images_csv(images, csv_path)
            
            print(f"\nüìä Contextual Results:")
            print(f"   ‚úÖ Images with context: {len(images)}")
            
            # Show context breakdown
            contexts = {}
            for image in images:
                ctx = f"Q{image.get('question_number', '?')}_{image.get('context_type', '?')}"
                contexts[ctx] = contexts.get(ctx, 0) + 1
            
            for ctx, count in contexts.items():
                print(f"     ‚Ä¢ {ctx}: {count}")
            
            print(f"   üìÅ Folder: {images_dir}")
        else:
            print(f"   ‚ùå No contextual images found")
        
        return images

# FALLBACK: Simple extractor without API
class SimpleContextImageExtractor:
    def __init__(self):
        self.image_counter = 0
    
    def extract_with_simple_context(self, pdf_path, output_dir, pdf_name):
        """Simple extraction without AI - uses basic pattern matching"""
        images_data = []
        
        try:
            doc = fitz.open(pdf_path)
            print(f"üìÑ Simple Context Extraction: {pdf_name}")
            
            for page_num in range(len(doc)):
                page = doc.load_page(page_num)
                print(f"    üîç Page {page_num+1}: Simple context analysis...")
                
                # Extract text and find question patterns
                page_text = page.get_text()
                questions = self._find_questions_simple(page_text)
                
                image_list = page.get_images()
                print(f"      Found {len(image_list)} images, {len(questions)} question patterns")
                
                for img_index, img in enumerate(image_list):
                    xref = img[0]
                    
                    try:
                        base_image = doc.extract_image(xref)
                        if base_image and base_image.get("image"):
                            self.image_counter += 1
                            
                            width = base_image.get("width", 0)
                            height = base_image.get("height", 0)
                            image_data = base_image["image"]
                            size_kb = len(image_data) / 1024
                            
                            # Simple context assignment
                            context = self._assign_simple_context(questions, img_index)
                            
                            img_ext = base_image.get("ext", "png")
                            filename = self._create_simple_filename(
                                pdf_name, page_num + 1, self.image_counter, context, img_ext
                            )
                            img_path = output_dir / filename
                            
                            with open(img_path, "wb") as img_file:
                                img_file.write(image_data)
                            
                            if self._is_substantial_image(width, height, size_kb):
                                images_data.append({
                                    'pdf_name': pdf_name,
                                    'page_number': page_num + 1,
                                    'image_number': self.image_counter,
                                    'filename': filename,
                                    'filepath': str(img_path),
                                    'width': width,
                                    'height': height,
                                    'size_kb': round(size_kb, 2),
                                    'question_number': context['question'],
                                    'context_type': context['type'],
                                    'confidence': 'low',
                                    'type': 'embedded_image'
                                })
                                print(f"      ‚úÖ {filename}")
                    
                    except Exception as e:
                        print(f"      Image error: {e}")
            
            doc.close()
            
        except Exception as e:
            print(f"‚ùå Error: {e}")
        
        return images_data
    
    def _find_questions_simple(self, text):
        """Simple question pattern matching"""
        questions = []
        # Look for patterns like "1.", "Q1", "Question 1", etc.
        patterns = [
            r'(\d+)\.\s',  # "1. "
            r'[Qq]\.?\s*(\d+)',  # "Q1", "Q.1"
            r'Question\s*(\d+)',  # "Question 1"
        ]
        
        for pattern in patterns:
            matches = re.finditer(pattern, text)
            for match in matches:
                questions.append({
                    'question_number': match.group(1),
                    'position': match.start()
                })
        
        return questions
    
    def _assign_simple_context(self, questions, img_index):
        """Simple context assignment based on image order"""
        if questions and img_index < len(questions):
            q = questions[img_index]
            return {'question': q['question_number'], 'type': 'question'}
        else:
            return {'question': str(img_index + 1), 'type': 'unknown'}
    
    def _create_simple_filename(self, pdf_name, page_num, img_num, context, extension):
        """Create simple contextual filename"""
        return f"{pdf_name}_p{page_num}_q{context['question']}_{context['type']}_img{img_num:03d}.{extension}"
    
    def _is_substantial_image(self, width, height, size_kb, 
                            min_width=100, min_height=100, min_size_kb=5):
        return (width >= min_width and height >= min_height and size_kb >= min_size_kb)

# USAGE
if __name__ == "__main__":
    API_KEY = "sk-a74954e77779423297e2abbc4ef0b7cd"  # Your DeepSeek API key
    
    print("üöÄ Choose Context-Aware Extraction:")
    print("1. AI-Powered (with DeepSeek API) - Better context")
    print("2. Simple Pattern-Based - No API required")
    
    choice = input("Enter choice (1 or 2): ").strip()
    
    folder_path = r"C:\Users\menha\Downloads\test"
    output_dir = Path(folder_path) / "contextual_image_extraction"
    output_dir.mkdir(exist_ok=True)
    
    pdf_files = list(Path(folder_path).glob("*.pdf"))
    
    if not pdf_files:
        print("No PDF files found!")
        exit()
    
    if choice == "1":
        extractor = ContextAwareImageExtractor(api_key=API_KEY)
        print("\n" + "="*60)
        print("ü§ñ AI-POWERED CONTEXT EXTRACTION")
        print("Using DeepSeek API for intelligent context analysis")
        print("="*60)
    else:
        extractor = SimpleContextImageExtractor()
        print("\n" + "="*60)
        print("üîç SIMPLE CONTEXT EXTRACTION")
        print("Using pattern matching for basic context")
        print("="*60)
    
    all_images = []
    
    for pdf_file in pdf_files:
        if choice == "1":
            images = extractor.process_pdf(pdf_file, output_dir)
        else:
            images = extractor.extract_with_simple_context(pdf_file, output_dir, pdf_file.stem)
        
        all_images.extend(images)
        print()
    
    if all_images:
        print("üéâ CONTEXTUAL EXTRACTION COMPLETED!")
        print(f"üìä Total contextual images: {len(all_images)}")
        print(f"üìÅ Output: {output_dir}")
        
        # Show filename examples
        print(f"üìù Sample filenames:")
        for img in all_images[:3]:  # Show first 3
            print(f"   ‚Ä¢ {img['filename']}")
    else:
        print("‚ùå No images found with context")
