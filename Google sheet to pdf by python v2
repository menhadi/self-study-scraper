import gspread
from google.oauth2.service_account import Credentials
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, PageBreak, Table, TableStyle, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.lib import colors
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from googleapiclient.discovery import build
import os
import logging
import pandas as pd
import re
import requests
from io import BytesIO
import urllib.parse

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# Google Sheets and Drive setup
SCOPE = [
    "https://www.googleapis.com/auth/spreadsheets",
    "https://www.googleapis.com/auth/drive"
]

# Column names in Google Sheets
COLUMN_FOLDER = 'Folder'
COLUMN_SUB_FOLDER = 'Sub Folder'
COLUMN_FILE_NAME = 'File Name'
COLUMN_QUESTION_NO = 'Question No'
COLUMN_QUESTION_TEXT = 'Question Text'
COLUMN_INSTRUCTIONS = 'Instructions'
COLUMN_OPTION_A = 'Option A'
COLUMN_OPTION_B = 'Option B'
COLUMN_OPTION_C = 'Option C'
COLUMN_OPTION_D = 'Option D'
COLUMN_QUESTION_IMAGE_URL = 'Question Image URL'
COLUMN_OPTION_A_IMAGE_URL = 'Option A Image URL'
COLUMN_OPTION_B_IMAGE_URL = 'Option B Image URL'
COLUMN_OPTION_C_IMAGE_URL = 'Option C Image URL'
COLUMN_OPTION_D_IMAGE_URL = 'Option D Image URL'
COLUMN_CORRECT_OPTION = 'Correct Option'
COLUMN_EXPLANATION = 'Explanation'
COLUMN_CONTENT = 'Content'
COLUMN_PDF_URLS = 'PDF urls'

# -----------------------------------------------------------
# ✅ UNICODE FONT PATH (YOUR EXACT LOCATION)
# -----------------------------------------------------------
FONT_DIR = r"C:\Users\menha\Downloads\dejavu-fonts-ttf-2.37\dejavu-fonts-ttf-2.37\ttf"
UNICODE_FONT = "DejaVuSans"
UNICODE_FONT_BOLD = "DejaVuSans-Bold"

pdfmetrics.registerFont(TTFont(UNICODE_FONT, os.path.join(FONT_DIR, "DejaVuSans.ttf")))
pdfmetrics.registerFont(TTFont(UNICODE_FONT_BOLD, os.path.join(FONT_DIR, "DejaVuSans-Bold.ttf")))

logging.info("✅ DejaVu Unicode fonts loaded successfully.")

class PDFGenerator:
    def __init__(self, credentials_file):
        self.credentials_file = credentials_file
        self.sheets_client = None
        self.drive_service = None
        self.setup_clients()
        
    def setup_clients(self):
        """Initialize Google Sheets and Drive clients"""
        try:
            creds = Credentials.from_service_account_file(self.credentials_file, scopes=SCOPE)
            self.sheets_client = gspread.authorize(creds)
            self.drive_service = build('drive', 'v3', credentials=creds)
            logging.info("Google Sheets and Drive clients initialized")
        except Exception as e:
            logging.error(f"Failed to initialize clients: {e}")
            raise

    def clean_name(self, name, default="Default"):
        """Clean folder/file names to be filesystem-safe"""
        if not name:
            return default
        name = str(name)
        name = re.sub(r'https?://', '', name)
        name = re.sub(r'[<>:"/\\|?*]', "_", name)
        return name.strip().rstrip(".")

    def load_data_from_sheets(self, spreadsheet_id, worksheet_name):
        """Load data from Google Sheets"""
        try:
            spreadsheet = self.sheets_client.open_by_key(spreadsheet_id)
            worksheet = spreadsheet.worksheet(worksheet_name)
            data = worksheet.get_all_records()
            logging.info(f"Loaded {len(data)} rows from Google Sheets")
            return data
        except Exception as e:
            logging.error(f"Failed to load data from Google Sheets: {e}")
            raise

    def create_folder_structure(self, base_path, folder, sub_folder):
        """Create folder structure for PDFs"""
        safe_folder = self.clean_name(folder, "Folder")
        safe_sub_folder = self.clean_name(sub_folder, "SubFolder")
        path = os.path.join(base_path, safe_folder, safe_sub_folder)
        os.makedirs(path, exist_ok=True)
        return path

    def extract_urls_from_text(self, text):
        """Extract ALL URLs from text, including those in separate square brackets [url1] [url2]"""
        if not text:
            return []
        
        text = str(text).strip()
        urls = []
        
        # Pattern to match URLs in separate square brackets: [url1] [url2] [url3]
        bracket_pattern = r'\[(https?://[^\]]+)\]'
        bracket_urls = re.findall(bracket_pattern, text)
        urls.extend(bracket_urls)
        
        # Also look for standalone URLs outside brackets
        url_pattern = r'https?://[^\s<>"]+|www\.[^\s<>"]+'
        standalone_urls = re.findall(url_pattern, text)
        for url in standalone_urls:
            if not url.startswith('http'):
                url = 'https://' + url
            # Only add if not already in bracket_urls (avoid duplicates)
            if url not in urls:
                urls.append(url)
        
        return urls

    def clean_text(self, text):
        """Clean text by removing HTML tags AND URLs (including those in separate square brackets)"""
        if not text:
            return text
        
        text = str(text)
        
        # Remove HTML tags
        text = re.sub(r'<[^>]+>', '', text)
        
        # Remove URLs in separate square brackets [url1] [url2]
        text = re.sub(r'\[https?://[^\]]+\]', '', text)
        
        # Remove standalone URLs
        text = re.sub(r'https?://[^\s<>"]+|www\.[^\s<>"]+', '', text)
        
        # Clean up extra spaces that might be left after removal
        text = re.sub(r'\s+', ' ', text)
        
        return text.strip()

    # ✅ IMPROVED IMAGE PARSING WITH MULTIPLE URL SUPPORT
    def fetch_images_from_urls(self, urls, max_width=1.6 * inch):
        """Fetch multiple images from URLs and return list of Image objects"""
        images = []
        for url in urls:
            try:
                if not url:
                    continue

                url = str(url).strip()
                if not url.lower().startswith("http"):
                    continue

                resp = requests.get(url, timeout=15)
                if resp.status_code != 200:
                    continue

                img_data = BytesIO(resp.content)
                img = Image(img_data)

                # Scale image proportionally to fit within max_width
                if img.drawWidth > max_width:
                    scale = max_width / img.drawWidth
                    img.drawWidth = max_width
                    img.drawHeight *= scale

                # Maintain aspect ratio for very tall images
                max_height = 2.0 * inch
                if img.drawHeight > max_height:
                    scale = max_height / img.drawHeight
                    img.drawHeight = max_height
                    img.drawWidth *= scale

                # ✅ ZERO PADDING AND PROPER ALIGNMENT
                img.hAlign = 'LEFT'
                images.append(img)
                
            except Exception as e:
                logging.debug(f"Failed to fetch image from {url}: {e}")
                continue
        
        return images

    def add_header_footer(self, canvas, doc, paper_name=None):
        """Add header and footer to all pages - 80% width (no margins)"""
        canvas.saveState()
        
        # Calculate 80% width
        page_width = doc.pagesize[0]
        header_footer_width = page_width * 0.8
        start_x = (page_width - header_footer_width) / 2
        
        # Header line - 80% width centered
        canvas.setStrokeColor(colors.black)
        canvas.setLineWidth(0.5)
        canvas.line(start_x, doc.pagesize[1] - 40, start_x + header_footer_width, doc.pagesize[1] - 40)
        
        # Add paper name in header on right side
        if paper_name:
            canvas.setFont(UNICODE_FONT, 10)
            canvas.setFillColor(colors.black)
            canvas.drawRightString(page_width - 36, doc.pagesize[1] - 30, paper_name)
        
        # Footer line - 80% width centered
        canvas.setStrokeColor(colors.black)
        canvas.setLineWidth(0.5)
        canvas.line(start_x, 40, start_x + header_footer_width, 40)
        
        # Page number only (centered at bottom)
        canvas.setFont(UNICODE_FONT, 10)
        canvas.setFillColor(colors.black)
        canvas.drawCentredString(doc.pagesize[0] / 2, 25, str(canvas.getPageNumber()))
        
        canvas.restoreState()

    def should_use_single_column(self, option_a, option_b, option_c, option_d, doc_width):
        """Check if options should be displayed in single column to avoid overlap"""
        # Estimate text width - if any option is longer than 40% of available width, use single column
        max_option_length = max(len(str(option_a)), len(str(option_b)), len(str(option_c)), len(str(option_d)))
        available_width_per_option = (doc_width / 2) - 20  # Account for padding
        
        # If any option is longer than 40% of available space, use single column
        estimated_char_width = 6  # Approximate width per character in points
        estimated_text_width = max_option_length * estimated_char_width
        
        return estimated_text_width > (available_width_per_option * 0.4)

    def create_complete_pdf(self, questions, output_path, paper_name):
        """Create complete PDF with questions, options, answers and explanations"""
        try:
            doc = SimpleDocTemplate(
                output_path,
                pagesize=letter,
                rightMargin=72,
                leftMargin=72,
                topMargin=72,
                bottomMargin=72
            )
            
            styles = getSampleStyleSheet()
            
            # Custom styles with Unicode fonts
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontName=UNICODE_FONT_BOLD,
                fontSize=16,
                spaceAfter=20,
                alignment=1,
                textColor=colors.black
            )
            
            question_number_style = ParagraphStyle(
                'QuestionNumberStyle',
                parent=styles['Normal'],
                fontName=UNICODE_FONT_BOLD,
                fontSize=12,
                spaceAfter=0,
                leading=14,
                textColor=colors.black,
                leftIndent=0
            )
            
            question_text_style = ParagraphStyle(
                'QuestionTextStyle',
                parent=styles['Normal'],
                fontName=UNICODE_FONT_BOLD,
                fontSize=12,
                leftIndent=0,
                spaceAfter=12,
                leading=14,
                textColor=colors.black
            )
            
            instruction_label_style = ParagraphStyle(
                'InstructionLabelStyle',
                parent=styles['Normal'],
                fontName=UNICODE_FONT_BOLD,
                fontSize=12,
                leftIndent=0,
                spaceAfter=0,
                leading=14,
                textColor=colors.black
            )
            
            instruction_text_style = ParagraphStyle(
                'InstructionTextStyle',
                parent=styles['Normal'],
                fontName=UNICODE_FONT,
                fontSize=12,
                leftIndent=0,
                spaceAfter=8,
                leading=14,
                textColor=colors.black
            )
            
            option_style = ParagraphStyle(
                'OptionStyle',
                parent=styles['Normal'],
                fontName=UNICODE_FONT,
                fontSize=12,
                leftIndent=0,  # ✅ ZERO INDENT FOR BETTER ALIGNMENT
                spaceAfter=3,
                leading=14,
                textColor=colors.black
            )
            
            correct_answer_style = ParagraphStyle(
                'CorrectAnswerStyle',
                parent=styles['Normal'],
                fontName=UNICODE_FONT_BOLD,
                fontSize=12,
                textColor=colors.black,
                spaceAfter=8,
                leading=14,
                leftIndent=0
            )
            
            explanation_label_style = ParagraphStyle(
                'ExplanationLabelStyle',
                parent=styles['Normal'],
                fontName=UNICODE_FONT_BOLD,
                fontSize=12,
                textColor=colors.black,
                spaceAfter=0,
                leading=14,
                leftIndent=0
            )
            
            explanation_text_style = ParagraphStyle(
                'ExplanationTextStyle',
                parent=styles['Normal'],
                fontName=UNICODE_FONT,
                fontSize=12,
                textColor=colors.black,
                spaceAfter=15,
                leading=14,
                leftIndent=0
            )
            
            story = []
            
            # Add title
            title = Paragraph(f"{paper_name}", title_style)
            story.append(title)
            story.append(Spacer(1, 30))
            
            for i, question in enumerate(questions, 1):
                # ✅ USE ACTUAL QUESTION NUMBER FROM SHEET OR SEQUENTIAL
                actual_question_no = question.get('question_no', i)
                if not actual_question_no or str(actual_question_no).strip() == '':
                    actual_question_no = i
                
                # Clean text (remove HTML tags AND URLs)
                question_text = self.clean_text(question['question_text'])
                
                # ✅ ADD INSTRUCTIONS BEFORE QUESTION TEXT (IF PRESENT)
                if question.get('instructions'):
                    instr_text = self.clean_text(question['instructions'])
                    if instr_text and instr_text.strip():
                        # Create instruction with "Instruction:" in bold and text in normal
                        instruction_label = Paragraph("<b>Instruction:</b>", instruction_label_style)
                        instruction_content = Paragraph(f"{instr_text}", instruction_text_style)
                        
                        # Add instruction to story
                        story.append(instruction_label)
                        story.append(instruction_content)
                        story.append(Spacer(1, 8))
                
                # Question number and text
                q_number = Paragraph(f"Q.{actual_question_no}", question_number_style)
                q_text = Paragraph(f"{question_text}", question_text_style)
                
                # Create table to keep number and text on same line with proper spacing
                question_table = Table([[q_number, q_text]], colWidths=[35, doc.width - 35])
                question_table.setStyle(TableStyle([
                    ('VALIGN', (0, 0), (-1, 0), 'TOP'),
                    ('LEFTPADDING', (0, 0), (-1, 0), 0),
                    ('RIGHTPADDING', (0, 0), (-1, 0), 0),
                    ('BOTTOMPADDING', (0, 0), (-1, 0), 0),
                ]))
                
                story.append(question_table)
                story.append(Spacer(1, 8))
                
                # ✅ IMPROVED QUESTION IMAGE HANDLING WITH MULTIPLE URL SUPPORT
                question_image_urls = []
                
                # Get URLs from dedicated image URL column
                if question.get('question_image_url'):
                    dedicated_urls = self.extract_urls_from_text(question['question_image_url'])
                    question_image_urls.extend(dedicated_urls)
                
                # Also extract URLs from question text itself
                text_urls = self.extract_urls_from_text(question['question_text'])
                question_image_urls.extend(text_urls)
                
                # Remove duplicates while preserving order
                seen = set()
                unique_urls = []
                for url in question_image_urls:
                    if url not in seen:
                        seen.add(url)
                        unique_urls.append(url)
                
                # Fetch all images from unique URLs
                question_images = self.fetch_images_from_urls(unique_urls)
                
                # Add all question images in separate lines
                for img in question_images:
                    img_table = Table([[img]], colWidths=[doc.width])
                    img_table.setStyle(TableStyle([
                        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                        ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                        ('LEFTPADDING', (0, 0), (-1, -1), 0),
                        ('RIGHTPADDING', (0, 0), (-1, -1), 0),
                        ('BOTTOMPADDING', (0, 0), (-1, -1), 0),
                    ]))
                    story.append(img_table)
                    story.append(Spacer(1, 6))
                
                # ✅ IMPROVED OPTION IMAGE HANDLING WITH MULTIPLE URL SUPPORT
                # Process each option to get images and clean text
                option_data = []
                for option_key in ['option_a', 'option_b', 'option_c', 'option_d']:
                    raw_text = question[option_key]
                    clean_text = self.clean_text(raw_text)
                    
                    # Get image URLs from dedicated image URL column
                    image_urls = []
                    dedicated_url_col = f"{option_key}_image_url"
                    if question.get(dedicated_url_col):
                        dedicated_urls = self.extract_urls_from_text(question[dedicated_url_col])
                        image_urls.extend(dedicated_urls)
                    
                    # Also extract URLs from option text itself
                    text_urls = self.extract_urls_from_text(raw_text)
                    image_urls.extend(text_urls)
                    
                    # Remove duplicates
                    seen = set()
                    unique_urls = []
                    for url in image_urls:
                        if url not in seen:
                            seen.add(url)
                            unique_urls.append(url)
                    
                    # Fetch images
                    images = self.fetch_images_from_urls(unique_urls)
                    
                    option_data.append({
                        'letter': option_key[-1].upper(),  # A, B, C, D
                        'text': clean_text,
                        'images': images
                    })
                
                opt_a_data = option_data[0]
                opt_b_data = option_data[1]
                opt_c_data = option_data[2]
                opt_d_data = option_data[3]

                # ✅ IMPROVED LAYOUT: Check if we have any images to determine best layout
                has_images = any([
                    len(opt_a_data['images']) > 0,
                    len(opt_b_data['images']) > 0, 
                    len(opt_c_data['images']) > 0,
                    len(opt_d_data['images']) > 0
                ])
                
                use_single = has_images or self.should_use_single_column(
                    opt_a_data['text'], opt_b_data['text'], opt_c_data['text'], opt_d_data['text'], doc.width
                )

                if use_single:
                    # Single column layout - better for images
                    data = []
                    for opt_data in option_data:
                        opt_paragraph = Paragraph(f"({opt_data['letter']}) {opt_data['text']}", option_style) if opt_data['text'].strip() else ""
                        
                        # If there are images, create a table for text + images
                        if opt_data['images']:
                            # For multiple images, stack them vertically
                            if len(opt_data['images']) > 1:
                                images_table_data = [[img] for img in opt_data['images']]
                                images_table = Table(images_table_data, colWidths=[doc.width * 0.4])
                                images_table.setStyle(TableStyle([
                                    ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                                    ('LEFTPADDING', (0, 0), (-1, -1), 0),
                                    ('RIGHTPADDING', (0, 0), (-1, -1), 0),
                                ]))
                                data.append([opt_paragraph, images_table])
                            else:
                                data.append([opt_paragraph, opt_data['images'][0]])
                        else:
                            data.append([opt_paragraph, ""])
                    
                    # Use flexible column widths based on content
                    text_col_width = doc.width * 0.6 if has_images else doc.width * 0.8
                    img_col_width = doc.width * 0.4 if has_images else doc.width * 0.2
                    widths = [text_col_width, img_col_width]
                    
                else:
                    # Two column layout for text-only options
                    data = [
                        [Paragraph(f"(A) {opt_a_data['text']}", option_style), "",
                         Paragraph(f"(B) {opt_b_data['text']}", option_style), ""],
                        [Paragraph(f"(C) {opt_c_data['text']}", option_style), "",
                         Paragraph(f"(D) {opt_d_data['text']}", option_style), ""],
                    ]
                    widths = [doc.width * 0.45, doc.width * 0.05,
                              doc.width * 0.45, doc.width * 0.05]

                tbl = Table(data, colWidths=widths)
                tbl.setStyle(TableStyle([
                    ('VALIGN', (0,0), (-1,-1), 'TOP'),
                    ('ALIGN', (0,0), (-1,-1), 'LEFT'),
                    ('LEFTPADDING', (0,0), (-1,-1), 0),
                    ('RIGHTPADDING', (0,0), (-1,-1), 0),
                    ('TOPPADDING', (0,0), (-1,-1), 2),
                    ('BOTTOMPADDING', (0,0), (-1,-1), 2),
                ]))

                story.append(tbl)
                story.append(Spacer(1, 10))
                
                # Correct answer
                correct_option = question['correct_option']
                if correct_option:
                    correct_answer = f"Correct Answer: {correct_option}"
                    story.append(Paragraph(correct_answer, correct_answer_style))
                
                # Explanation
                if question.get('explanation'):
                    expl_text = self.clean_text(question['explanation'])
                    if expl_text and expl_text.strip():
                        story.append(Paragraph("Explanation:", explanation_label_style))
                        story.append(Paragraph(expl_text, explanation_text_style))
                
                story.append(Spacer(1, 15))
                
                # Add page break after every 5 questions
                if i % 5 == 0:
                    story.append(PageBreak())
            
            # Build PDF with header and footer
            doc.build(story, 
                     onFirstPage=lambda canvas, doc: self.add_header_footer(canvas, doc, paper_name),
                     onLaterPages=lambda canvas, doc: self.add_header_footer(canvas, doc, paper_name))
            logging.info(f"Complete PDF created successfully: {output_path}")
            return True
            
        except Exception as e:
            logging.error(f"Failed to create complete PDF: {e}")
            return False

    def create_questions_only_pdf(self, questions, output_path, paper_name):
        """Create PDF with only questions and options"""
        try:
            doc = SimpleDocTemplate(
                output_path,
                pagesize=letter,
                rightMargin=72,
                leftMargin=72,
                topMargin=72,
                bottomMargin=72
            )
            
            styles = getSampleStyleSheet()
            
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontName=UNICODE_FONT_BOLD,
                fontSize=16,
                spaceAfter=20,
                alignment=1,
                textColor=colors.black
            )
            
            question_number_style = ParagraphStyle(
                'QuestionNumberStyle',
                parent=styles['Normal'],
                fontName=UNICODE_FONT_BOLD,
                fontSize=12,
                spaceAfter=0,
                leading=14,
                textColor=colors.black,
                leftIndent=0
            )
            
            question_text_style = ParagraphStyle(
                'QuestionTextStyle',
                parent=styles['Normal'],
                fontName=UNICODE_FONT_BOLD,
                fontSize=12,
                leftIndent=0,
                spaceAfter=12,
                leading=14,
                textColor=colors.black
            )
            
            instruction_label_style = ParagraphStyle(
                'InstructionLabelStyle',
                parent=styles['Normal'],
                fontName=UNICODE_FONT_BOLD,
                fontSize=12,
                leftIndent=0,
                spaceAfter=0,
                leading=14,
                textColor=colors.black
            )
            
            instruction_text_style = ParagraphStyle(
                'InstructionTextStyle',
                parent=styles['Normal'],
                fontName=UNICODE_FONT,
                fontSize=12,
                leftIndent=0,
                spaceAfter=8,
                leading=14,
                textColor=colors.black
            )
            
            option_style = ParagraphStyle(
                'OptionStyle',
                parent=styles['Normal'],
                fontName=UNICODE_FONT,
                fontSize=12,
                leftIndent=0,
                spaceAfter=3,
                leading=14,
                textColor=colors.black
            )
            
            story = []
            
            # Add title
            title = Paragraph(f"{paper_name}", title_style)
            story.append(title)
            story.append(Spacer(1, 30))
            
            for i, question in enumerate(questions, 1):
                # ✅ USE ACTUAL QUESTION NUMBER FROM SHEET OR SEQUENTIAL
                actual_question_no = question.get('question_no', i)
                if not actual_question_no or str(actual_question_no).strip() == '':
                    actual_question_no = i
                
                # Clean text
                question_text = self.clean_text(question['question_text'])
                
                # ✅ ADD INSTRUCTIONS BEFORE QUESTION TEXT (IF PRESENT)
                if question.get('instructions'):
                    instr_text = self.clean_text(question['instructions'])
                    if instr_text and instr_text.strip():
                        instruction_label = Paragraph("<b>Instruction:</b>", instruction_label_style)
                        instruction_content = Paragraph(f"{instr_text}", instruction_text_style)
                        story.append(instruction_label)
                        story.append(instruction_content)
                        story.append(Spacer(1, 8))
                
                # Question number and text
                q_number = Paragraph(f"Q.{actual_question_no}", question_number_style)
                q_text = Paragraph(f"{question_text}", question_text_style)
                
                question_table = Table([[q_number, q_text]], colWidths=[35, doc.width - 35])
                question_table.setStyle(TableStyle([
                    ('VALIGN', (0, 0), (-1, 0), 'TOP'),
                    ('LEFTPADDING', (0, 0), (-1, 0), 0),
                    ('RIGHTPADDING', (0, 0), (-1, 0), 0),
                    ('BOTTOMPADDING', (0, 0), (-1, 0), 0),
                ]))
                
                story.append(question_table)
                story.append(Spacer(1, 8))
                
                # ✅ IMPROVED QUESTION IMAGE HANDLING WITH MULTIPLE URL SUPPORT
                question_image_urls = []
                
                # Get URLs from dedicated image URL column
                if question.get('question_image_url'):
                    dedicated_urls = self.extract_urls_from_text(question['question_image_url'])
                    question_image_urls.extend(dedicated_urls)
                
                # Also extract URLs from question text itself
                text_urls = self.extract_urls_from_text(question['question_text'])
                question_image_urls.extend(text_urls)
                
                # Remove duplicates while preserving order
                seen = set()
                unique_urls = []
                for url in question_image_urls:
                    if url not in seen:
                        seen.add(url)
                        unique_urls.append(url)
                
                # Fetch all images from unique URLs
                question_images = self.fetch_images_from_urls(unique_urls)
                
                # Add all question images in separate lines
                for img in question_images:
                    img_table = Table([[img]], colWidths=[doc.width])
                    img_table.setStyle(TableStyle([
                        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                        ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                        ('LEFTPADDING', (0, 0), (-1, -1), 0),
                        ('RIGHTPADDING', (0, 0), (-1, -1), 0),
                    ]))
                    story.append(img_table)
                    story.append(Spacer(1, 6))
                
                # ✅ IMPROVED OPTION IMAGE HANDLING WITH MULTIPLE URL SUPPORT
                # Process each option to get images and clean text
                option_data = []
                for option_key in ['option_a', 'option_b', 'option_c', 'option_d']:
                    raw_text = question[option_key]
                    clean_text = self.clean_text(raw_text)
                    
                    # Get image URLs from dedicated image URL column
                    image_urls = []
                    dedicated_url_col = f"{option_key}_image_url"
                    if question.get(dedicated_url_col):
                        dedicated_urls = self.extract_urls_from_text(question[dedicated_url_col])
                        image_urls.extend(dedicated_urls)
                    
                    # Also extract URLs from option text itself
                    text_urls = self.extract_urls_from_text(raw_text)
                    image_urls.extend(text_urls)
                    
                    # Remove duplicates
                    seen = set()
                    unique_urls = []
                    for url in image_urls:
                        if url not in seen:
                            seen.add(url)
                            unique_urls.append(url)
                    
                    # Fetch images
                    images = self.fetch_images_from_urls(unique_urls)
                    
                    option_data.append({
                        'letter': option_key[-1].upper(),  # A, B, C, D
                        'text': clean_text,
                        'images': images
                    })
                
                opt_a_data = option_data[0]
                opt_b_data = option_data[1]
                opt_c_data = option_data[2]
                opt_d_data = option_data[3]

                has_images = any([
                    len(opt_a_data['images']) > 0,
                    len(opt_b_data['images']) > 0, 
                    len(opt_c_data['images']) > 0,
                    len(opt_d_data['images']) > 0
                ])
                
                use_single = has_images or self.should_use_single_column(
                    opt_a_data['text'], opt_b_data['text'], opt_c_data['text'], opt_d_data['text'], doc.width
                )

                if use_single:
                    # Single column layout for better image display
                    data = []
                    for opt_data in option_data:
                        opt_paragraph = Paragraph(f"({opt_data['letter']}) {opt_data['text']}", option_style) if opt_data['text'].strip() else ""
                        
                        # If there are images, create a table for text + images
                        if opt_data['images']:
                            # For multiple images, stack them vertically
                            if len(opt_data['images']) > 1:
                                images_table_data = [[img] for img in opt_data['images']]
                                images_table = Table(images_table_data, colWidths=[doc.width * 0.4])
                                images_table.setStyle(TableStyle([
                                    ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                                    ('LEFTPADDING', (0, 0), (-1, -1), 0),
                                    ('RIGHTPADDING', (0, 0), (-1, -1), 0),
                                ]))
                                data.append([opt_paragraph, images_table])
                            else:
                                data.append([opt_paragraph, opt_data['images'][0]])
                        else:
                            data.append([opt_paragraph, ""])
                    
                    text_col_width = doc.width * 0.6 if has_images else doc.width * 0.8
                    img_col_width = doc.width * 0.4 if has_images else doc.width * 0.2
                    widths = [text_col_width, img_col_width]
                    
                else:
                    # Two column layout for text-only
                    data = [
                        [Paragraph(f"(A) {opt_a_data['text']}", option_style), "",
                         Paragraph(f"(B) {opt_b_data['text']}", option_style), ""],
                        [Paragraph(f"(C) {opt_c_data['text']}", option_style), "",
                         Paragraph(f"(D) {opt_d_data['text']}", option_style), ""],
                    ]
                    widths = [doc.width * 0.45, doc.width * 0.05,
                              doc.width * 0.45, doc.width * 0.05]

                tbl = Table(data, colWidths=widths)
                tbl.setStyle(TableStyle([
                    ('VALIGN', (0,0), (-1,-1), 'TOP'),
                    ('ALIGN', (0,0), (-1,-1), 'LEFT'),
                    ('LEFTPADDING', (0,0), (-1,-1), 0),
                    ('RIGHTPADDING', (0,0), (-1,-1), 0),
                    ('TOPPADDING', (0,0), (-1,-1), 2),
                    ('BOTTOMPADDING', (0,0), (-1,-1), 2),
                ]))

                story.append(tbl)
                story.append(Spacer(1, 15))
                
                # Add page break after every 8 questions
                if i % 8 == 0:
                    story.append(PageBreak())
            
            # Build PDF
            doc.build(story, 
                     onFirstPage=lambda canvas, doc: self.add_header_footer(canvas, doc, paper_name),
                     onLaterPages=lambda canvas, doc: self.add_header_footer(canvas, doc, paper_name))
            logging.info(f"Questions-only PDF created successfully: {output_path}")
            return True
            
        except Exception as e:
            logging.error(f"Failed to create questions-only PDF: {e}")
            return False

    def create_answers_only_pdf(self, questions, output_path, paper_name):
        """Create PDF with only correct answers in optimized 4-column format"""
        try:
            doc = SimpleDocTemplate(
                output_path,
                pagesize=letter,
                rightMargin=72,
                leftMargin=72,
                topMargin=72,
                bottomMargin=72
            )
            
            styles = getSampleStyleSheet()
            
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontName=UNICODE_FONT_BOLD,
                fontSize=16,
                spaceAfter=20,
                alignment=1,
                textColor=colors.black
            )
            
            story = []
            
            # Add title
            title = Paragraph(f"{paper_name}", title_style)
            story.append(title)
            story.append(Spacer(1, 8))
            story.append(Paragraph("Correct Answers", styles['Heading2']))
            story.append(Spacer(1, 25))
            
            # Group questions into chunks of 100
            chunk_size = 100
            question_chunks = [questions[i:i + chunk_size] for i in range(0, len(questions), chunk_size)]
            
            for chunk_index, chunk in enumerate(question_chunks):
                if chunk_index > 0:
                    story.append(PageBreak())
                
                # Create table data for 4 columns with 25 rows each
                table_data = []
                
                # Add header row
                header_row = ['Q.No', 'Answer', 'Q.No', 'Answer', 'Q.No', 'Answer', 'Q.No', 'Answer']
                table_data.append(header_row)
                
                # Add 25 rows
                for row_num in range(25):
                    row = []
                    for col in range(4):
                        question_index = row_num + (col * 25)
                        if question_index < len(chunk):
                            question = chunk[question_index]
                            # ✅ USE ACTUAL QUESTION NUMBER FROM SHEET OR SEQUENTIAL
                            actual_q_no = question.get('question_no', chunk_index * chunk_size + question_index + 1)
                            if not actual_q_no or str(actual_q_no).strip() == '':
                                actual_q_no = chunk_index * chunk_size + question_index + 1
                            row.extend([str(actual_q_no), question['correct_option']])
                        else:
                            row.extend(['', ''])
                    
                    table_data.append(row)
                
                # Calculate table width
                page_width = letter[0]
                available_width = page_width - 72 - 72
                col_width = available_width / 8
                col_widths = [col_width] * 8
                
                table = Table(table_data, colWidths=col_widths)
                table.setStyle(TableStyle([
                    ('BACKGROUND', (0, 0), (-1, 0), colors.lightgrey),
                    ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),
                    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                    ('FONTNAME', (0, 0), (-1, 0), UNICODE_FONT_BOLD),
                    ('FONTSIZE', (0, 0), (-1, 0), 10),
                    ('BOTTOMPADDING', (0, 0), (-1, 0), 8),
                    ('BACKGROUND', (0, 1), (-1, -1), colors.white),
                    ('FONTNAME', (0, 1), (-1, -1), UNICODE_FONT),
                    ('FONTSIZE', (0, 1), (-1, -1), 9),
                    ('GRID', (0, 0), (-1, -1), 0.5, colors.black),
                    ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.whitesmoke]),
                    ('LEFTPADDING', (0, 0), (-1, -1), 6),
                    ('RIGHTPADDING', (0, 0), (-1, -1), 6),
                ]))
                
                story.append(table)
                story.append(Spacer(1, 15))
            
            # Build PDF
            doc.build(story, 
                     onFirstPage=lambda canvas, doc: self.add_header_footer(canvas, doc, paper_name),
                     onLaterPages=lambda canvas, doc: self.add_header_footer(canvas, doc, paper_name))
            logging.info(f"Answers-only PDF created successfully: {output_path}")
            return True
            
        except Exception as e:
            logging.error(f"Failed to create answers-only PDF: {e}")
            return False

    def process_questions(self, data):
        """Process questions and group by paper"""
        papers = {}
        
        for row in data:
            try:
                # Extract paper information
                folder = self.clean_name(row.get(COLUMN_FOLDER, 'Default_Folder'))
                sub_folder = self.clean_name(row.get(COLUMN_SUB_FOLDER, 'General'))
                file_name = self.clean_name(row.get(COLUMN_FILE_NAME, 'Default_Paper'))
                
                paper_key = f"{folder}_{sub_folder}_{file_name}"
                
                if paper_key not in papers:
                    papers[paper_key] = {
                        'folder': folder,
                        'sub_folder': sub_folder,
                        'file_name': file_name,
                        'questions': []
                    }
                
                # Create question dictionary
                question = {
                    'question_no': row.get(COLUMN_QUESTION_NO, ''),
                    'question_text': row.get(COLUMN_QUESTION_TEXT, ''),
                    'instructions': row.get(COLUMN_INSTRUCTIONS, ''),
                    'option_a': row.get(COLUMN_OPTION_A, ''),
                    'option_b': row.get(COLUMN_OPTION_B, ''),
                    'option_c': row.get(COLUMN_OPTION_C, ''),
                    'option_d': row.get(COLUMN_OPTION_D, ''),
                    'correct_option': row.get(COLUMN_CORRECT_OPTION, ''),
                    'explanation': row.get(COLUMN_EXPLANATION, ''),
                    'content': row.get(COLUMN_CONTENT, ''),
                    'question_image_url': row.get(COLUMN_QUESTION_IMAGE_URL, ''),
                    'option_a_image_url': row.get(COLUMN_OPTION_A_IMAGE_URL, ''),
                    'option_b_image_url': row.get(COLUMN_OPTION_B_IMAGE_URL, ''),
                    'option_c_image_url': row.get(COLUMN_OPTION_C_IMAGE_URL, ''),
                    'option_d_image_url': row.get(COLUMN_OPTION_D_IMAGE_URL, '')
                }
                
                papers[paper_key]['questions'].append(question)
                
            except Exception as e:
                logging.warning(f"Error processing row: {e}")
                continue
        
        return papers

def main():
    # Configuration
    CREDENTIALS_FILE = "service-account.json"
    SPREADSHEET_ID = "1U6gW0yqh3GZlkyxvhF_5k3sXMP8GwZT-TNsXqKv7S1o"
    WORKSHEET_NAME = "Sheet4"
    OUTPUT_DIR = "Generated_PDFs"
    
    # Create output directory
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    
    try:
        # Initialize PDF generator
        pdf_gen = PDFGenerator(CREDENTIALS_FILE)
        
        # Load data from Google Sheets
        data = pdf_gen.load_data_from_sheets(SPREADSHEET_ID, WORKSHEET_NAME)
        
        # Process questions
        papers = pdf_gen.process_questions(data)
        logging.info(f"Found {len(papers)} papers to process")
        
        # Generate PDFs
        results = []
        
        for paper_key, paper_info in papers.items():
            try:
                paper_name = paper_info['file_name']
                questions = paper_info['questions']
                folder = paper_info['folder']
                sub_folder = paper_info['sub_folder']
                
                logging.info(f"Processing: {paper_name} ({len(questions)} questions)")
                
                # Create folder structure
                local_folder_path = pdf_gen.create_folder_structure(OUTPUT_DIR, folder, sub_folder)
                
                # Create PDF filenames for three types
                safe_name = "".join(c for c in paper_name if c.isalnum() or c in (' ', '-', '_')).rstrip()
                
                pdf_files = {
                    'complete': os.path.join(local_folder_path, f"{safe_name}_Complete_Solutions.pdf"),
                    'questions_only': os.path.join(local_folder_path, f"{safe_name}_Questions.pdf"),
                    'answers_only': os.path.join(local_folder_path, f"{safe_name}_Correct_Answers.pdf")
                }
                
                # Generate all three PDF types
                pdf_results = {}
                
                # 1. Complete PDF
                if pdf_gen.create_complete_pdf(questions, pdf_files['complete'], paper_name):
                    pdf_results['complete'] = pdf_files['complete']
                    logging.info(f"✓ Complete PDF created: {pdf_files['complete']}")
                else:
                    pdf_results['complete'] = None
                    logging.error(f"✗ Failed to create complete PDF")
                
                # 2. Questions only PDF
                if pdf_gen.create_questions_only_pdf(questions, pdf_files['questions_only'], paper_name):
                    pdf_results['questions_only'] = pdf_files['questions_only']
                    logging.info(f"✓ Questions-only PDF created: {pdf_files['questions_only']}")
                else:
                    pdf_results['questions_only'] = None
                    logging.error(f"✗ Failed to create questions-only PDF")
                
                # 3. Answers only PDF
                if pdf_gen.create_answers_only_pdf(questions, pdf_files['answers_only'], paper_name):
                    pdf_results['answers_only'] = pdf_files['answers_only']
                    logging.info(f"✓ Answers-only PDF created: {pdf_files['answers_only']}")
                else:
                    pdf_results['answers_only'] = None
                    logging.error(f"✗ Failed to create answers-only PDF")
                
                # Store results
                result = {
                    'paper_name': paper_name,
                    'folder': folder,
                    'sub_folder': sub_folder,
                    'questions_count': len(questions),
                    'complete_pdf': pdf_results['complete'],
                    'questions_pdf': pdf_results['questions_only'],
                    'answers_pdf': pdf_results['answers_only'],
                    'status': 'Success'
                }
                results.append(result)
                
                logging.info(f"Successfully processed: {paper_name}")
                    
            except Exception as e:
                logging.error(f"Failed to process paper {paper_key}: {e}")
                result = {
                    'paper_name': paper_key,
                    'folder': '',
                    'sub_folder': '',
                    'questions_count': 0,
                    'complete_pdf': '',
                    'questions_pdf': '',
                    'answers_pdf': '',
                    'status': f'Failed - {str(e)}'
                }
                results.append(result)
        
        # Save processing report
        report_df = pd.DataFrame(results)
        report_path = os.path.join(OUTPUT_DIR, "Processing_Report.csv")
        report_df.to_csv(report_path, index=False)
        logging.info(f"Results saved to: {report_path}")
        
        # Print summary
        successful = len([r for r in results if r['status'] == 'Success'])
        total = len(results)
        
        print("\n" + "="*60)
        print("PDF GENERATION COMPLETE!")
        print("="*60)
        print(f"Successfully processed: {successful}/{total} papers")
        print(f"Generated 3 PDF types for each paper:")
        print("  • Complete Solutions (with explanations)")
        print("  • Questions only (for practice)")
        print("  • Correct Answers (100 questions per page)")
        print(f"\nPDFs saved to: {OUTPUT_DIR}")
        print("All done!")
        
    except Exception as e:
        logging.error(f"Main process failed: {e}")
        raise

if __name__ == "__main__":
    main()
