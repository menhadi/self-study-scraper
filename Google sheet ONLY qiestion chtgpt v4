import requests
import base64
import json
import re
import csv
import os
from PIL import Image
from io import BytesIO
from google.oauth2 import service_account
from googleapiclient.discovery import build
from typing import Dict, List, Tuple
import time
import concurrent.futures

# ==============================
#  MODEL SETTINGS
# ==============================
EXTRACTION_MODEL = "gpt-4o"        # OCR extraction
DETECTION_MODEL_CHEAP = "gpt-4o-mini"    # Cheap detection model first
DETECTION_MODEL_ACCURATE = "gpt-4o"      # Accurate detection model second

EXTRACTION_TEMP = 0.1
DETECTION_TEMP = 0.0

# Progress tracking file
PROGRESS_FILE = "processed_files_part1.csv"

# Timely update settings
UPDATE_BATCH_SIZE = 10  # Update sheet every 10 questions extracted

# LESS AGGRESSIVE patterns for filename filtering
SKIP_PATTERNS = ['cover', 'title_page', 'instruction_only', 'answer_key', 'solution_manual']


# ========================================
#  MultiQuestionExtractor
# ========================================
class MultiQuestionExtractor:
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://api.openai.com/v1/chat/completions"
        self.headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {api_key}"
        }
        self.cheap_detection_count = 0
        self.accurate_detection_count = 0

    # --------------------------
    # ROBUST IMAGE OPTIMIZATION - FIXED VERSION
    # --------------------------
    def optimize_image(self, image_url, target_width=600, max_retries=3):
        """Robust image download + resize + convert ‚Üí base64 JPEG with retries."""
        for attempt in range(max_retries):
            try:
                print(f"üñºÔ∏è Downloading image (attempt {attempt + 1}): {image_url[-50:]}...")
                
                # Increased timeout and better error handling
                response = requests.get(image_url, timeout=60, stream=True)
                response.raise_for_status()
                
                # Check content type and size
                content_type = response.headers.get('content-type', '')
                if 'image' not in content_type:
                    print(f"‚ö†Ô∏è Not an image: {content_type}")
                    if attempt == max_retries - 1:
                        return None
                    time.sleep(2)
                    continue
                
                # Load image with size check
                img_data = BytesIO(response.content)
                img = Image.open(img_data)
                
                # Convert problematic modes
                if img.mode in ('RGBA', 'P', 'LA'):
                    img = img.convert('RGB')
                elif img.mode == '1':  # Binary image
                    img = img.convert('L')
                
                width, height = img.size
                print(f"üìê Original size: {width}x{height}")
                
                # Resize if too large (with aspect ratio preservation)
                if width > target_width:
                    ratio = target_width / float(width)
                    new_height = int(float(height) * ratio)
                    img = img.resize((target_width, new_height), Image.Resampling.LANCZOS)
                    print(f"üìè Resized to: {target_width}x{new_height}")
                
                # Optimize and convert to base64
                output = BytesIO()
                img.save(output, format='JPEG', quality=85, optimize=True)
                file_size = output.tell()
                print(f"üíæ Optimized size: {file_size} bytes")
                
                # Check if file size is reasonable
                if file_size > 10 * 1024 * 1024:  # 10MB limit
                    print("‚ö†Ô∏è File too large, reducing quality...")
                    output = BytesIO()
                    img.save(output, format='JPEG', quality=70, optimize=True)
                
                base64_data = base64.b64encode(output.getvalue()).decode('utf-8')
                print("‚úÖ Image optimization successful")
                return base64_data

            except requests.exceptions.RequestException as e:
                print(f"üåê Network error (attempt {attempt + 1}): {e}")
                if attempt == max_retries - 1:
                    return None
                time.sleep(3)  # Wait before retry
                
            except Exception as e:
                print(f"üñºÔ∏è Image processing error (attempt {attempt + 1}): {e}")
                if attempt == max_retries - 1:
                    return None
                time.sleep(2)
        
        return None

    # --------------------------
    # AUTO-FILL IMAGE OPTIONS - FIXED VERSION
    # --------------------------
    def _fix_image_options(self, questions):
        """Auto-detect and fill [IMAGE] placeholders for options with chemical structures"""
        for q in questions:
            # Check if options are empty or contain image indicators
            options_to_check = ['option_a', 'option_b', 'option_c', 'option_d']
            
            for opt_key in options_to_check:
                opt_value = q.get(opt_key, "").strip()
                
                # If option is empty or contains image-like patterns, use [IMAGE]
                if not opt_value or self._looks_like_image_placeholder(opt_value):
                    q[opt_key] = "[IMAGE]"
                
                # FORCEFULLY convert any LaTeX to Unicode
                else:
                    q[opt_key] = self._force_convert_latex_to_unicode(opt_value)
            
            # Also process question text and instructions for LaTeX conversion
            if 'text' in q:
                q['text'] = self._force_convert_latex_to_unicode(q['text'])
            if 'instructions' in q:
                q['instructions'] = self._force_convert_latex_to_unicode(q['instructions'])
                
        return questions

    def _looks_like_image_placeholder(self, text):
        """Check if text indicates it should be an image placeholder"""
        image_indicators = [
            'structure', 'diagram', 'figure', 'chart', 'graph',
            'chemical structure', 'molecular structure', 'reaction scheme',
            'image', 'picture', 'drawing', 'illustration', 'scheme'
        ]
        text_lower = text.lower()
        return any(indicator in text_lower for indicator in image_indicators)

    def _force_convert_latex_to_unicode(self, text):
        """FORCEFULLY convert ALL LaTeX chemical notation to Unicode - NO LATEX REMAINS"""
        if not text or not isinstance(text, str):
            return text
            
        # EXTENSIVE LaTeX to Unicode conversions
        substitutions = {
            # Subscripts (COMPREHENSIVE)
            r'_{0}': '‚ÇÄ', r'_0': '‚ÇÄ', r'_{1}': '‚ÇÅ', r'_1': '‚ÇÅ', 
            r'_{2}': '‚ÇÇ', r'_2': '‚ÇÇ', r'_{3}': '‚ÇÉ', r'_3': '‚ÇÉ', 
            r'_{4}': '‚ÇÑ', r'_4': '‚ÇÑ', r'_{5}': '‚ÇÖ', r'_5': '‚ÇÖ',
            r'_{6}': '‚ÇÜ', r'_6': '‚ÇÜ', r'_{7}': '‚Çá', r'_7': '‚Çá',
            r'_{8}': '‚Çà', r'_8': '‚Çà', r'_{9}': '‚Çâ', r'_9': '‚Çâ',
            r'_{10}': '‚ÇÅ‚ÇÄ', r'_{11}': '‚ÇÅ‚ÇÅ', r'_{12}': '‚ÇÅ‚ÇÇ',
            
            # Superscripts
            r'^{0}': '‚Å∞', r'^0': '‚Å∞', r'^{1}': '¬π', r'^1': '¬π',
            r'^{2}': '¬≤', r'^2': '¬≤', r'^{3}': '¬≥', r'^3': '¬≥',
            r'^{4}': '‚Å¥', r'^4': '‚Å¥', r'^{5}': '‚Åµ', r'^5': '‚Åµ',
            r'^{6}': '‚Å∂', r'^6': '‚Å∂', r'^{7}': '‚Å∑', r'^7': '‚Å∑',
            r'^{8}': '‚Å∏', r'^8': '‚Å∏', r'^{9}': '‚Åπ', r'^9': '‚Åπ',
            r'^{+}': '‚Å∫', r'^+': '‚Å∫', r'^{-}': '‚Åª', r'^-': '‚Åª',
            r'^{}': '', r'^{\prime}': '‚Ä≤',
            
            # Greek letters (COMPLETE SET)
            r'\alpha': 'Œ±', r'\beta': 'Œ≤', r'\gamma': 'Œ≥', r'\delta': 'Œ¥',
            r'\epsilon': 'Œµ', r'\varepsilon': 'Œµ', r'\zeta': 'Œ∂', r'\eta': 'Œ∑',
            r'\theta': 'Œ∏', r'\vartheta': 'œë', r'\iota': 'Œπ', r'\kappa': 'Œ∫',
            r'\lambda': 'Œª', r'\mu': 'Œº', r'\nu': 'ŒΩ', r'\xi': 'Œæ',
            r'\pi': 'œÄ', r'\varpi': 'œñ', r'\rho': 'œÅ', r'\varrho': 'œ±',
            r'\sigma': 'œÉ', r'\varsigma': 'œÇ', r'\tau': 'œÑ', r'\upsilon': 'œÖ',
            r'\phi': 'œÜ', r'\varphi': 'œÜ', r'\chi': 'œá', r'\psi': 'œà',
            r'\omega': 'œâ',
            r'\Gamma': 'Œì', r'\Delta': 'Œî', r'\Theta': 'Œò', r'\Lambda': 'Œõ',
            r'\Xi': 'Œû', r'\Pi': 'Œ†', r'\Sigma': 'Œ£', r'\Upsilon': 'Œ•',
            r'\Phi': 'Œ¶', r'\Psi': 'Œ®', r'\Omega': 'Œ©',
            
            # Arrows (COMPLETE SET)
            r'\rightarrow': '‚Üí', r'\to': '‚Üí', r'\leftarrow': '‚Üê', 
            r'\Rightarrow': '‚áí', r'\Leftarrow': '‚áê', r'\leftrightarrow': '‚Üî',
            r'\Leftrightarrow': '‚áî', r'\longrightarrow': '‚ü∂', r'\longleftarrow': '‚üµ',
            r'\Longrightarrow': '‚üπ', r'\Longleftarrow': '‚ü∏', r'\longleftrightarrow': '‚ü∑',
            r'\Longleftrightarrow': '‚ü∫', r'\mapsto': '‚Ü¶', r'\longmapsto': '‚üº',
            r'\hookrightarrow': '‚Ü™', r'\hookleftarrow': '‚Ü©', r'\rightharpoonup': '‚áÄ',
            r'\leftharpoonup': '‚Üº', r'\rightharpoondown': '‚áÅ', r'\leftharpoondown': '‚ÜΩ',
            r'\uparrow': '‚Üë', r'\downarrow': '‚Üì', r'\updownarrow': '‚Üï',
            r'\Uparrow': '‚áë', r'\Downarrow': '‚áì', r'\Updownarrow': '‚áï',
            r'\nearrow': '‚Üó', r'\searrow': '‚Üò', r'\swarrow': '‚Üô', r'\nwarrow': '‚Üñ',
            
            # Math symbols (COMPREHENSIVE)
            r'\times': '√ó', r'\div': '√∑', r'\pm': '¬±', r'\mp': '‚àì',
            r'\cdot': '¬∑', r'\ast': '‚àó', r'\star': '‚ãÜ', r'\circ': '‚àò',
            r'\bullet': '‚Ä¢', r'\oplus': '‚äï', r'\ominus': '‚äñ', r'\otimes': '‚äó',
            r'\oslash': '‚äò', r'\odot': '‚äô', r'\leq': '‚â§', r'\geq': '‚â•',
            r'\neq': '‚â†', r'\approx': '‚âà', r'\equiv': '‚â°', r'\propto': '‚àù',
            r'\sim': '‚àº', r'\simeq': '‚âÉ', r'\cong': '‚âÖ', r'\subset': '‚äÇ',
            r'\supset': '‚äÉ', r'\subseteq': '‚äÜ', r'\supseteq': '‚äá',
            r'\in': '‚àà', r'\ni': '‚àã', r'\notin': '‚àâ', r'\emptyset': '‚àÖ',
            r'\infty': '‚àû', r'\partial': '‚àÇ', r'\nabla': '‚àá', r'\forall': '‚àÄ',
            r'\exists': '‚àÉ', r'\neg': '¬¨', r'\wedge': '‚àß', r'\vee': '‚à®',
            r'\cap': '‚à©', r'\cup': '‚à™', r'\int': '‚à´', r'\sum': '‚àë',
            r'\prod': '‚àè', r'\sqrt': '‚àö', r'\angle': '‚à†', r'\triangle': '‚ñ≥',
            r'\parallel': '‚à•', r'\perp': '‚ä•', r'\dagger': '‚Ä†', r'\ddagger': '‚Ä°',
            
            # Chemical and physical symbols
            r'^{\circ}': '¬∞', r'^\circ': '¬∞', r'\degree': '¬∞',
            r'\celsius': '¬∞C', r'\angstrom': '√Ö', r'\AA': '√Ö',
            r'\ohm': 'Œ©', r'\micro': 'Œº', r'\cdot': '¬∑',
            
            # Brackets and parentheses
            r'\langle': '‚ü®', r'\rangle': '‚ü©', r'\lbrace': '{', r'\rbrace': '}',
            r'\lbrack': '[', r'\rbrack': ']', r'\lfloor': '‚åä', r'\rfloor': '‚åã',
            r'\lceil': '‚åà', r'\rceil': '‚åâ',
            
            # Common chemical compounds and notations
            r'\ce{': '', r'}': '',  # Remove \ce{} wrapper
            r'\,': ' ', r'\;': ' ', r'\quad': ' ', r'\qquad': '  ',
            r'\!': '', r'~': ' ', r'\ ': ' ',
            
            # Text formatting
            r'\text{': '', r'\mathrm{': '', r'\mathbf{': '', r'\mathit{': '',
            r'\mathbb{': '', r'\mathcal{': '', r'\mathfrak{': '',
        }
        
        # Apply substitutions MULTIPLE TIMES to catch nested LaTeX
        converted_text = text
        for _ in range(3):  # Multiple passes to catch nested commands
            for latex, unicode_char in substitutions.items():
                converted_text = converted_text.replace(latex, unicode_char)
        
        # Remove any remaining LaTeX braces
        converted_text = re.sub(r'\{([^}]*)\}', r'\1', converted_text)
        
        # Handle chemical formulas with multiple subscripts (H2O, CO2, CH4, etc.)
        converted_text = re.sub(r'([A-Za-z])(\d+)', self._convert_chemical_subscripts, converted_text)
        
        # Remove any remaining backslashes (failed conversions)
        converted_text = converted_text.replace('\\', '')
        
        return converted_text

    def _convert_chemical_subscripts(self, match):
        """Convert chemical formulas like H2O to H‚ÇÇO"""
        element = match.group(1)
        number = match.group(2)
        
        subscript_map = {
            '0': '‚ÇÄ', '1': '‚ÇÅ', '2': '‚ÇÇ', '3': '‚ÇÉ', '4': '‚ÇÑ',
            '5': '‚ÇÖ', '6': '‚ÇÜ', '7': '‚Çá', '8': '‚Çà', '9': '‚Çâ'
        }
        
        # Convert each digit to subscript
        subscript_number = ''.join(subscript_map.get(digit, digit) for digit in number)
        
        return element + subscript_number

    # --------------------------
    # HYBRID DETECTION - Cost-optimized approach
    # --------------------------
    def contains_questions(self, image_url: str, file_name: str) -> bool:
        """Hybrid detection: cheap model first, accurate model if uncertain"""
        
        # Step 1: Quick filename check (free)
        file_lower = file_name.lower()
        if any(pattern in file_lower for pattern in SKIP_PATTERNS):
            print(f"‚è≠Ô∏è {file_name} - Skipped by filename pattern")
            return False
        
        # Step 2: First pass with cheap model ($0.00015)
        cheap_result = self._detect_with_cheap_model(image_url, file_name)
        
        if cheap_result == "YES":
            print(f"‚úÖ {file_name} - Cheap model detected questions")
            return True
        elif cheap_result == "NO":
            print(f"‚è≠Ô∏è {file_name} - Cheap model says no questions")
            return False
        else:
            # Step 3: Second pass with accurate model ($0.0025)
            print(f"üîç {file_name} - Uncertain, using accurate model")
            accurate_result = self._detect_with_accurate_model(image_url, file_name)
            return accurate_result

    def _detect_with_cheap_model(self, image_url: str, file_name: str) -> str:
        """First pass with cheap model - cost: $0.00015 per image"""
        self.cheap_detection_count += 1
        
        base64_image = self.optimize_image(image_url, target_width=300)  # Very small for cost savings
        if not base64_image:
            return "UNCERTAIN"

        # OPTIMIZED PROMPT for chemistry questions
        detection_prompt = """
CRITICAL: This is for CHEMISTRY/SCIENCE exams. Look for:
1. Questions with numbers (Q39, 39., etc.)  
2. Chemical structures, molecular formulas, reactions
3. Multiple choice options (A) B) C) D)
4. Chemical notation like OEt, NaH, LIAH4, BuOOH
5. Structural formulas or diagrams
6. Text ending with "?" or question marks

If you see ANY chemical structures, numbered questions, or multiple choice options, answer YES.
If it's completely blank or only instructions, answer NO.

Answer ONLY "YES" or "NO".
"""

        payload = {
            "model": DETECTION_MODEL_CHEAP,
            "temperature": DETECTION_TEMP,
            "messages": [
                {
                    "role": "user",
                    "content": [
                        {"type": "text", "text": detection_prompt},
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:image/jpeg;base64,{base64_image}",
                                "detail": "low"
                            }
                        }
                    ]
                }
            ],
            "max_tokens": 5
        }

        try:
            response = requests.post(self.base_url, headers=self.headers, json=payload, timeout=30)
            if response.status_code == 200:
                content = response.json()["choices"][0]["message"]["content"].strip().upper()
                if "YES" in content:
                    return "YES"
                elif "NO" in content:
                    return "NO"
                else:
                    return "UNCERTAIN"
            else:
                print(f"Cheap detection API Error {response.status_code}")
                return "UNCERTAIN"
        except Exception as e:
            print(f"Cheap detection failed for {file_name}: {e}")
            return "UNCERTAIN"

    def _detect_with_accurate_model(self, image_url: str, file_name: str) -> bool:
        """Second pass with accurate model - cost: $0.0025 per image"""
        self.accurate_detection_count += 1
        
        base64_image = self.optimize_image(image_url, target_width=400)
        if not base64_image:
            return True  # When in doubt, process the image

        # COMPREHENSIVE PROMPT for accurate detection
        detection_prompt = """
Analyze this exam image thoroughly. Does it contain ANY question content including:

QUESTION PATTERNS:
- Numbered questions: Q39, 39., Q.39, etc.
- Multiple choice options: (A), (B), (C), (D)
- Questions ending with "?" or question text

CHEMISTRY/SCIENCE CONTENT:
- Chemical structures and molecular diagrams
- Chemical formulas: OEt, NaH, LIAH4, BuOOH, Ti(OPt)4, etc.
- Reaction schemes and chemical equations
- Structural formulas and organic chemistry notation
- Scientific diagrams and graphs

If you see ANY of the above question elements, chemical structures, or multiple choice content, answer YES.
If it's completely blank, only instructions, or a cover page, answer NO.

Answer ONLY "YES" or "NO".
"""

        payload = {
            "model": DETECTION_MODEL_ACCURATE,
            "temperature": DETECTION_TEMP,
            "messages": [
                {
                    "role": "user",
                    "content": [
                        {"type": "text", "text": detection_prompt},
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:image/jpeg;base64,{base64_image}",
                                "detail": "low"
                            }
                        }
                    ]
                }
            ],
            "max_tokens": 5
        }

        try:
            response = requests.post(self.base_url, headers=self.headers, json=payload, timeout=35)
            if response.status_code == 200:
                content = response.json()["choices"][0]["message"]["content"].strip().upper()
                result = "YES" in content
                print(f"üéØ Accurate detection for {file_name}: {'‚úÖ QUESTION' if result else '‚ùå NO QUESTION'}")
                return result
            else:
                print(f"Accurate detection API Error {response.status_code}")
                return True  # When in doubt, process
        except Exception as e:
            print(f"Accurate detection failed for {file_name}: {e}")
            return True  # When in doubt, process

    def print_detection_stats(self):
        """Print cost statistics for detection"""
        cheap_cost = self.cheap_detection_count * 0.00015
        accurate_cost = self.accurate_detection_count * 0.0025
        total_cost = cheap_cost + accurate_cost
        
        print(f"\nüí∞ DETECTION COST STATISTICS:")
        print(f"Cheap model detections: {self.cheap_detection_count} (${cheap_cost:.4f})")
        print(f"Accurate model detections: {self.accurate_detection_count} (${accurate_cost:.4f})")
        print(f"Total detection cost: ${total_cost:.4f}")
        print(f"Average cost per image: ${total_cost/(self.cheap_detection_count + self.accurate_detection_count):.6f}")

    # ----------------------------------------------
    # ROBUST EXTRACTION with better error handling
    # ----------------------------------------------
    def extract_all_questions_from_image(self, image_url: str, file_name: str) -> List[Dict]:
        """Robust extraction with multiple fallbacks"""
        
        base64_image = self.optimize_image(image_url, target_width=600)
        if not base64_image:
            # Try one more time with smaller size
            print(f"üîÑ Retrying image optimization with smaller size...")
            base64_image = self.optimize_image(image_url, target_width=400)
            if not base64_image:
                error_msg = f"Image processing failed after retries"
                print(f"‚ùå {error_msg} for {file_name}")
                return [{"error": error_msg, "file_name": file_name, "number": "ERROR"}]

        # STRICT PROMPT with NO LATEX requirement
        prompt = """
You are an OCR expert for scientific exams. Extract ALL questions from this image.

CRITICAL RULES - STRICTLY ENFORCED:
1. ABSOLUTELY NO LaTeX CODE - convert everything to Unicode
2. For ANY chemical structures, diagrams, reaction schemes ‚Üí use "[IMAGE]"
3. Convert ALL subscripts: H_2O ‚Üí H‚ÇÇO, CO_2 ‚Üí CO‚ÇÇ
4. Convert ALL Greek letters: \alpha ‚Üí Œ±, \beta ‚Üí Œ≤
5. Convert ALL arrows: \rightarrow ‚Üí ‚Üí, \leftarrow ‚Üí ‚Üê
6. For text-based chemical formulas (OEt, NaH, LiAlH‚ÇÑ) ‚Üí preserve exactly
7. Extract questions even if they use chemical structures instead of traditional numbering
8. Detect question type: "MCQ" or "FILL_IN_BLANK"
9. Extract instructions before questions
10. Output ONLY a valid JSON array

SPECIFIC [IMAGE] PLACEHOLDER CASES:
- Chemical structure diagrams ‚Üí "[IMAGE]"
- Reaction mechanism schemes ‚Üí "[IMAGE]" 
- Molecular orbital diagrams ‚Üí "[IMAGE]"
- Complex graphs/charts ‚Üí "[IMAGE]"
- Any non-text visual representation ‚Üí "[IMAGE]"

ZERO LATEX POLICY: Convert these examples:
- H_2SO_4 ‚Üí H‚ÇÇSO‚ÇÑ
- \alpha -particle ‚Üí Œ±-particle  
- A \rightarrow B ‚Üí A ‚Üí B
- \ce{H2O} ‚Üí H‚ÇÇO
- 25^{\circ}C ‚Üí 25¬∞C

JSON SCHEMA:
[
  {
    "number": "Q39",
    "type": "MCQ", 
    "text": "question text [IMAGE] [IMAGE]",
    "option_a": "chemical formula or [IMAGE]",
    "option_b": "chemical formula or [IMAGE]", 
    "option_c": "chemical formula or [IMAGE]",
    "option_d": "chemical formula or [IMAGE]",
    "instructions": "any instructions before the question"
  }
]
"""

        payload = {
            "model": EXTRACTION_MODEL,
            "temperature": EXTRACTION_TEMP,
            "messages": [
                {
                    "role": "user",
                    "content": [
                        {"type": "text", "text": prompt},
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:image/jpeg;base64,{base64_image}",
                                "detail": "high"
                            }
                        }
                    ]
                }
            ],
            "max_tokens": 4000  # Increased for complex questions
        }

        try:
            print(f"üß™ Extracting questions from: {file_name}")
            response = requests.post(self.base_url, headers=self.headers, json=payload, timeout=120)

            if response.status_code != 200:
                error_msg = f"OCR API Error: {response.status_code}"
                if response.status_code == 400:
                    error_detail = response.json().get('error', {}).get('message', '')
                    error_msg += f" - {error_detail}"
                elif response.status_code == 429:
                    error_msg += " - Rate Limit Exceeded (waiting 10s)"
                    time.sleep(10)
                    return self.extract_all_questions_from_image(image_url, file_name)  # Retry
                elif response.status_code == 500:
                    error_msg += " - Internal Server Error"
                elif response.status_code == 503:
                    error_msg += " - Service Unavailable"
                
                print(f"{error_msg} for {file_name}")
                return [{"error": error_msg, "file_name": file_name, "number": "ERROR"}]

            content = response.json()["choices"][0]["message"]["content"].strip()

            # Parse JSON
            questions = self._parse_questions_json(content)
            if not questions:
                print("‚ö† OCR JSON parsing failed ‚Üí fallback text parser")
                questions = self._fallback_parse(content, file_name)
                
                # If fallback also fails, create at least one question entry
                if not questions:
                    print("üí• Complete extraction failure, creating error question")
                    return [{
                        "number": "EXTRACTION_FAILED", 
                        "type": "ERROR", 
                        "text": f"Failed to extract questions from {file_name}",
                        "option_a": "", "option_b": "", "option_c": "", "option_d": "",
                        "instructions": "", "file_name": file_name
                    }]

            # FORCEFULLY apply image placeholders and LaTeX conversion
            questions = self._fix_image_options(questions)

            # Add defaults with safe type handling
            for q in questions:
                q["file_name"] = file_name
                q.setdefault("type", "MCQ")
                q.setdefault("option_a", "")
                q.setdefault("option_b", "")
                q.setdefault("option_c", "")
                q.setdefault("option_d", "")
                q.setdefault("instructions", "")
                q.setdefault("number", f"Q{questions.index(q)+1}")  # Ensure number exists

            print(f"‚úÖ Extracted {len(questions)} questions from {file_name}")
            return questions

        except Exception as e:
            error_msg = f"Extraction failed: {str(e)}"
            print(f"‚ùå {error_msg} for {file_name}")
            return [{"error": error_msg, "file_name": file_name, "number": "ERROR"}]

    # --------------------------
    # JSON PARSER
    # --------------------------
    def _parse_questions_json(self, text):
        text = text.strip()

        # Direct array
        try:
            obj = json.loads(text)
            if isinstance(obj, list):
                return obj
        except:
            pass

        # Code block
        m = re.search(r'```json\s*(\[.*?\])\s*```', text, re.DOTALL)
        if m:
            try:
                return json.loads(m.group(1))
            except:
                pass

        # None found
        return None

    # -----------------------------------
    # IMPROVED FALLBACK TEXT PARSER
    # -----------------------------------
    def _fallback_parse(self, raw_text, file_name):
        """Improved fallback parser that always returns at least one question"""
        lines = raw_text.split("\n")
        questions = []
        current = None
        instructions = []
        question_found = False

        for line in lines:
            t = line.strip()
            if not t:
                continue

            # instructions block BEFORE first question
            if not question_found and re.match(r'(instruction|direction|read)', t, re.I):
                instructions.append(t)
                continue

            # IMPROVED question detection for chemistry
            qmatch = re.match(r'(Q\.?\s*\d+|\d+\.)', t, re.I)
            if qmatch:
                question_found = True

                if current:
                    current["instructions"] = " ".join(instructions)
                    questions.append(current)

                num = qmatch.group(1)
                txt = t[len(num):].strip()

                current = {
                    "number": num.replace(".", ""),
                    "type": "MCQ",
                    "text": txt,
                    "option_a": "",
                    "option_b": "",
                    "option_c": "",
                    "option_d": "",
                    "instructions": "",
                    "file_name": file_name
                }
                continue

            # detect options
            if current:
                om = re.match(r'([A-D])[\.\)]\s*(.+)', t)
                if om:
                    key = f"option_{om.group(1).lower()}"
                    current[key] = om.group(2)
                    continue

                # add to question text
                current["text"] += " " + t

        # last question
        if current:
            current["instructions"] = " ".join(instructions)
            questions.append(current)

        # If no questions found but there's content, create one question with all text
        if not questions and raw_text.strip():
            questions.append({
                "number": "Q1",
                "type": "MCQ", 
                "text": raw_text[:500],  # Limit text length
                "option_a": "", "option_b": "", "option_c": "", "option_d": "",
                "instructions": "", 
                "file_name": file_name
            })

        return questions

    # -----------------------------------------------
    # PROCESS IMAGES IN BATCHES with better error handling
    # -----------------------------------------------
    def process_image_batch(self, image_batch: List[Tuple[str, str]]) -> List[Dict]:
        results = []
        
        # First, detect which images contain actual questions
        print("üîç Hybrid detection: cheap model first, accurate if uncertain...")
        valid_images = []
        
        for name, url in image_batch:
            if self.contains_questions(url, name):
                print(f"‚úÖ {name} - Contains questions")
                valid_images.append((name, url))
            else:
                print(f"‚è≠Ô∏è {name} - No questions found")
        
        if not valid_images:
            return results
            
        # Process only images with actual questions
        with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:  # Reduced workers for stability
            # Submit all tasks and store them in order
            future_to_index = {
                executor.submit(self.extract_all_questions_from_image, url, name): i 
                for i, (name, url) in enumerate(valid_images)
            }
            
            # Create a list to store results in original order
            temp_results = [None] * len(valid_images)
            
            for future in concurrent.futures.as_completed(future_to_index):
                index = future_to_index[future]
                fname, url = valid_images[index]
                try:
                    res = future.result(timeout=180)  # Increased timeout
                    temp_results[index] = res
                    print(f"‚úÖ Completed processing: {fname}")
                except concurrent.futures.TimeoutError:
                    error_msg = "Processing timeout"
                    print(f"‚è∞ {error_msg} for {fname}")
                    temp_results[index] = [{"error": error_msg, "file_name": fname, "number": "TIMEOUT"}]
                except Exception as e:
                    error_msg = f"Processing failed: {str(e)}"
                    print(f"‚ùå {error_msg} for {fname}")
                    temp_results[index] = [{"error": error_msg, "file_name": fname, "number": "ERROR"}]
                
                # Request delay between API calls
                time.sleep(3)
            
            # Flatten the results while maintaining order
            for result in temp_results:
                if result is not None:
                    results.extend(result)
        
        return results


# =====================================================
#  GOOGLE SHEET PROCESSOR - PART 1
# =====================================================
class GoogleSheetProcessorPart1:
    def __init__(self, credentials_file: str, sheet_id: str, api_key: str, sheet_tab: str):
        self.sheet_id = sheet_id
        self.sheet_tab = sheet_tab
        self.extractor = MultiQuestionExtractor(api_key)
        self.service = self._auth(credentials_file)
        self.processed_questions = []  # Track all processed questions
        self.next_output_row = 2  # Start from row 2 (after header)

    # ----------------------
    # AUTH
    # ----------------------
    def _auth(self, credentials_file):
        try:
            scopes = ['https://www.googleapis.com/auth/spreadsheets']
            creds = service_account.Credentials.from_service_account_file(
                credentials_file, scopes=scopes)
            return build('sheets', 'v4', credentials=creds)
        except Exception as e:
            print("Google Sheets Auth Failed:", e)
            raise

    # ----------------------
    # READ SHEET
    # ----------------------
    def read_sheet(self):
        try:
            result = self.service.spreadsheets().values().get(
                spreadsheetId=self.sheet_id,
                range=f"{self.sheet_tab}!A:B"  # Only read file names and URLs
            ).execute()

            return result.get("values", [])
        except Exception as e:
            print("Error reading sheet:", e)
            return []

    # ----------------------
    # PROGRESS TRACKING - CSV BASED
    # ----------------------
    def load_processed_files(self):
        """Load already processed files from CSV"""
        processed_files = set()
        if os.path.exists(PROGRESS_FILE):
            try:
                with open(PROGRESS_FILE, 'r', newline='') as f:
                    reader = csv.reader(f)
                    for row in reader:
                        if row:
                            processed_files.add(row[0])
                print(f"üìä Loaded {len(processed_files)} processed files from {PROGRESS_FILE}")
            except Exception as e:
                print(f"Error reading progress file: {e}")
        return processed_files

    def save_processed_files(self, processed_files):
        """Save processed files to CSV"""
        try:
            with open(PROGRESS_FILE, 'w', newline='') as f:
                writer = csv.writer(f)
                for file_name in processed_files:
                    writer.writerow([file_name])
            print(f"üíæ Saved {len(processed_files)} processed files to {PROGRESS_FILE}")
        except Exception as e:
            print(f"Error saving progress file: {e}")

    def mark_file_processed(self, file_name, processed_files):
        """Mark a file as processed and save to CSV"""
        processed_files.add(file_name)
        self.save_processed_files(processed_files)

    # ----------------------
    # CLEAR OUTPUT COLUMNS (OPTIONAL - now only for full reset)
    # ----------------------
    def clear_output(self):
        try:
            # Clear columns C to N (question data columns)
            self.service.spreadsheets().values().clear(
                spreadsheetId=self.sheet_id,
                range=f"{self.sheet_tab}!C:N"
            ).execute()
            print("Old question data cleared (C:N).")
        except Exception as e:
            print("Clear failed:", e)

    # ----------------------
    # UPDATE SHEET - TIMELY UPDATES
    # ----------------------
    def update_sheet_timely(self, questions_batch: List[Dict]):
        """Update sheet with a batch of questions (timely updates)"""
        if not questions_batch:
            return

        # format sheet rows (only question data, no answers)
        # NEW COLUMN ORDER:
        # C=Type, D=Number, E=File Name, F=Instructions, G=Text, H=Option A, I=Option B, J=Option C, K=Option D
        rows = []

        for q in questions_batch:
            if "error" in q:
                rows.append([
                    "ERROR",           # C: Type
                    q.get("number", ""),  # D: Number  
                    q.get("file_name",""),  # E: File Name
                    "",               # F: Instructions
                    q["error"],        # G: Text
                    "", "", "", ""     # H-K: Options A-D
                ])
                continue
            
            rows.append([
                q.get("type",""),      # C: Type
                q.get("number",""),    # D: Number
                q.get("file_name",""), # E: File Name
                q.get("instructions",""),  # F: Instructions
                q.get("text",""),      # G: Text
                q.get("option_a",""),  # H: Option A
                q.get("option_b",""),  # I: Option B  
                q.get("option_c",""),  # J: Option C
                q.get("option_d","")   # K: Option D
            ])

        try:
            self.service.spreadsheets().values().update(
                spreadsheetId=self.sheet_id,
                range=f"{self.sheet_tab}!C{self.next_output_row}",
                valueInputOption="RAW",
                body={"values": rows}
            ).execute()
            
            print(f"üìä TIMELY UPDATE: Added {len(rows)} questions to sheet (starting row {self.next_output_row})")
            self.next_output_row += len(rows)  # Move pointer for next update
            
        except Exception as e:
            print(f"Timely update failed: {e}")

    # =====================================================
    # PROCESS ALL IMAGES WITH ROBUST ERROR HANDLING
    # =====================================================
    def process_all_images(self, batch_size=2, resume=True):  # Reduced batch size for stability

        data = self.read_sheet()

        if len(data) < 2:
            print("No data in sheet.")
            return

        # Load processed files from CSV
        processed_files = self.load_processed_files()
        
        if resume and processed_files:
            print(f"üìä Resuming - Found {len(processed_files)} already processed files")
        else:
            print("üÜï Starting fresh - No previous progress found")

        # Don't clear output if resuming and there are processed files
        if not resume or not processed_files:
            self.clear_output()
            self.next_output_row = 2  # Reset to row 2

        # build batches, skip already processed files
        batches = []
        temp = []
        processed_count = 0

        for i, row in enumerate(data[1:], start=2):
            if len(row) < 2:
                continue

            fname = row[0]
            url = row[1]

            if not url.startswith("http"):
                continue

            # Skip already processed files when resuming
            if resume and fname in processed_files:
                processed_count += 1
                continue

            temp.append((fname, url))

            if len(temp) == batch_size:
                batches.append(temp)
                temp = []

        if temp:
            batches.append(temp)

        print(f"üìÅ New files to process: {sum(len(b) for b in batches)}")
        print(f"‚úÖ Already processed: {processed_count}")

        if not batches:
            print("üéâ All files already processed!")
            return

        # process batches with robust error handling
        all_questions = []
        pending_questions = []  # Questions waiting to be written to sheet

        for i, b in enumerate(batches, start=1):
            print(f"\n=== Processing batch {i}/{len(batches)} ===")
            try:
                qlist = self.extractor.process_image_batch(b)

                # Mark files as processed (even if they had errors)
                for q in qlist:
                    if "file_name" in q and q["file_name"] not in processed_files:
                        self.mark_file_processed(q["file_name"], processed_files)

                all_questions.extend(qlist)
                pending_questions.extend(qlist)

                # TIMELY UPDATE: Update sheet every UPDATE_BATCH_SIZE questions
                if len(pending_questions) >= UPDATE_BATCH_SIZE:
                    print(f"üîÑ Updating sheet with {len(pending_questions)} questions...")
                    self.update_sheet_timely(pending_questions)
                    pending_questions = []  # Clear pending questions after update

                time.sleep(5)  # Increased delay between batches
                
            except Exception as e:
                print(f"üí• Batch {i} failed: {e}")
                # Continue with next batch instead of stopping
                continue

        # Update any remaining questions
        if pending_questions:
            print(f"üîÑ Final update with {len(pending_questions)} remaining questions...")
            self.update_sheet_timely(pending_questions)

        # Print cost statistics
        self.extractor.print_detection_stats()

        print(f"‚úÖ Successfully processed {len(all_questions)} total questions")
        print(f"üìä Questions written to sheet starting from row 2")

# =====================================================
# MAIN RUNNER - PART 1
# =====================================================

def main_part1():

    # ====== IMPORTANT CONFIGURATION ======
    OPENAI_API_KEY = "your_openai_api_key_here"

    if not OPENAI_API_KEY or OPENAI_API_KEY == "your_openai_api_key_here":
        print("‚ùå ERROR: Please put your real OpenAI API key in the script.")
        return

    GOOGLE_SHEET_ID = "1U6gW0yqh3GZlkyxvhF_5k3sXMP8GwZT-TNsXqKv7S1o"
    CREDENTIALS_FILE = "service-account.json"
    SHEET_TAB = "Sheet4"

    BATCH_SIZE = 2            # Reduced for stability
    RESUME_MODE = True        # Set to False to start from scratch

    print("\n" + "="*80)
    print(" üîç PART 1: QUESTION EXTRACTION WITH HYBRID DETECTION ")
    print("="*80)
    print(f" Extraction Model : {EXTRACTION_MODEL}")
    print(f" Detection Models : {DETECTION_MODEL_CHEAP} + {DETECTION_MODEL_ACCURATE}")
    print(f" Batch Size       : {BATCH_SIZE}")
    print(f" Resume Mode      : {'ON' if RESUME_MODE else 'OFF'}")
    print(f" Progress File    : {PROGRESS_FILE}")
    print(f" Timely Updates   : Every {UPDATE_BATCH_SIZE} questions")
    print("="*80)
    print("üí∞ Cost Strategy: Cheap detection first ($0.00015), accurate if uncertain ($0.0025)")
    print("="*80)

    try:
        processor = GoogleSheetProcessorPart1(
            CREDENTIALS_FILE,
            GOOGLE_SHEET_ID,
            OPENAI_API_KEY,
            SHEET_TAB
        )

        processor.process_all_images(batch_size=BATCH_SIZE, resume=RESUME_MODE)

        print("\nüéâ PART 1 COMPLETED SUCCESSFULLY!")
        print("All questions extracted and saved to sheet columns C through K.")

    except Exception as e:
        print(f"\n‚ùå FATAL ERROR: {e}")
        import traceback
        traceback.print_exc()


# =====================================================
# ENTRY POINT
# =====================================================
if __name__ == "__main__":
    main_part1()
