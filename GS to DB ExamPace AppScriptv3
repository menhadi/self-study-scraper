/*********************************
 * GLOBAL CONFIG
 *********************************/
const GOOGLE_SHEET_ID = "1Ur-uRw_LwfA7UchfwfjwIO6ZQsGtD1fJHQLsYoSxbAU";

/**
 * TAB NAME â†’ DB TABLE
 */
const TAB_TABLE_MAP = {
  "groups": "groups",
  "packages": "packages",
  "package_groups": "package_groups",
  "exams": "exams",
  "exam_groups": "exam_groups",
  "exam_questions": "exam_questions",
  "exam_packages": "exam_packages",
  "exam_subject_durations": "exam_subject_durations",
  "question_groups": "question_groups",
  "subjects": "subjects",
  "subject_groups": "subject_groups"
};

const API_BASE_URL = "https://exampace.com/api";
const API_KEY = "EXAMPACE_SYNC_KEY_2025";

const BATCH_SIZE = 300;
const TIMESTAMP_FORMAT = "yyyy-MM-dd HH:mm:ss";

/*********************************
 * HELPERS
 *********************************/
function getSheet_(tab) {
  const ss = SpreadsheetApp.openById(GOOGLE_SHEET_ID);
  const sheet = ss.getSheetByName(tab);
  if (!sheet) throw new Error(`âŒ Tab "${tab}" not found`);
  return sheet;
}

function norm_(v) {
  return v === null || v === undefined ? "" : v.toString().trim();
}

function now_() {
  return Utilities.formatDate(
    new Date(),
    Session.getScriptTimeZone(),
    TIMESTAMP_FORMAT
  );
}

function getAllowedColumns_(table) {
  const res = UrlFetchApp.fetch(
    `${API_BASE_URL}/schema.php?table=${encodeURIComponent(table)}`,
    { headers: { "X-API-KEY": API_KEY } }
  );
  const json = JSON.parse(res.getContentText());
  if (!json.success) throw new Error(res.getContentText());
  return json.columns.map(c => c.trim().toLowerCase());
}

function getAllTabs_() {
  return Object.keys(TAB_TABLE_MAP);
}

/*********************************
 * ğŸ”¼ PUSH (INSERT + UPDATE) â€” BATCH SAFE
 *********************************/
function pushOneTab_(tab) {
  const table = TAB_TABLE_MAP[tab];
  const sheet = getSheet_(tab);

  const headers = sheet.getRange(1,1,1,sheet.getLastColumn())
    .getValues()[0]
    .map(h => h.toString().trim());

  const headersLc = headers.map(h => h.toLowerCase());

  const idCol = headersLc.indexOf("id");
  const statusCol = headersLc.indexOf("syncstatus");
  if (statusCol === -1) return;

  const allowed = getAllowedColumns_(table);

  const rows = sheet.getLastRow() > 1
    ? sheet.getRange(2,1,sheet.getLastRow()-1,headers.length).getValues()
    : [];

  const payload = [];
  const rowNums = [];
  const hasId = [];

  rows.forEach((row, i) => {
    if (norm_(row[statusCol]).toLowerCase() !== "pending") return;

    const obj = {};

    if (idCol !== -1 && row[idCol]) {
      obj.id = Number(row[idCol]);
    }

    headers.forEach((h, idx) => {
      const hLc = h.toLowerCase();
      if (!allowed.includes(hLc)) return;
      if (["id", "syncstatus", "created_at"].includes(hLc)) return;

      const v = row[idx];
      if (v === "" || v === "NULL") return;

      if (v instanceof Date) {
        const d = new Date(v);
        if (d.getSeconds() > 59) d.setSeconds(59);
        obj[hLc] = Utilities.formatDate(d, Session.getScriptTimeZone(), TIMESTAMP_FORMAT);
      } else {
        obj[hLc] = v;
      }
    });

    obj.updated_at = now_();

    // ğŸ”’ Must contain at least one real DB column
    const realKeys = Object.keys(obj).filter(
      k => !["id", "updated_at"].includes(k)
    );
    if (!realKeys.length) {
      Logger.log(`â­ï¸ Skipping row ${i+2}: no real DB columns`);
      return;
    }

    payload.push(obj);
    rowNums.push(i + 2);
    hasId.push(!!(idCol !== -1 && row[idCol]));
  });

  if (!payload.length) return;

  // ğŸ”¥ PUSH IN BATCHES
  for (let start = 0; start < payload.length; start += BATCH_SIZE) {
    const end = Math.min(start + BATCH_SIZE, payload.length);

    const batchPayload = payload.slice(start, end);
    const batchRowNums = rowNums.slice(start, end);
    const batchHasId = hasId.slice(start, end);

    const res = UrlFetchApp.fetch(`${API_BASE_URL}/push.php`, {
      method: "post",
      contentType: "application/json",
      headers: { "X-API-KEY": API_KEY },
      payload: JSON.stringify({
        table,
        rows: batchPayload
      })
    });

    const json = JSON.parse(res.getContentText());
    if (!json.success) throw new Error(res.getContentText());

    batchPayload.forEach((_, i) => {
      if (!batchHasId[i] && json.rows?.[i]?.id) {
        sheet.getRange(batchRowNums[i], idCol + 1).setValue(json.rows[i].id);
      }
      sheet.getRange(batchRowNums[i], statusCol + 1).setValue("Synced");
    });

    Logger.log(`âœ… PUSH ${tab} â†’ ${table}: rows ${start+1}â€“${end}`);
  }
}

function pushAllTabs() {
  getAllTabs_().forEach(pushOneTab_);
}

/*********************************
 * â¬‡ï¸ PULL (FULL + INCREMENTAL)
 *********************************/
function pullOneTab_(tab) {
  const table = TAB_TABLE_MAP[tab];
  const sheet = getSheet_(tab);

  const headers = sheet.getRange(1,1,1,sheet.getLastColumn())
    .getValues()[0]
    .map(h => h.toString().trim());

  const headersLc = headers.map(h => h.toLowerCase());

  const idCol = headersLc.indexOf("id");
  const statusCol = headersLc.indexOf("syncstatus");

  const props = PropertiesService.getScriptProperties();
  const key = `lastSync_${GOOGLE_SHEET_ID}_${tab}`;
  const lastSync = props.getProperty(key) || "1970-01-01 00:00:00";

  const rows = sheet.getLastRow() > 1
    ? sheet.getRange(2,1,sheet.getLastRow()-1,headers.length).getValues()
    : [];

  const idMap = {};
  rows.forEach((r, i) => {
    if (idCol !== -1 && r[idCol]) {
      idMap[Number(r[idCol])] = i + 2;
    }
  });

  const res = UrlFetchApp.fetch(`${API_BASE_URL}/pull.php`, {
    method: "post",
    contentType: "application/json",
    headers: { "X-API-KEY": API_KEY },
    payload: JSON.stringify({
      table,
      lastSync,
      existingIds:
        (!rows.length || lastSync === "1970-01-01 00:00:00")
          ? []
          : Object.keys(idMap)
    })
  });

  const json = JSON.parse(res.getContentText());
  if (!json.success) throw new Error(res.getContentText());

  let maxUpdatedAt = lastSync;

  json.rows.forEach(row => {
    const arr = headersLc.map(h => {
      if (h === "id") return row.id ?? "";
      return row[h] ?? "";
    });

    if (statusCol !== -1) arr[statusCol] = "Synced";

    if (row.updated_at && row.updated_at > maxUpdatedAt) {
      maxUpdatedAt = row.updated_at;
    }

    if (idMap[row.id]) {
      sheet.getRange(idMap[row.id],1,1,arr.length).setValues([arr]);
    } else {
      sheet.appendRow(arr);
    }
  });

  props.setProperty(key, maxUpdatedAt);
  Logger.log(`âœ… PULL ${tab} â† ${table}: ${json.rows.length}`);
}

function pullAllTabs() {
  getAllTabs_().forEach(pullOneTab_);
}

/*********************************
 * ğŸª„ onEdit â†’ Pending
 *********************************/
function onEdit(e) {
  if (!e || !e.range) return;

  const sheet = e.range.getSheet();
  const tab = sheet.getName();
  if (!TAB_TABLE_MAP[tab]) return;

  const headers = sheet.getRange(1,1,1,sheet.getLastColumn())
    .getValues()[0]
    .map(h => h.toString().trim().toLowerCase());

  const statusCol = headers.indexOf("syncstatus");
  if (statusCol === -1) return;

  if (e.range.getRow() > 1 && e.range.getColumn() !== statusCol + 1) {
    sheet.getRange(e.range.getRow(), statusCol + 1).setValue("Pending");
  }
}

/*********************************
 * â™»ï¸ RESET (FULL RESYNC)
 *********************************/
function resetAllLastSync() {
  const props = PropertiesService.getScriptProperties();
  getAllTabs_().forEach(tab =>
    props.deleteProperty(`lastSync_${GOOGLE_SHEET_ID}_${tab}`)
  );
  Logger.log("ğŸ” lastSync reset for all tabs");
}
