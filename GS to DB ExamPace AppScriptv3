/******************************
 * CONFIGURATION
 ******************************/
const API_BASE_URL = "https://exampace.com/api";
const API_KEY = "EXAMPACE_SYNC_KEY_2025";
const BATCH_SIZE = 300;
const TIMESTAMP_FORMAT = "yyyy-MM-dd HH:mm:ss";

/******************************
 * üîé AUTO-FETCH DB SCHEMA
 ******************************/
function getAllowedColumns_(tableName) {
  const res = UrlFetchApp.fetch(
    `${API_BASE_URL}/schema.php?table=${encodeURIComponent(tableName)}`,
    {
      headers: { "X-API-KEY": API_KEY },
      muteHttpExceptions: true
    }
  );

  let json;
  try {
    json = JSON.parse(res.getContentText());
  } catch (e) {
    throw new Error("Invalid schema API response:\n" + res.getContentText());
  }

  if (!json.success) {
    throw new Error("Schema API error: " + JSON.stringify(json));
  }

  return json.columns;
}

/******************************
 * üîº PUSH FUNCTION
 ******************************/
function pushSheetToDB() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
  const tableName = sheet.getName();

  Logger.log(`üîº Pushing "${tableName}" ‚Üí DB`);

  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const statusCol = headers.findIndex(h => h.toString().toLowerCase() === "syncstatus");
  if (statusCol === -1) return Logger.log("‚ùå Missing SyncStatus");

  const allowedCols = getAllowedColumns_(tableName);

  const rows = sheet.getLastRow() >= 2
    ? sheet.getRange(2, 1, sheet.getLastRow() - 1, headers.length).getValues()
    : [];

  const pending = [];

  rows.forEach((row, i) => {
    if (row[statusCol]?.toString().toLowerCase() === "pending") {
      const obj = {};
      headers.forEach((h, idx) => {
        if (idx === statusCol) return;
        if (!allowedCols.includes(h)) return;

        let val = row[idx];
        if (val instanceof Date) {
          val = Utilities.formatDate(val, Session.getScriptTimeZone(), TIMESTAMP_FORMAT);
        }
        obj[h] = val === "" ? null : val;
      });
      pending.push({ rowNum: i + 2, data: obj });
    }
  });

  if (!pending.length) return Logger.log("‚úÖ No pending rows");

  const res = UrlFetchApp.fetch(`${API_BASE_URL}/push.php`, {
    method: "post",
    contentType: "application/json",
    payload: JSON.stringify({
      table: tableName,
      rows: pending.slice(0, BATCH_SIZE).map(r => r.data)
    }),
    headers: { "X-API-KEY": API_KEY },
    muteHttpExceptions: true
  });

  const json = JSON.parse(res.getContentText());
  if (!json.success) throw new Error(JSON.stringify(json));

  pending.slice(0, BATCH_SIZE).forEach(r => {
    sheet.getRange(r.rowNum, statusCol + 1).setValue("Synced");
  });

  Logger.log(`‚úÖ ${pending.length} rows pushed`);
}

/******************************
 * ‚¨áÔ∏è PULL FUNCTION
 ******************************/
function pullDBToSheet() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
  const tableName = sheet.getName();

  Logger.log(`‚¨áÔ∏è Pulling "${tableName}" from DB`);

  const props = PropertiesService.getScriptProperties();
  const lastSync = props.getProperty(`lastSync_${tableName}`) || "1970-01-01 00:00:00";

  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const idCol = headers.findIndex(h => h.toLowerCase() === "id");
  const statusCol = headers.findIndex(h => h.toLowerCase() === "syncstatus");

  if (idCol === -1) throw new Error("Missing id column");

  const rows = sheet.getLastRow() >= 2
    ? sheet.getRange(2, 1, sheet.getLastRow() - 1, headers.length).getValues()
    : [];

  const idMap = {};
  rows.forEach((r, i) => r[idCol] && (idMap[r[idCol]] = i + 2));

  const res = UrlFetchApp.fetch(`${API_BASE_URL}/pull.php`, {
    method: "post",
    contentType: "application/json",
    payload: JSON.stringify({
      table: tableName,
      lastSync,
      existingIds: Object.keys(idMap)
    }),
    headers: { "X-API-KEY": API_KEY },
    muteHttpExceptions: true
  });

  const json = JSON.parse(res.getContentText());
  if (!json.success) throw new Error(JSON.stringify(json));

  let maxUpdatedAt = lastSync;
  let updated = 0, inserted = 0;

  json.rows.forEach(row => {
    const arr = headers.map(h => row[h] ?? "");
    if (statusCol !== -1) arr[statusCol] = "Synced";

    if (row.updated_at > maxUpdatedAt) maxUpdatedAt = row.updated_at;

    if (idMap[row.id]) {
      sheet.getRange(idMap[row.id], 1, 1, arr.length).setValues([arr]);
      updated++;
    } else {
      sheet.appendRow(arr);
      inserted++;
    }
  });

  props.setProperty(`lastSync_${tableName}`, maxUpdatedAt);
  Logger.log(`‚úÖ Pull done: Updated ${updated}, Inserted ${inserted}`);
}

/******************************
 * ü™Ñ SAFE onEdit
 ******************************/
function onEdit(e) {
  if (!e || !e.range) return;

  const sheet = e.range.getSheet();
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const syncCol = headers.findIndex(h => h.toLowerCase() === "syncstatus");
  if (syncCol === -1) return;

  if (e.range.getRow() > 1 && e.range.getColumn() !== syncCol + 1) {
    sheet.getRange(e.range.getRow(), syncCol + 1).setValue("Pending");
  }
}

/******************************
 * ‚ôªÔ∏è RESET LAST SYNC
 ******************************/
function resetLastSync() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
  PropertiesService.getScriptProperties().deleteProperty(`lastSync_${sheet.getName()}`);
  Logger.log("üîÅ lastSync reset");
}
