/**
 * FULL AUTOMATION v11.0.0 - WITHOUT FLIPBOOK API
 * ✅ Creates posts with Real3D Flipbook shortcodes
 * ✅ Uses [real3dflipbook pdf="URL"] shortcode format
 * ✅ Removes Read/Download links from single posts
 * ✅ Retains all previous logic (categories, breadcrumbs, tables, etc.)
 */

const WP_SITE = "https://tech4learn.com";
const WP_POSTS_ENDPOINT = WP_SITE + "/wp-json/wp/v2/posts";
const WP_CATS_ENDPOINT = WP_SITE + "/wp-json/wp/v2/categories";
const BATCH_SIZE = 80;
const PUBLISH_MODE = "publish";

// ---------------- AUTH ----------------
function getCredentials() {
  return { user: "tech4learn.com", pass: "qqcteWtjJ34JJ0K4T80imE2T" };
}
function getAuthHeaders() {
  const c = getCredentials();
  return {
    "Authorization": "Basic " + Utilities.base64Encode(c.user + ":" + c.pass),
    "Content-Type": "application/json"
  };
}

// ---------------- CONTROLS ----------------
function startSync() {
  const has = ScriptApp.getProjectTriggers().some(t => t.getHandlerFunction() === "syncGroupedTables");
  if (!has) ScriptApp.newTrigger("syncGroupedTables").timeBased().everyMinutes(5).create();
  syncGroupedTables();
}
function stopSync() {
  ScriptApp.getProjectTriggers().forEach(t => {
    if (t.getHandlerFunction() === "syncGroupedTables") ScriptApp.deleteTrigger(t);
  });
}
function resetProgress() {
  PropertiesService.getScriptProperties().setProperty("lastRow", "1");
}
function recreateAll() { resetProgress(); stopSync(); startSync(); }

// ---------------- CORE ----------------
function syncGroupedTables() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    if (!ss) return Logger.log("❌ No active spreadsheet");
    
    let sheet = null;
    for (const s of ss.getSheets()) {
      const vals = s.getDataRange().getValues();
      if (!vals.length) continue;
      const hdrs = vals[0].map(x => (x || "").toString().trim().toLowerCase());
      if (hdrs.includes("main category") && hdrs.includes("pdf url")) { 
        sheet = s; 
        break; 
      }
    }
    if (!sheet) sheet = ss.getActiveSheet();
    
    const data = sheet.getDataRange().getValues();
    if (data.length < 2) return;

    const headersLower = data[0].map(h => (h || "").toString().trim().toLowerCase());
    function findCol(names) {
      for (const n of names) {
        const i = headersLower.findIndex(h => h.indexOf(n.toLowerCase()) !== -1);
        if (i !== -1) return i;
      }
      return -1;
    }

    let levelIdx = [];
    const mainIdx = headersLower.findIndex(h => h === "main category" || h === "menu");
    if (mainIdx !== -1) levelIdx.push(mainIdx);
    headersLower.forEach((h, i) => {
      if (i !== mainIdx && (h.startsWith("sub") || h.includes("subcategory"))) levelIdx.push(i);
    });

    const idx = {
      levels: levelIdx.slice(0, 6),
      post: findCol(["post title", "post name"]),
      pdfTitle: findCol(["pdf title", "pdf file name"]),
      pdfURL: findCol(["pdf url", "pdf link"]),
      singleFlag: findCol(["create single post", "single post", "create post"]),
      metaTitle: findCol(["meta title"]),
      metaDesc: findCol(["meta description"]),
      focusKey: findCol(["focus keyword"]),
      canonical: findCol(["canonical url"]),
      tableHead: findCol(["table headings", "headers", "columns"]),
      syncStatus: findCol(["sync status", "status"])
    };

    // Debug: Log found indices
    Logger.log("Found indices: " + JSON.stringify(idx));

    const props = PropertiesService.getScriptProperties();
    let lastRow = parseInt(props.getProperty("lastRow") || "1", 10);
    if (isNaN(lastRow) || lastRow < 1) lastRow = 1;

    const nodesMap = {};
    function nodeKey(p) { return p.join(" || "); }
    function ensureNode(path) {
      const k = nodeKey(path);
      if (!nodesMap[k]) nodesMap[k] = { path: [...path], childNodes: new Set(), childLeaves: [] };
      return nodesMap[k];
    }

    const maxRow = Math.min(data.length - 1, lastRow + BATCH_SIZE);
    Logger.log(`Processing rows ${lastRow + 1} to ${maxRow}`);
    
    // Build nodes structure
    for (let r = lastRow + 1; r <= maxRow; r++) {
      const row = data[r];
      if (!row || row.length === 0) continue;
      
      const status = safe(row, idx.syncStatus).toLowerCase();
      if (["✅ synced", "synced", "done"].includes(status)) continue;

      const path = [];
      for (const li of idx.levels) {
        const v = safe(row, li);
        if (v) path.push(v);
      }

      const postName = safe(row, idx.post);
      const pdfURL = safe(row, idx.pdfURL);
      if (!pdfURL) {
        Logger.log(`❌ Skipping row ${r}: No PDF URL`);
        continue;
      }

      const pdfTitle = safe(row, idx.pdfTitle) || postName || (path.length ? path[path.length - 1] : "PDF");
      const meta = {
        title: safe(row, idx.metaTitle),
        desc: safe(row, idx.metaDesc),
        key: safe(row, idx.focusKey),
        canonical: safe(row, idx.canonical)
      };
      const singleFlag = ["yes", "y", "true", "1"].includes(safe(row, idx.singleFlag).toLowerCase());
      const tableHeadRaw = safe(row, idx.tableHead);
      const tableHeaders = tableHeadRaw ? tableHeadRaw.split(",").map(h => h.trim()) : [];

      // Build category hierarchy
      for (let i = 1; i <= path.length; i++) {
        const pref = path.slice(0, i);
        ensureNode(pref);
        if (i > 1) ensureNode(path.slice(0, i - 1)).childNodes.add(nodeKey(pref));
      }

      const node = ensureNode(path.length ? path : [pdfTitle]);
      node.childLeaves.push({ 
        title: pdfTitle, 
        pdfURL, 
        meta, 
        createSingle: singleFlag, 
        tableHeaders, 
        rowIndex: r 
      });
      props.setProperty("lastRow", String(r));
    }

    const headersAuth = getAuthHeaders();
    const createdNodes = {};
    const leafMap = {};
    const nodeKeys = Object.keys(nodesMap).sort((a, b) => a.split(" || ").length - b.split(" || ").length);

    Logger.log("Processing " + nodeKeys.length + " nodes");

    // Pass 1: Create category posts
    for (const nk1 of nodeKeys) {
      const node1 = nodesMap[nk1];
      const title = node1.path.join(" | ");
      const slug = slugify(title);
      const catIDs = ensureCategoryPath(node1.path, headersAuth);
      const assignedCat = catIDs.length ? [catIDs[catIDs.length - 1]] : [];

      const payload = {
        title,
        content: `<h2>${escapeHtml(title)}</h2>Generating content...`,
        status: PUBLISH_MODE,
        slug,
        categories: assignedCat
      };
      createdNodes[nk1] = createOrUpdatePost(slug, payload, headersAuth);
      if (createdNodes[nk1]) {
        Logger.log(`✅ Created/Updated category post: ${title}`);
      }
    }

    // Pass 2: Create single posts with flipbook shortcodes
    for (const nk2 of nodeKeys) {
      const node2 = nodesMap[nk2];
      if (!node2.childLeaves?.length) continue;
      
      for (let j = 0; j < node2.childLeaves.length; j++) {
        const leaf = node2.childLeaves[j];
        if (!leaf.createSingle) continue;

        const postTitle = leaf.title;
        const slug2 = slugify(postTitle);
        const catIDs2 = ensureCategoryPath(node2.path, headersAuth);
        const assignedCat2 = catIDs2.length ? [catIDs2[catIDs2.length - 1]] : [];

        // Build breadcrumb
        const breadcrumbHTML = buildBreadcrumbHtml([...node2.path, leaf.title], createdNodes);

        // Create flipbook shortcode - using proper Real3D Flipbook format
        const flipbookShortcode = `[real3dflipbook pdf="${leaf.pdfURL}" title="${escapeHtml(leaf.title)}"]`;
        
        // Build post content with breadcrumb and flipbook
        const html2 = breadcrumbHTML +
          `<h2>${escapeHtml(postTitle)}</h2>
          <div class="flipbook-container">
            ${flipbookShortcode}
          </div>
          <p><em>View the document using the flipbook viewer above.</em></p>`;

        const postPayload = {
          title: postTitle,
          content: html2,
          status: PUBLISH_MODE,
          slug: slug2,
          categories: assignedCat2
        };

        // Add meta fields if available
        if (leaf.meta.title) {
          postPayload.meta = {
            _yoast_wpseo_title: leaf.meta.title,
            _yoast_wpseo_metadesc: leaf.meta.desc,
            _yoast_wpseo_focuskw: leaf.meta.key
          };
        }

        const singlePost = createOrUpdatePost(slug2, postPayload, headersAuth);

        if (singlePost) {
          leafMap[nk2 + "||" + j] = singlePost;
          if (idx.syncStatus !== -1) {
            sheet.getRange(leaf.rowIndex + 1, idx.syncStatus + 1).setValue("✅ Synced");
          }
          Logger.log(`✅ Created single post with flipbook: ${postTitle}`);
        } else {
          Logger.log(`❌ Failed to create single post: ${postTitle}`);
        }
      }
    }

    // Pass 3: Update category posts with tables
    for (const nk3 of nodeKeys) {
      const node3 = nodesMap[nk3];
      const nodePost = createdNodes[nk3];
      if (!nodePost) continue;

      let html = buildBreadcrumbHtml(node3.path, createdNodes) + `<h2>${escapeHtml(node3.path.join(" | "))}</h2>`;
      
      // Add subcategories table if exists
      if (node3.childNodes.size > 0) {
        const css = tableCSS();
        html += css + "<h3>Subcategories</h3><table class='auto-table'><thead><tr><th>#</th>";
        html += Array(node3.path.length + 1).fill(0).map((_, i) => `<th>Level ${i + 1}</th>`).join("");
        html += "<th>Open</th></tr></thead><tbody>";
        let c = 1;
        node3.childNodes.forEach(ck => {
          const child = nodesMap[ck];
          const cp = createdNodes[ck];
          html += `<tr><td>${c++}</td>`;
          // Fill all level columns
          for (let i = 0; i < node3.path.length + 1; i++) {
            if (i < child.path.length) {
              html += `<td>${escapeHtml(child.path[i])}</td>`;
            } else {
              html += `<td></td>`;
            }
          }
          html += `<td><a href="${cp ? cp.link : "#"}" target="_blank">Open</a></td></tr>`;
        });
        html += "</tbody></table>";
      }

      // Add items table if exists
      if (node3.childLeaves.length > 0) {
        const leaf = node3.childLeaves[0];
        const headers = leaf.tableHeaders.length ? leaf.tableHeaders : node3.path.map((_, i) => "Level " + (i + 1));
        html += "<h3>Items</h3>" + buildLeafTableHtml(node3.childLeaves, node3.path, headers, leafMap, nk3);
      }

      const updateSuccess = updatePostContent(nodePost.id, html, headersAuth);
      if (updateSuccess) {
        Logger.log(`✅ Updated category table: ${node3.path.join(" | ")}`);
      }
    }

    Logger.log("✅ Sync completed successfully");

  } catch (e) {
    Logger.log("❌ syncGroupedTables error: " + e.toString());
    Logger.log("Stack: " + e.stack);
  }
}

// ---------------- WORDPRESS FUNCTIONS ----------------
function ensureCategoryPath(path, headers) {
  let ids = [], parent = 0;
  for (let name of path) {
    name = name.trim(); 
    if (!name) continue;
    
    try {
      // Search for existing category
      const searchUrl = WP_CATS_ENDPOINT + "?search=" + encodeURIComponent(name) + "&parent=" + parent;
      const searchResponse = UrlFetchApp.fetch(searchUrl, { headers, muteHttpExceptions: true });
      
      let categoryId = null;
      if (searchResponse.getResponseCode() === 200) {
        const categories = JSON.parse(searchResponse.getContentText());
        const existingCat = categories.find(cat => 
          cat.name.toLowerCase() === name.toLowerCase() && cat.parent === parent
        );
        if (existingCat) {
          categoryId = existingCat.id;
          Logger.log(`✅ Found existing category: ${name} (ID: ${categoryId})`);
        }
      }
      
      // Create category if not exists
      if (!categoryId) {
        const createPayload = {
          name: name,
          parent: parent,
          slug: slugify(name)
        };
        
        const createResponse = UrlFetchApp.fetch(WP_CATS_ENDPOINT, {
          method: "POST", 
          headers: headers, 
          payload: JSON.stringify(createPayload), 
          muteHttpExceptions: true
        });
        
        if (createResponse.getResponseCode() === 200 || createResponse.getResponseCode() === 201) {
          const newCategory = JSON.parse(createResponse.getContentText());
          categoryId = newCategory.id;
          Logger.log(`✅ Created category: ${name} (ID: ${categoryId})`);
        } else {
          Logger.log(`❌ Failed to create category: ${name} - ${createResponse.getContentText()}`);
        }
      }
      
      if (categoryId) {
        parent = categoryId;
        ids.push(categoryId);
      }
    } catch (e) { 
      Logger.log("⚠️ ensureCategoryPath error for '" + name + "': " + e.toString()); 
    }
  }
  return ids;
}

function createOrUpdatePost(slug, payload, headers) {
  try {
    // Search for existing post by slug
    const searchUrl = WP_POSTS_ENDPOINT + "?slug=" + encodeURIComponent(slug);
    const searchResponse = UrlFetchApp.fetch(searchUrl, { headers, muteHttpExceptions: true });
    
    if (searchResponse.getResponseCode() === 200) {
      const posts = JSON.parse(searchResponse.getContentText());
      if (posts && posts.length > 0) {
        // Update existing post
        const postId = posts[0].id;
        const updateResponse = UrlFetchApp.fetch(WP_POSTS_ENDPOINT + "/" + postId, {
          method: "PUT", 
          headers: headers, 
          payload: JSON.stringify(payload), 
          muteHttpExceptions: true
        });
        
        if (updateResponse.getResponseCode() === 200) {
          const updatedPost = JSON.parse(updateResponse.getContentText());
          Logger.log(`✅ Updated existing post: ${payload.title}`);
          return { id: updatedPost.id, link: updatedPost.link };
        }
      }
    }
    
    // Create new post
    const createResponse = UrlFetchApp.fetch(WP_POSTS_ENDPOINT, {
      method: "POST", 
      headers: headers, 
      payload: JSON.stringify(payload), 
      muteHttpExceptions: true
    });
    
    if (createResponse.getResponseCode() === 200 || createResponse.getResponseCode() === 201) {
      const newPost = JSON.parse(createResponse.getContentText());
      Logger.log(`✅ Created new post: ${payload.title}`);
      return { id: newPost.id, link: newPost.link };
    } else {
      Logger.log(`❌ Failed to create post: ${payload.title} - ${createResponse.getContentText()}`);
    }
    
    return null;
  } catch (e) { 
    Logger.log("❌ createOrUpdatePost error: " + e.toString()); 
    return null; 
  }
}

function updatePostContent(id, html, headers) {
  try {
    const response = UrlFetchApp.fetch(WP_POSTS_ENDPOINT + "/" + id, {
      method: "PUT", 
      headers: headers, 
      payload: JSON.stringify({ content: html }),
      muteHttpExceptions: true
    });
    
    return response.getResponseCode() === 200;
  } catch (e) { 
    Logger.log("❌ updatePostContent error: " + e.toString()); 
    return false;
  }
}

// ---------------- HELPER FUNCTIONS ----------------
function buildBreadcrumbHtml(path, createdNodes) {
  if (!path.length) return "";
  let crumb = `<nav class="breadcrumb" style="margin-bottom:10px;font-size:14px;">
    <a href="${WP_SITE}">Home</a>`;
  for (let i = 0; i < path.length; i++) {
    const subPath = path.slice(0, i + 1);
    const key = subPath.join(" || ");
    const node = createdNodes[key];
    if (node) {
      if (i < path.length - 1)
        crumb += ` › <a href="${node.link}">${escapeHtml(path[i])}</a>`;
      else
        crumb += ` › <span style="color:#777;">${escapeHtml(path[i])}</span>`;
    } else {
      crumb += ` › <span style="color:#777;">${escapeHtml(path[i])}</span>`;
    }
  }
  return crumb + "</nav>";
}

function tableCSS() {
  return '<style>table.auto-table{width:100%;border-collapse:collapse;margin:10px 0;font-family:Arial;}' +
         '.auto-table th,.auto-table td{padding:8px;border:1px solid #ccc;}.auto-table th{background:#f0f0f0;}</style>';
}

function buildLeafTableHtml(items, path, headers, leafMap, nkKey) {
  const css = tableCSS();
  let head = '<tr><th>#</th>';
  for (let h of headers) head += `<th>${escapeHtml(h)}</th>`;
  head += '<th>Title</th><th>Read</th><th>Download</th></tr>';
  let rows = "";
  for (let j = 0; j < items.length; j++) {
    const it = items[j];
    const singlePost = leafMap[nkKey + "||" + j];
    const link = singlePost ? singlePost.link : "#";
    rows += `<tr><td>${j + 1}</td>`;
    // Fill path columns
    for (let i = 0; i < headers.length; i++) {
      if (i < path.length) {
        rows += `<td>${escapeHtml(path[i])}</td>`;
      } else {
        rows += `<td></td>`;
      }
    }
    rows += `<td><a href="${link}" target="_blank">${escapeHtml(it.title)}</a></td>
      <td><a href="${it.pdfURL}" target="_blank">Read</a></td>
      <td><a href="${it.pdfURL}" download>Download</a></td></tr>`;
  }
  return css + `<table class="auto-table"><thead>${head}</thead><tbody>${rows}</tbody></table>`;
}

function safe(r, i) { 
  if (i === -1 || !r || i >= r.length) return ""; 
  const v = r[i]; 
  return v ? v.toString().trim() : ""; 
}

function slugify(t) { 
  return (t || "").toString().trim()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .replace(/[^\w\s-]/g, "")
    .replace(/\s+/g, "-")
    .replace(/-+/g, "-")
    .replace(/^-+|-+$/g, "")
    .toLowerCase(); 
}

function escapeHtml(t) { 
  return (t || "").replace(/[&<>"']/g, m => ({ 
    "&": "&amp;", 
    "<": "&lt;", 
    ">": "&gt;", 
    '"': "&quot;", 
    "'": "&#039;" 
  }[m])); 
}
